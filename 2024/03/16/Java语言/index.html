<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="Hexo Theme Keep"><meta name="author" content="一个想当厨子的码农"><title>Java基础 | CodeCook</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/deploy-provider/logo.png"><script class="keep-theme-configurations">const KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"example.com",root:"/",language:"zh-CN",path:"search.json"},KEEP.theme_config={base_info:{primary_color:"#0066cc",title:"CodeCook",author:"一个想当厨子的码农",avatar:"/images/deploy-provider/avatar.png",logo:"/images/deploy-provider/logo.png",favicon:"/images/deploy-provider/logo.png"},menu:{home:"/ || fa-solid fa-house",archives:"/archives || fa-solid fa-box-archive",tags:"/tags || fa-solid fa-tags",links:"/links || fa-solid fa-link",about:"/about || fa-solid fa-user-graduate",tools:"/tools || fa-solid fa-screwdriver-wrench"},first_screen:{enable:!0,background_img:"/images/bg.svg",background_img_dark:"/images/bg.svg",description:"因为热爱，所以分享；|| 因为分享，更加热爱。",hitokoto:!1},social_contact:{enable:!0,links:{github:"https://github.com/dettry",weixin:null,qq:null,weibo:null,zhihu:null,twitter:null,x:null,facebook:null,email:null}},scroll:{progress_bar:!1,percent:!0,hide_header:!1},home:{category:!1,tag:!0,announcement:null,post_datetime:"updated"},post:{author_badge:{enable:!0,level_badge:!0,custom_badge:["One","Two","Three"]},word_count:{wordcount:!0,min2read:!0},datetime_format:"YYYY-MM-DD HH:mm:ss",copyright_info:!1,share:!0,reward:{enable:!0,img_link:"/images/deploy-provider/paycode.png",text:null}},code_block:{tools:{enable:!0,style:"mac"},highlight_theme:"obsidian"},toc:{enable:!0,number:!1,expand_all:!0,init_open:!0,layout:"right"},website_count:{busuanzi_count:{enable:!0,site_uv:!0,site_pv:!0,page_pv:!0}},local_search:{enable:!0,preload:!0},comment:{enable:!0,use:"waline",valine:{appid:null,appkey:null,server_urls:null,placeholder:null},gitalk:{github_id:null,github_admins:null,repository:null,client_id:null,client_secret:null,proxy:null},twikoo:{env_id:null,region:null,version:"1.6.21"},waline:{server_url:"https://blog-comment-eight-azure.vercel.app",reaction:!0,version:2},giscus:{repo:null,repo_id:null,category:"Announcements",category_id:null,reactions_enabled:!1},artalk:{server:null},disqus:{shortname:null}},rss:{enable:!0},lazyload:{enable:!0},cdn:{enable:!0,provider:"cndjs"},pjax:{enable:!1},footer:{since:2020,word_count:!0,icp:{enable:!1,record_code:null,url:"https://beian.miit.gov.cn"},site_deploy:{enable:!0,provider:"github",url:"https://github.com/"},shields_style:{enable:!1,custom:[{link_url:null,img_url:null}]}},inject:{enable:!1,css:[null],js:[null]},root:"",source_data:{tools:[{category:"聊天 AI"},{name:"ChatGPT",link:"https://chat.openai.com/",description:"OpenAI 旗下 AI 聊天对话工具",image:"/images/tools/chatgpt.svg"},{name:"Gemini",link:"https://gemini.google.com/app",description:"Google 旗下 AI 聊天对话工具",image:"/images/tools/gemini.svg"},{category:"图标工具"},{name:"iconfont",link:"https://www.iconfont.cn/",description:"阿里妈妈MUX倾力打造的矢量图标管理 交流平台",image:"/images/tools/iconfont.svg"},"......","......","......"]},version:"4.1.1"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"},KEEP.language_code_block={copy:"复制代码",copied:"已复制",fold:"折叠代码块",folded:"已折叠"},KEEP.language_copy_copyright={copy:"复制版权信息",copied:"已复制",title:"原文标题",author:"原文作者",link:"原文链接"}</script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="progress-bar-container"></div><main class="page-container border-box"><div class="page-main-content border-box"><div class="page-main-content-top"><header class="header-wrapper"><div class="border-box header-content"><div class="left border-box"><a class="logo-image border-box" href="/"><img src="/images/deploy-provider/logo.png"> </a><a class="site-name border-box" href="/">CodeCook</a></div><div class="right border-box"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/"><i class="menu-icon fa-solid fa-house"></i> 首页</a></li><li class="menu-item"><a href="/archives"><i class="menu-icon fa-solid fa-box-archive"></i> 归档</a></li><li class="menu-item"><a href="/tags"><i class="menu-icon fa-solid fa-tags"></i> 标签</a></li><li class="menu-item"><a href="/links"><i class="menu-icon fa-solid fa-link"></i> 友链</a></li><li class="menu-item"><a href="/about"><i class="menu-icon fa-solid fa-user-graduate"></i> 关于</a></li><li class="menu-item"><a href="/tools"><i class="menu-icon fa-solid fa-screwdriver-wrench"></i> 工具</a></li><li class="menu-item search search-popup-trigger"><i class="fas search fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li><li class="drawer-menu-item flex-center"><a href="/about">关于</a></li><li class="drawer-menu-item flex-center"><a href="/tools">工具</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle border-box"><div class="main-content border-box"><div class="fade-in-down-animation"><div class="post-page-container border-box"><div class="post-content-container border-box"><div class="post-content-bottom border-box"><div class="post-title">Java基础</div><div class="post-header border-box"><div class="avatar-box border-box"><img src="/images/deploy-provider/avatar.png"></div><div class="info-box"><div class="author border-box"><span class="name">一个想当厨子的码农</span> <span class="author-badge">Lv1</span></div><div class="meta-info border-box"><div class="post-meta-info-container border-box post"><div class="post-meta-info border-box"><span class="meta-info-item post-create-date"><i class="icon fa-solid fa-calendar-plus"></i>&nbsp; <span class="datetime">2024-03-16 16:39:36</span> </span><span class="meta-info-item post-update-date"><i class="icon fa-solid fa-file-pen"></i>&nbsp; <span class="datetime" data-updated="Sat May 04 2024 14:24:36 GMT+0800">2024-05-04 14:24:36</span> </span><span class="post-tag meta-info-item border-box"><ul class="post-tag-ul"><li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/java/">java</a></li></ul></span><span class="meta-info-item post-pv"><i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div></div><div class="post-content keep-markdown-body"><h1>Java语言</h1><h2 id="1-语言基础">1. 语言基础</h2><h3 id="1-1-基础语法">1.1 基础语法</h3><ul><li><strong>数据类型</strong></li></ul><p>数据类型分为两类：基本数据类型、引用数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java中的基本数据类型只有**四类八种**</span><br><span class="line"></span><br><span class="line">整数型：byte、short、int、long</span><br><span class="line"></span><br><span class="line">short占两字节</span><br><span class="line"></span><br><span class="line">int 占用四个字节</span><br><span class="line"></span><br><span class="line">long 占用八个字节</span><br></pre></td></tr></table></figure><ul><li>浮点型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浮点型有两种：float、double</span><br><span class="line">float占用四位，double占用八位</span><br></pre></td></tr></table></figure><ul><li>字符型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符型为char，char类型是一个单一的16位Unicode字符。</span><br></pre></td></tr></table></figure><ul><li>布尔型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its &quot;size&quot; isn&#x27;t something that&#x27;s precisely defined.</span><br><span class="line"> </span><br><span class="line">翻译：布尔数据类型只有两种可能的值：true和false。使用这个数据类型用于追踪true/false状况的简单标识。这个数据类型表示1bit的信息，但是它的”大小“没有被精确定义。</span><br></pre></td></tr></table></figure><p><img lazyload alt="image" data-src="C:%5CUsers%5C85793%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20231228151136962.png" alt="image-20231228151136962"></p><ul><li>引用数据类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要不是基本数据类型就是引用数据类型。</span><br></pre></td></tr></table></figure><ul><li>自动类型转换（隐式）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换规则： 数据范围必须是**从小到大**，即由小的转换成大的，自动转换。</span><br></pre></td></tr></table></figure><ul><li>强制类型转换（显式）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意事项：</span><br><span class="line">1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。 </span><br><span class="line">2. byte/short/char这三种类型都可以发生数学运算，例如加法“+”。</span><br><span class="line">3. byte/short/char这三种类型在运算的时候都会首先提升成为int类型，然后再计算。</span><br><span class="line">例：byte+byte-&gt;int+int-&gt;int</span><br><span class="line">4. boolean类型不能发生数据类型转换</span><br></pre></td></tr></table></figure><ul><li>运算符的优先级</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单目（一元）&gt;算术运算符&gt;移位&gt;关系&gt;位&gt;条件(三元)&gt;赋值</span><br></pre></td></tr></table></figure><ul><li><strong>基础语法</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 大小写敏感： Java是大小写敏感的语言，例如Hello和hello是不同的，这其实就是Java的字符串表示方式。</span><br><span class="line">2. 类名：类名使用 UpperCamelCase 风格，但以下情形例外： DO / BO / DTO / VO / AO /</span><br><span class="line">PO / UID 等。</span><br><span class="line">正例： ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion</span><br><span class="line">反例： forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion</span><br><span class="line">3. 包名：包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用</span><br><span class="line">单数形式，但是类名如果有复数含义，类名可以使用复数形式。</span><br><span class="line">正例： 应用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils（此规则参考 spring 的框架结构）</span><br><span class="line">4. 方法名、变量名、参数名：都统一使用 lowerCamelCase 风格</span><br><span class="line">正例： localValue / getHttpMessage() / inputUserId</span><br></pre></td></tr></table></figure><ul><li><strong>方法</strong></li><li>构造方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">作用：用来创建对象的</span><br><span class="line">注意事项：</span><br><span class="line">1. 构造方法的名称必须和所在类的名称完全一样，就连大小写也要一样</span><br><span class="line">2. 构造方法不要写返回值类型，连void都不写</span><br><span class="line">3. 构造方法不能return一个具体的返回值</span><br><span class="line">4. 如果没有编写任何构造方法，那么编译器会默认分配一个构造方法</span><br><span class="line">5. 一旦编写了一个构造方法，那么编译器就不会再分配任何构造方法</span><br></pre></td></tr></table></figure><ul><li>静态方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态方法又叫类方法。</span><br></pre></td></tr></table></figure><ul><li>非静态方法（成员方法）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法之间的调用注意事项：</span><br><span class="line">1. 同类型的方法之间可以直接调用</span><br><span class="line">2. 静态方法调用非静态方法需要先new一个对象，然后通过对象进行调用。</span><br><span class="line">3. 非静态方法可以直接调用静态方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>方法重载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">多个方法的名称相同，但是参数列表不一样。</span><br><span class="line">方法重载与下列因素相关：</span><br><span class="line">1. 参数个数不同</span><br><span class="line">2. 参数类型不同</span><br><span class="line">3. 多参数类型顺序不同</span><br><span class="line">方法重载与下列因素无关：</span><br><span class="line">1. 与参数名称无关</span><br><span class="line">2. 与方法的返回值类型无关</span><br><span class="line">3. </span><br></pre></td></tr></table></figure><ul><li>参数传递机制</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java的参数传递机制都是：值传递</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>数组</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Java的内存划分成为5个部分：</span><br><span class="line">1. 栈内存（stack）：存放的都是方法中的局部变量。  方法的运行一定要在栈中运行。</span><br><span class="line">         局部变量： 方法的参数、方法&#123;&#125;内部的变量</span><br><span class="line">2. 堆内存（heap）: 凡是new出来的东西都在堆当中。</span><br><span class="line">        堆内存里面的东西都有一个地址值：16进制</span><br><span class="line">        堆内存中的数据都有默认值。规则：</span><br><span class="line">                 整数         默认0</span><br><span class="line">                 浮点数       默认0.0</span><br><span class="line">                 字符         默认&#x27;\u0000&#x27;</span><br><span class="line">                 布尔         默认false</span><br><span class="line">                 引用类型      默认null</span><br><span class="line">3. 方法区（）: 存储.class相关信息，包含方法的信息。</span><br><span class="line"></span><br><span class="line">4. 本地方法栈（）： 与操作系统相关</span><br><span class="line">5. 寄存器（）： 与cpu相关</span><br></pre></td></tr></table></figure><h3 id="1-2-面向对象">1.2 面向对象</h3><ul><li><strong>特点</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成指挥者。</span><br></pre></td></tr></table></figure><p><strong>面向对象语言包含三大基本特征：</strong></p><ul><li><p>封装</p><p>就是将一些细节信息隐藏起来，对外界不可见。</p><ol><li>方法就是一种封装</li><li>private关键字也是一种封装</li></ol><p>一旦使用private进行修饰，那么本类当中仍然可以随意访问，但是超出了本类范围之外就不能再直接访问了。</p><p>可以使用getter/setter方法间接访问private成员变量。</p></li><li><p>继承</p></li></ul><p>​ 继承是多态的前提，如果没有继承，就没有多态。</p><p>​ 继承主要解决的问题就是：<strong>共性抽取</strong></p><pre><code>  **变量重名的解决方法**
</code></pre><p>​ 局部变量： 直接写成员变量名</p><p>​ 本类的成员变量： this.成员变量名</p><p>​ 父类的成员变量： super.成员变量名</p><pre><code> **重写（override）**    
</code></pre><p>​ 概念：在继承关系中，方法的名称一样，参数列表一样。</p><p>​ 方法重写（override）：方法名称一样，参数列表也一样。（覆盖重写）</p><p>​ 方法重载（overload）：方法名称一样，参数列表不一样。</p><pre><code> **覆盖重写的注意事项：**

          1. 必须保证父子类之间的方法名称相同，参数列表也相同。
          2. 子类方法的权限必须大于等于父类方法的权限修饰符。
</code></pre><p>​ public&gt;protected&gt;(default)&gt;private</p><p>​ 备注：（default）不是关键字default，而是什么修饰符也不用。</p><p>​	<strong>继承关系中，父子类构造方法的访问特点：</strong></p><pre><code>1. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造
</code></pre><p>​ 注意事项：</p><p>​ 子类必须调用父类构造方法，不写则默认super（），写了则用写的指定的super调用，super只能有一个，还必须是第一个。</p><p>​ <strong>Java继承的三大特点</strong></p><ol><li>Java语言是单继承的，即一个类的直接父类只能有唯一一个。</li><li>Java语言可以多级继承。</li><li>一个子类只能有一个父类，但是一个父类可以有多个子类。</li></ol><p>如果父类当中的方法不确定如何进行{}方法体实现，那么这就应该是一个抽象方法。</p><p>抽象类：抽象方法所在的类必须是抽象类才行。在class之前写上abstract即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="comment">//这是一个抽象方法，代表吃东西，但是具体吃什么不确定。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何使用抽象类和抽象方法</strong></p><ol><li><p>不能直接创建new抽象类对象</p></li><li><p>必须用一个子类来继承抽象父类。</p></li><li><p>子类必须覆盖重写抽象父类当中的所有抽象方法。</p><p>覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号</p><ol start="4"><li>创建子类对象进行使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>多态</li></ul><p>一个对象拥有多种形态，这个就叫对象的多态性。</p><p><strong>代码当中体现多态性，其实就是一句话，父类引用指向子类对象。</strong></p><p>格式：</p><p>父类名称 对象名 = new 子类名称（）；</p><p>或者</p><p>接口名称 对象名 = new 实现类名称（）；</p><p>访问成员变量和方法的规则：</p><p>访问成员方法：等号右边new的谁，优先用谁，没有则向上找。</p><p>直接通过对象名称访问成员变量：等号左边是谁，优先用谁，没有则向上找。</p><p>间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。</p><p><strong>对象的转型</strong></p><ol><li>对象的向上转型，其实就是多态写法：</li></ol><p>格式：父类名称 对象名 = new 子类名称（）；</p><ol start="2"><li>对象的向下转型，其实是一个【还原】的动作</li></ol><p>格式：子类名称 对象名 = （子类名称） 父类对象</p><p>注意事项：</p><ol><li>必须保证对象本来创建的时候就是A,才能向下转型成为A。</li><li>如果创建的对象本来不是A，非要向下转型为A就会报错。</li></ol><p><strong>四种权限修饰符</strong></p><p><strong>内部类</strong></p><ol><li>成员内部类</li><li>局部内部类（包含匿名内部类）</li></ol><p>成员内部类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">      修饰符 class 内部类名称&#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">注意：内用外，随意访问； 外用内，需要内部类对象。</span><br></pre></td></tr></table></figure><p>局部内部类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">      修饰符 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">              class 局部内部类名称&#123;</span><br><span class="line">      </span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">接口名称 对象名称 =  <span class="keyword">new</span> 接口名称（）&#123;</span><br><span class="line"> 覆盖重写所有抽象方法</span><br><span class="line">&#125;；</span><br><span class="line">注意事项：</span><br><span class="line">    <span class="number">1.</span> 匿名内部类在创建对象的时候只能使用唯一一次</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li><strong>类和对象</strong></li></ul><p><strong>什么是类</strong></p><ul><li>类：是一组相关属性和行为的集合。</li></ul><p>现实中，描述一类事物：</p><ul><li><p>属性：就是该事物的特征信息。（是什么）（成员变量）</p></li><li><p>行为：就是该事物能够做什么。（成员方法）成员方法不要写static关键字。</p></li></ul><p><strong>什么是对象</strong></p><ul><li>对象：是一类事物的具体体香。对象是类的一个实例。</li></ul><p><strong>类与对象的关系</strong></p><ul><li>类是对一类事物的描述，是抽象的。</li><li>对象是一类事物的实例，是具体的。</li><li>类是对象的模板，对象是类的实体。</li></ul><p><strong>成员变量和局部变量的区别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. 定义的位置不一样</span><br><span class="line">局部变量：在方法的内部</span><br><span class="line">成员变量：在方法的外部，直接写在类当中。</span><br><span class="line"></span><br><span class="line">2. 作用范围不一样</span><br><span class="line">局部变量：只有方法当中才可以使用</span><br><span class="line">成员变量：整个类全可以通用</span><br><span class="line"></span><br><span class="line">3. 默认值不一样</span><br><span class="line">局部变量：没有默认值，如果要想使用，必须手动赋值</span><br><span class="line">成员变量：如果没有赋值，会有默认值，规则和数组一样。</span><br><span class="line"></span><br><span class="line">4. 内存的位置不一样</span><br><span class="line">局部变量：位于栈内存</span><br><span class="line">成员变量：位于堆内存</span><br><span class="line"></span><br><span class="line">5. 生命周期不一样</span><br><span class="line">局部变量：随着方法进栈而生，随着方法出栈而亡</span><br><span class="line">成员变量：随着对象创建而生，随着对象被垃圾回收而亡。</span><br></pre></td></tr></table></figure><ul><li><strong>对象数组</strong></li></ul><p>数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变。</p><ul><li><strong>字符串</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 字符串的内容不可变</span><br><span class="line">2. 字符串可以共享使用</span><br><span class="line">3. 字符串效果上相当于char[]字符数组，但是底层原理是byte[]字节数组</span><br><span class="line">在堆内存中有一个字符串常量池。</span><br><span class="line">常用方法：</span><br><span class="line">equals</span><br><span class="line">length()</span><br><span class="line">concat:连接字符串</span><br><span class="line">charAt:</span><br><span class="line">indexOf:</span><br></pre></td></tr></table></figure><p>StringBuilder类：字符串缓冲区，可以提高字符串的效率</p><p>常用方法：</p><p>append</p><p>toString</p><ul><li><strong>静态关键字static</strong></li></ul><p>一旦用了static关键字，那么这样的内容不再属于对象自己，</p><p>而是属于类的，所以凡是本类的对象，都共享同一份。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一旦使用static修饰成员方法，那么就成为了静态方法，静态方法不属于对象，而是属于类的。</span><br><span class="line"></span><br><span class="line">如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。</span><br><span class="line"></span><br><span class="line">如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。</span><br><span class="line"></span><br><span class="line">无论是成员变量还是方法，如果有了static，都推荐使用类名称进行调用。</span><br><span class="line"></span><br><span class="line">静态变量：类名称.静态变量</span><br><span class="line"></span><br><span class="line">静态方法：类名称.静态方法（）</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line">1. 静态方法当中不能使用this</span><br></pre></td></tr></table></figure><p><strong>静态代码块</strong></p><p>特点：当第一次用到本类时，静态代码块执行唯一的一次。</p><p>静态内容总是优先于非静态，所以静态代码块比构造方法先执行。</p><p>静态代码块的用途：</p><p>用来一次性的对静态成员变量进行赋值。</p><p><strong>Arrays工具类</strong></p><p>toString(数组)：将参数数组变成字符串（按照默认格式：[元素1，元素2,…]）</p><h3 id="1-3-接口">1.3 接口</h3><p>接口就是多个类的公共规范</p><p>接口是一种引用数据类型，最重要的内容就是其中的：<strong>抽象方法</strong>。</p><p>从Java 8开始，接口 里允许定义默认方法。</p><p>备注：接口当中的默认方法可以解决接口升级的问题。</p><p><strong>什么是接口升级？</strong></p><p>就是已经投入使用的接口，想在其中添加新的方法，这时如果直接添加，会导致所有实现该接口的类报错，但是使用default默认方法可以解决此问题，并且该方法也可以被其他接口实现类覆盖重写。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Java 9 开始，接口中允许定义私有方法。</p><ol><li>普通私有方法，解决多个默认方法之间的重复代码问题</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>静态私有方法：解决多个静态方法之间重复代码问题</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line"></span><br><span class="line">方法体</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口与接口之间是多继承的。</p><ul><li><strong>日期时间类</strong></li></ul><p>date</p><ul><li><strong>DateFormat类</strong></li></ul><p>日期时间格式化类</p><ul><li><strong>包装类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基本类型             对应的包装类</span><br><span class="line"><span class="type">byte</span>                  Byte</span><br><span class="line"><span class="type">short</span>                 Short</span><br><span class="line"><span class="type">int</span>                   Integer</span><br><span class="line"><span class="type">long</span>                  Long</span><br><span class="line"><span class="type">float</span>                 Float</span><br><span class="line"><span class="type">double</span>                Double</span><br><span class="line"><span class="type">char</span>                  Character</span><br><span class="line"><span class="type">boolean</span>               Boolean</span><br></pre></td></tr></table></figure><p><strong>装箱与拆箱</strong></p><p>装箱：从基本类型转换成对应的包装类对象</p><p>拆箱：从包装类对象转换为对应的基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i= Integer.valueOf(<span class="number">4</span>)<span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i.intValue();<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><h3 id="1-4-容器">1.4 容器</h3><ul><li>collection集合</li></ul><p>**集合：**集合是Java中提供的一种容器，可以用来存储多个数据。</p><p>集合和数组既然都是容器，它们有啥区别？</p><ol><li>数组的长度是固定的，集合的长度是可变的</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象，而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ol><p><strong>常用共性方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>: 添加对象</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>: 清空集合</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E e)</span>: 把给定对象从当前集合删除</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span>: 判断当前集合中是否包含给定的对象</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>:</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>: 返回集合中的元素个数</span><br><span class="line"><span class="keyword">public</span> Object[] toArray(): 把集合中的元素，存储到数组中</span><br></pre></td></tr></table></figure><p><strong>List</strong></p><ol><li>有序的集合（存储和取出元素顺序相同）</li><li>允许存储重复的元素</li><li>有索引，可以使用普通的for循环遍历</li></ol><ul><li>ArrayList（查询快，增删慢）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>常用方法：</p><p>add,get,remove,size</p><ul><li>LinkedList（查询慢，增删快）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;E&gt; linked = <span class="keyword">new</span> <span class="title class_">LinkerdList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>Set</strong></p><ol><li>不允许存储重复的元素</li><li>没有索引</li></ol><ul><li>HashSet</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;E&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><ol><li>是一个无序集合</li><li>底层是一个哈希表结构</li></ol><p>哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑i地址，是模拟出来的地址，不是数据实际存储的物理地址）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>:获取对象的哈希码值</span><br></pre></td></tr></table></figure><p>哈希表（查询快）</p><p>哈希表的结构，jdk1.8之后：</p><ol><li>哈希表=数组+链表；</li><li>哈希表=数组+红黑树；</li></ol><ul><li>LInkedHashSet</li></ul><p>LInkedHashSet特点：</p><p>底层是一个哈希表+链表，多了一条链表（记录元素的存储顺序），保证元素有序。</p><p><strong>HashSet存储自定义类型元素</strong></p><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。</p><p><strong>可变参数</strong></p><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（数据类型...变量名）&#123;</span><br><span class="line">&#125;</span><br><span class="line">实例</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>... arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">注意事项</span><br><span class="line">    <span class="number">1.</span> 一个方法的参数列表只能有一个可变参数</span><br><span class="line">    <span class="number">2.</span> 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾。</span><br><span class="line">可变参数的特殊（终极）写法</span><br><span class="line">    实例</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Object...obj)</span>&#123;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Map</strong></p><p>特点</p><ol><li>map集合是一个双列集合，一个元素包含两个值（key:value）</li><li>map集合中的元素，key和value的数据类型可以相同，也可以不同</li><li>map中key是不允许重复的，value可以重复</li><li>map中的key和value一一对应</li></ol><ul><li>HashMap（初始长度16）</li></ul><p>特点：</p><ol><li>HashMap集合底层是哈希表：查询速度特别快</li><li>hashMap是一个无序集合，存储和取出元素的顺序可能不一致</li></ol><ul><li>LinkedHashMap</li></ul><p>特点：</p><ol><li>底层是哈希表+链表（保证迭代的顺序）</li><li>是一个有序的集合，存储和取出元素的顺序是一致的</li></ol><ul><li>TreeMap</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>Collections工具类</p><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? <span class="built_in">super</span> T&gt; c, T... elements)</span> ：往集合中添加一些元素</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span> ：打乱集合顺序</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line">：将集合按照默认规则排序</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span>：将集合中元素按照指定规则排序</span><br></pre></td></tr></table></figure><h4 id="1-4-1-Iterator迭代器">1.4.1 Iterator迭代器</h4><p>迭代：Collection集合元素的通用获取方式。</p><p>迭代器的使用案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       coll.add(<span class="string">&quot;姚明&quot;</span>);</span><br><span class="line">       coll.add(<span class="string">&quot;科比&quot;</span>);</span><br><span class="line">       coll.add(<span class="string">&quot;詹姆斯&quot;</span>);</span><br><span class="line">       coll.add(<span class="string">&quot;库里&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取一个迭代器对象</span></span><br><span class="line">       Iterator&lt;String&gt; iterator = coll.iterator();</span><br><span class="line">       <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-异常">1.5 异常</h3><p><strong>异常</strong>：指的是程序在执行过程中，出现非正常的情况，最终导致JVM非正常停止。</p><p>Java处理异常的方式是中断处理。</p><p><strong>异常产生的过程解析</strong></p><h4 id="1-5-1-异常的处理">1.5.1 异常的处理</h4><p>Java异常处理的五个关键字：try、catch、finally、throw、throws</p><ol><li>抛出异常throw</li></ol><p>throw作用：</p><p>可以使用throw关键字在指定的方法中抛出指定的异常</p><p>使用格式：</p><p>throw new xxxException（“异常产生的原因”）;</p><p>注意：</p><ol><li>throw关键字必须写在方法的内部</li><li>throw后面new的对象必须是Exception或者Exception的子类对象</li><li>throw抛出指定的异常对象，我们必须处理这个异常对象，要么用throws，要么try…catch</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以后（工作中）我们首先必须对方法传递过来的参数进行合法性校验</span><br><span class="line"></span><br><span class="line">如果参数不合法，那么我们就必须使用抛出异常的方式，告知方法的调用者，传递的参数有问题。</span><br></pre></td></tr></table></figure><ol start="2"><li>声明异常throws（异常处理的第一种方式）</li></ol><p>作用：</p><p>当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象</p><p>可以使用throws处理异常对象，把异常声明抛出给方法的调用者处理（自己不处理，谁调用我让谁处理），最终交给jvm处理–&gt;中断异常</p><p>使用格式：在方法声明时使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数列表） <span class="keyword">throws</span> xxxException,.....&#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">xxxException</span>(<span class="string">&quot;产生原因&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">注意</span><br><span class="line">    <span class="number">1.</span> <span class="keyword">throws</span> 必须写在方法声明处</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">throws</span> 后边声明的异常必须是Exception或者其子类</span><br><span class="line">    <span class="number">3.</span> 方法内部如果抛出多个异常，那么<span class="keyword">throws</span>后边也必须声明多个异常</span><br><span class="line">        如果多个异常之间有子父类关系，直接声明父类异常就行</span><br><span class="line">    <span class="number">4.</span> 调用了一个声明抛出异常的方法，我们就必须处理声明的异常</span><br><span class="line">        要么继续使用 <span class="keyword">throws</span> 声明抛出，交给方法的调用者处理，最终交给 JVM</span><br><span class="line">        要么 <span class="keyword">try</span>....<span class="keyword">catch</span> 自己处理。</span><br></pre></td></tr></table></figure><ol start="3"><li>捕获异常try…catch（异常处理的第二种方式）</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>(xxxException e)&#123; <span class="comment">//try中抛出什么异常，catch就定义什么异常对象，用来接收这个异常。</span></span><br><span class="line">    一般在工作中，会把异常的信息记录在一个日志中。</span><br><span class="line">&#125;</span><br><span class="line">注意</span><br><span class="line">    <span class="number">1.</span> <span class="keyword">try</span> 可能会抛出多个异常，那么可以使用多个 <span class="keyword">catch</span> 来处理</span><br><span class="line">    <span class="number">2.</span> 如果 <span class="keyword">try</span> 中产生了异常，就会执行 <span class="keyword">catch</span> 中的异常处理逻辑，执行完后，继续执行 <span class="keyword">try</span>...<span class="keyword">catch</span> 后的代码。</span><br><span class="line">    <span class="number">3.</span> 如果 <span class="keyword">try</span> 中没有异常，就不执行 <span class="keyword">catch</span> ，执行完 <span class="keyword">try</span> 后，继续执行 <span class="keyword">try</span>...<span class="keyword">catch</span> 后的代码。</span><br></pre></td></tr></table></figure><h3 id="1-6-泛型">1.6 泛型</h3><p>泛型是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型。</p><p><strong>泛型的数据类型在创建对象的时候确定</strong></p><p>创建集合对象，使用泛型</p><p>好处：</p><ol><li>避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型</li><li>把运行期异常（代码运行之后抛出的异常）提升到了编译期</li></ol><p>弊端：</p><ol><li>泛型是什么类型，只能存储什么类型的数据</li></ol><p><strong>含有泛型的方法</strong></p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表（使用泛型）)&#123;</span><br><span class="line">        方法体;</span><br><span class="line">    &#125;</span><br><span class="line">实例</span><br><span class="line"> <span class="keyword">public</span> &lt;H&gt; <span class="keyword">void</span> <span class="title function_">genericMethod</span><span class="params">(H h)</span>&#123;</span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>含有泛型的接口</strong></p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">第一种使用方式，定义接口的实现类，实现接口并指定接口的泛型</span><br><span class="line">实例</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">			E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Scanner</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">第二种使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt;&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;   </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>泛型通配符</p><p>​	？：代表任意的数据类型</p><p>使用方式：</p><p>​	不能创建对象使用</p><p>​ 只能作为方法的参数使用</p><p><strong>高级使用-受限泛型（要求只要看源码能看懂就行）</strong></p><p>作用：限定数据的使用类型。</p><p>泛型的上限限定：？extends E 代表使用的泛型只能是E类型的子类/本身</p><p>泛型的下限限定：？super E 代表使用的泛型只能是E类型的父类/本身</p><ul><li><strong>数据结构</strong></li></ul><p><strong>红黑树</strong></p><p>特点：</p><ol><li>趋近于平衡树，查询的速度非常快，查询叶子节点最大次数和最小次数不能超过2倍</li></ol><p>约束：</p><ol><li>节点可以是红色或者黑色</li><li>根节点是黑色</li><li>叶子节点（空节点）是黑色</li><li>每个红色的节点的子节点都是黑色</li><li>任何一个节点到其每一个叶子节点所有路径上的黑色节点数相等</li></ol><h3 id="1-7-反射">1.7 反射</h3><p><strong>作用</strong></p><ol><li>基本作用：可以得到一个类的全部成分然后操作</li><li>可以破坏封装性</li><li>最重要的用途是：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。</li></ol><h3 id="1-8-注解">1.8 注解</h3><p>就是Java的特殊标记，作用是：让其他程序根据注解信息来决定怎么执行该程序</p><p><strong>特殊属性名：value</strong></p><p>如果注解只有一个value属性，使用注解时，value名称可以不写。</p><p><strong>元注解</strong></p><p>修饰注解的注解</p><p>常见的元注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="meta">@Target</span></span><br><span class="line">    作用：声明被修饰的注解只能在哪些位置使用</span><br><span class="line">    @<span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line">    <span class="number">1.</span> TYPE,类，接口</span><br><span class="line">    <span class="number">2.</span> FIELD， 成员变量</span><br><span class="line">    <span class="number">3.</span> METHOD，成员方法</span><br><span class="line">    .....</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> <span class="meta">@Retention</span></span><br><span class="line">    作用：声明注解的保留周期</span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="number">1.</span> SOURCE</span><br><span class="line">    只作用在源码阶段，字节码文件中不存在</span><br><span class="line">    <span class="number">3.</span>RUNTIME（开发常用）</span><br><span class="line">    一直保留到运行阶段</span><br></pre></td></tr></table></figure><p><strong>注解的解析</strong></p><p>要解析谁上面的注解，就先拿到谁</p><h3 id="1-9-I-O">1.9 I/O</h3><p>重点：记住三个单词</p><p>​ file： 文件</p><p>​ directory：文件夹/目录</p><p>​ path： 路径</p><p><strong>递归</strong>：指在当前方法内部调用自己的这种现象</p><p>递归的分类：</p><ol><li>直接递归</li></ol><p>​ 方法自身调用自身</p><ol start="2"><li>间接递归</li></ol><p>​ A方法调用B方法，B方法调用C方法，C方法调用A方法。</p><p><strong>Java中的I/O操作主要是指使用Java.io包下的内容，进行输入、输出操作。</strong></p><ol><li>字节流（InputStream/OutputStream）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream </span><br><span class="line">    文件字节输入流</span><br><span class="line">    作用：把硬盘文件中的数据，读取到内存中使用</span><br><span class="line">FileOutputStream</span><br><span class="line">    文件字节输出流</span><br><span class="line">    作用：把内存中的数据写入到硬盘的文件中</span><br></pre></td></tr></table></figure><p>使用字节流读取中文文件容易产生乱码</p><p>一个中文</p><p>​ GBK： 占用两个字节</p><pre><code>	UTF-8：占用三个字节
</code></pre><ol start="2"><li>字符流（reader/writer）</li></ol><p>作用：读取字符信息，一次读取一个字符</p><p>jdk7的新特性</p><p>在try后边可以增加一个()，在括号中可以定义流对象</p><p>那么这个流对象的作用域就在try中有效</p><p>try中的代码执行完毕会自动把流对象释放，不用写finally</p><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(定义流对象；定义流对象...)&#123;</span><br><span class="line">    可能会产生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类变量 变量名)&#123;</span><br><span class="line">    异常的处理逻辑</span><br><span class="line">&#125;</span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoll</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(<span class="comment">//创建一个字符输出流对象，构造方法绑定需要写入的目的地</span></span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="literal">true</span>);) &#123;</span><br><span class="line"><span class="comment">//            //创建一个字符输入流对象，构造方法绑定需要读取的数据源</span></span><br><span class="line"><span class="comment">//            FileReader fr = new FileReader(&quot;test.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                fw.append(<span class="string">&quot;helloword&quot;</span>+i+<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"> 			e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>缓冲流</li></ol><p>作用：提高文件读写的效率</p><p>字节缓冲流（BufferedInputStream &amp; BufferedOutputStream）</p><p>字符缓冲流（BufferedReader &amp; BufferWriter）</p><ol start="4"><li>转换流(OutputStreamWriter &amp; InputStreamReader)</li></ol><p>作用：能够转换编码</p><ol start="5"><li>序列化流(ObjectOutputStream &amp; ObjectInputStream )</li></ol><p>作用：能够持久化存储对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Serializable 接口也叫标记型接口</span><br><span class="line">    要进行序列化和反序列化的类必须实现 Serializable 接口，就会给类添加一个标记</span><br><span class="line">    当我们进行序列化和反序列化的时候，就会检测是否有这个标记</span><br><span class="line">    有：就可以序列化和反系列化</span><br><span class="line">    没有：就会抛出 NotSerializableException 异常</span><br><span class="line"> <span class="keyword">transient</span>关键字：瞬态关键字</span><br><span class="line">    被 <span class="keyword">transient</span> 修饰的成员变量，不能被序列化</span><br><span class="line">问题：</span><br><span class="line">    每次修改类的定义，都会给class文件生成一个新的序列号，这样在进行序列化与反序列化时就会报invalidClassException异常</span><br><span class="line">解决方法：</span><br><span class="line">    无论是否对类的定义进行修改，都不重新生成新的序列号</span><br><span class="line">    可以手动给类添加一个序列号</span><br><span class="line">  格式：</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6161825669842708241L</span>;</span><br><span class="line">等号后面的常量可以为任意值，不可改变。</span><br></pre></td></tr></table></figure><p>序列化集合</p><p>当我们想在文件中保存多个对象的时候，可以把多个对象存储到一个集合中，然后对集合进行序列化和反序列化。</p><h2 id="2-JVM">2. JVM</h2><h3 id="2-1-类加载机制">2.1 类加载机制</h3><h3 id="2-2-字节码执行机制">2.2 字节码执行机制</h3><h3 id="2-3-jvm内存模型">2.3 jvm内存模型</h3><h3 id="2-4-gc垃圾回收机制">2.4 gc垃圾回收机制</h3><h3 id="2-5-jvm性能监控和故障定位">2.5 jvm性能监控和故障定位</h3><h3 id="2-6-jvm调优">2.6 jvm调优</h3><h2 id="3-并发-多线程">3. 并发/多线程</h2><h3 id="3-1-并发编程">3.1 并发编程</h3><h3 id="3-2-多线程">3.2 多线程</h3><p>创建线程的步骤：</p><ol><li>声明Thread类的子类</li><li>重写Thread类的run方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置线程任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">创建线程的第二种方式</span><br><span class="line">    <span class="number">1.</span> 创建一个runnable接口的实现类</span><br><span class="line">    <span class="number">2.</span> 在实现类中重写runnable接口的run方法，设置线程任务 </span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableThreadImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置线程任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableThreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多态写法</span></span><br><span class="line">        <span class="comment">//Runnable runnable= new MyRunnableThreadImpl();</span></span><br><span class="line">        MyRunnableThreadImpl runnable= <span class="keyword">new</span> <span class="title class_">MyRunnableThreadImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">使用runnable接口创建多线程的好处：</span><br><span class="line">    <span class="number">1.</span> 避免了单继承的局限性</span><br><span class="line">    <span class="number">2.</span> 增强了程序的扩展性，降低了程序的耦合性（解耦）</span><br></pre></td></tr></table></figure><p><strong>Thread类中的常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span>：获取；当前线程名</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> ：此线程开始执行，Java虚拟机调用此线程的run方法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span>:使当前线程暂停指定多长时间</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>：线程要执行的任务都在此处编写</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>：返回当前正在执行的线程对象的引用</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p><strong>并发与并行</strong></p><p>并发：指两个或多个事件在同一时间段内发生</p><p>并行：指两个或多个事件在同一时刻发生（同时发生）</p><p><strong>线程与进程</strong></p><p>进程： 是指一个内存中运行的应用程序</p><p>线程： 是指进程中的一个执行单元，负责当前进程中程序的执行，一个进程至少有一个线程。一个进程中是可以有多个线程的，这个应用程序称为<strong>多线程程序</strong>。</p><p><strong>线程调度</strong></p><p>分时调度： 所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。</p><p>抢占式调度： 优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java使用的为抢占式调度。</p><h4 id="3-2-1-线程安全">3.2.1 线程安全</h4><p><strong>解决线程安全问题</strong></p><ol><li>同步代码块: synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</li></ol><p>使用synchronized关键字容易产生死锁（如何解决，在后续内容中写）</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>（同步锁（锁对象））&#123;</span><br><span class="line">    <span class="comment">//需要同步操作的代码即：可能出现线程安全问题的代码（访问了共享数据的代码）</span></span><br><span class="line">&#125;</span><br><span class="line">同步锁（锁对象）注意事项：</span><br><span class="line">    <span class="number">1.</span> 同步代码块中的锁对象，可以使用任意的对象</span><br><span class="line">    <span class="number">2.</span> 必须保证多个线程使用的锁对象是同一个</span><br><span class="line">    <span class="number">3.</span> 锁对象作用：</span><br><span class="line">             把同步代码块锁住，只让一个线程在同步代码块中执行</span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableThreadImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//同步锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>同步方法</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 参数名（参数列表）&#123;</span><br><span class="line">    <span class="comment">//需要同步操作的代码即：可能出现线程安全问题的代码（访问了共享数据的代码）</span></span><br><span class="line">&#125;</span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableThreadImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                payTicket();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//同步方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">payTicket</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">**静态同步方法**</span><br><span class="line"></span><br><span class="line">锁对象是谁？</span><br><span class="line"></span><br><span class="line">不能是<span class="built_in">this</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>是创建对象之后产生的，静态方法优先于对象</span><br><span class="line"></span><br><span class="line">静态方法的锁对象是本类的class属性--&gt;class文件对象(反射)</span><br></pre></td></tr></table></figure><ol start="3"><li>Lock锁</li></ol><p>Lock接口中的方法：</p><p>void lock() 获取锁</p><p>void unlock() 释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            l.lock();</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    l.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-线程池">3.3 线程池</h3><p>线程池： 其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作。</p><h3 id="3-4-锁">3.4 锁</h3><h3 id="3-5-并发容器">3.5 并发容器</h3><h3 id="3-6-原子类">3.6 原子类</h3><h3 id="3-7-juc并发工具类">3.7 juc并发工具类</h3><h2 id="4-网络编程">4. 网络编程</h2><p>软件结构：c/s，b/s</p><h3 id="4-1-网络通信">4.1 网络通信</h3><p><strong>网络通信协议的分类</strong></p><ol><li>UDP：用户数据报协议</li></ol><p>特点：消耗资源小，通信效率高</p><p>通常用于音频、视频和普通数据的传输例如视频会议都使用udp协议，即使丢一两个数据包，也不会对接受结果产生太大影响。</p><ol start="2"><li>TCP：传输控制协议</li></ol><p>是面向连接的通信协议。在TCP连接中必须要明确客户端与服务器端，每次连接的创建都需要经过“三次握手”。</p><p>特点：传输安全</p><p>网络编程的三要素</p><ol><li>协议</li><li>IP地址</li></ol><ul><li>IPv4：32位的二进制数，通常被分为4个字节，表示a.b.c.d的形式，每个字节的范围都是0~255.</li><li>IPv6：</li></ul><ol start="3"><li>端口号</li></ol><h3 id="4-2-函数式接口">4.2 函数式接口</h3><p>函数式接口：只有一个抽象方法的接口，称之为函数式接口</p><p>当然接口中可以包含其他的方法（默认，静态，私有）</p><p><strong>Lambda表达式</strong></p><p>函数式编程思想：</p><p>​	只要能获取到结果，谁去做，怎么做的都不重要，重视的是结果，不重视过程。</p><p>使用前提</p><ol><li>使用Lambda必须具有接口，且要求接口中有且只有一个抽象方法。</li><li>使用Lambda必须具有上下文推断</li></ol><p>有些场景的代码执行后结果不一定被使用，从而造成<strong>性能浪费</strong>。而Lambda表达式是延迟执行的，正好可以作为解决方案，提升性能。</p><p><strong>常用函数式接口</strong></p><ol><li>Supplier接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Supplier:被称为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个方法，用于获取int类型数组中元素的最大值，</span></span><br><span class="line"><span class="comment">     * 方法的参数传递Supplier接口，泛型使用Integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sup</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">100</span>,<span class="number">0</span>,-<span class="number">50</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> max= getMax(()-&gt;&#123;</span><br><span class="line">           <span class="type">int</span> temp= arr[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (temp&lt;arr[i])&#123;</span><br><span class="line">                   temp=arr[i];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Consumer接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Consumer:消费型接口，泛型执行什么类型，就可以使用accept方法使用什么类型的数据</span><br><span class="line">至于怎么消费（使用），需要自定义（输出，计算）</span><br><span class="line">默认方法：andThen</span><br><span class="line">作用：将两个Consumer接口连接到一起，然后再对数据进行消费（使用）</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String[] arr, Consumer&lt;String&gt; con1,Consumer&lt;String&gt; con2)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            con1.andThen(con2).accept(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr =  &#123;<span class="string">&quot;迪丽热巴，女&quot;</span>,<span class="string">&quot;古力娜扎，女&quot;</span>,<span class="string">&quot;沈腾，男&quot;</span>&#125;;</span><br><span class="line">        printMessage(arr,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;姓名：&quot;</span>+s.split(<span class="string">&quot;，&quot;</span>)[<span class="number">0</span>]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;性别：&quot;</span>+s.split(<span class="string">&quot;，&quot;</span>)[<span class="number">1</span>]+<span class="string">&quot;。&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ol start="3"><li>Predicate接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">对某种类型的数据进行判断，从而得到一个Boolean值结果。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoPredicate</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个方法，方法的参数传递一个字符串</span></span><br><span class="line"><span class="comment">     * 传递两个Predicate接口</span></span><br><span class="line"><span class="comment">     * 一个用于判断字符串的长度大于5</span></span><br><span class="line"><span class="comment">     * 一个用于判断字符串中是否包含a</span></span><br><span class="line"><span class="comment">     * 两个条件必须同时满足</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span>&#123;</span><br><span class="line">          <span class="comment">// return pre1.test(s) &amp;&amp; pre2.test(s);</span></span><br><span class="line">        <span class="comment">//return pre1.test(s) || pre2.test(s);</span></span><br><span class="line"><span class="comment">//        return pre1.or(pre2).test(s);</span></span><br><span class="line">          <span class="keyword">return</span> pre1.and(pre2).test(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;Hello world!!&quot;</span>;</span><br><span class="line">       <span class="type">boolean</span> b= checkString(test,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> s.length()&gt;<span class="number">5</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> s.contains(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-Stream流">4.3 Stream流</h3><p>IO流和Stream流是两个概念，IO流是用于数据的读写，而Stream流可以用来对集合和数组进行简化操作。</p></div><div class="post-bottom-tags-and-share border-box"><div><ul class="post-tags-box border-box"><li class="tag-item border-box"><i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/java/">java</a></li></ul></div><div><div class="post-share-container border-box"><ul class="share-list-wrap border-box"><li class="qq share-item border-box flex-center tooltip" data-tooltip-content="分享到 QQ"><i class="fa-brands fa-qq"></i></li><li class="wechat share-item border-box flex-center tooltip tooltip-img" data-tooltip-content="分享到微信" data-tooltip-img-tip="微信扫一扫" data-tooltip-img-style="background-color: #fff; top: -10px; padding: 0.6rem 0.6rem 0.1rem 0.6rem;"><i class="fa-brands fa-weixin"></i></li><li class="weibo share-item border-box flex-center tooltip" data-tooltip-content="分享到微博"><i class="fa-brands fa-weibo"></i></li></ul></div></div></div><div class="reward-author-container border-box flex-center"><div class="reward-btn keep-button border-box flex-center tooltip tooltip-img" data-tooltip-content="打赏作者" data-tooltip-img-url="/images/deploy-provider/paycode.png" data-tooltip-img-trigger="click" data-tooltip-img-style="top: -8px;"><i class="fa-solid fa-hand-holding-heart"></i></div></div><div class="post-nav border-box"><div class="prev-post"><a class="prev" rel="prev" href="/2024/05/04/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/" title="k8s集群搭建教程（使用cri-docker+flannel）"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">k8s集群搭建教程（使用cri-docker+flannel）</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="next-post"><a class="next" rel="next" href="/2023/12/24/my_blog_build_note/" title="个人博客搭建笔记"><span class="title flex-center"><span class="post-nav-title-item text-ellipsis">个人博客搭建笔记</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comments-container border-box"><div id="comments-anchor" class="comment-area-title border-box"><i class="fas fa-comments"></i>&nbsp;评论</div><div class="comment-plugin-fail border-box"><span class="fail-tip">评论插件加载失败</span> <button class="reload keep-button">点击重新加载</button></div><div class="comment-plugin-loading flex-center border-box"><i class="loading-icon fa-solid fa-spinner fa-spin"></i> <span class="load-tip">正在加载评论插件</span></div><script data-pjax>window.KeepCommentPlugin={},window.KeepCommentPlugin.hideLoading=()=>{document.querySelector(".comments-container .comment-plugin-loading").style.display="none"},window.KeepCommentPlugin.loadFailHandle=()=>{window.KeepCommentPlugin.hideLoading();const e=document.querySelector(".comments-container .comment-plugin-fail");e.style.display="flex",e.querySelector(".reload").addEventListener("click",()=>{window.location.reload()})}</script><div class="waline-comment-container"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@waline/client@v2/dist/waline.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@waline/client@v2/dist/waline-meta.css"><div id="waline-comment"></div><script src="//cdn.jsdelivr.net/npm/@waline/client@v2/dist/waline.js" async onerror="window.KeepCommentPlugin.loadFailHandle()"></script><script async>window.KeepCommentPlugin.walineOptions = JSON.parse('{}'.replace(/&#34;/g, '"'))

          window.KeepCommentPlugin.initWaline = () => {
            if (window?.Waline) {
              window.KeepCommentPlugin.walineOptions.el = '#waline-comment'
              window.KeepCommentPlugin.walineOptions.comment = '.post-comments-count'
              window.KeepCommentPlugin.walineOptions.serverURL = 'https://blog-comment-eight-azure.vercel.app'
              window.KeepCommentPlugin.walineOptions.lang = 'zh-CN' || 'zh-CN'
              window.KeepCommentPlugin.walineOptions.reaction = 'true' === 'true'
              window.Waline.init(window.KeepCommentPlugin.walineOptions)
              window.KeepCommentPlugin.hideLoading()
            } else {
              setTimeout(() => {
                window.KeepCommentPlugin.initWaline()
              }, 1000)
            }
          }

          if ('false' === 'true') {
            setTimeout(() => {
              window.KeepCommentPlugin.initWaline()
            }, 1200)
          } else {
            window.addEventListener('DOMContentLoaded', window.KeepCommentPlugin.initWaline)
          }</script></div></div></div></div><div class="pc-post-toc right-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">Java语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="nav-text">1. 语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-text">1.1 基础语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">1.2 面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%8E%A5%E5%8F%A3"><span class="nav-text">1.3 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%AE%B9%E5%99%A8"><span class="nav-text">1.4 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">1.4.1 Iterator迭代器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%BC%82%E5%B8%B8"><span class="nav-text">1.5 异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">1.5.1 异常的处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E6%B3%9B%E5%9E%8B"><span class="nav-text">1.6 泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E5%8F%8D%E5%B0%84"><span class="nav-text">1.7 反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-%E6%B3%A8%E8%A7%A3"><span class="nav-text">1.8 注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-I-O"><span class="nav-text">1.9 I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-JVM"><span class="nav-text">2. JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-text">2.1 类加载机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-text">2.2 字节码执行机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.3 jvm内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-text">2.4 gc垃圾回收机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-jvm%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D"><span class="nav-text">2.5 jvm性能监控和故障定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-jvm%E8%B0%83%E4%BC%98"><span class="nav-text">2.6 jvm调优</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">3. 并发&#x2F;多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-text">3.1 并发编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">3.2 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">3.2.1 线程安全</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">3.3 线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E9%94%81"><span class="nav-text">3.4 锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="nav-text">3.5 并发容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-text">3.6 原子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-juc%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-text">3.7 juc并发工具类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">4. 网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="nav-text">4.1 网络通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-text">4.2 函数式接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Stream%E6%B5%81"><span class="nav-text">4.3 Stream流</span></a></li></ol></li></ol></li></ol></div></div></div></div></div></div></div><div class="page-main-content-bottom border-box"><footer class="footer border-box"><div class="border-box website-info-box default"><div class="copyright-info info-item default">&copy;&nbsp;<span>2020</span>&nbsp;-&nbsp;2024 &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">一个想当厨子的码农</a></div><div class="theme-info info-item default">由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a></div><div class="deploy-info info-item default"><a target="_blank" rel="nofollow" href="https://github.com/">本站由 <span class="tooltip" data-tooltip-content="GitHub Pages"><img src="/images/brands/github.png"></span>提供部署服务</a></div><div class="count-item info-item default"><span class="count-box border-box uv"><span class="item-type border-box">访客数</span> <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span> </span><span class="count-box border-box pv"><span class="item-type border-box">访问量</span> <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span></span></div></div></footer></div></div><div class="post-tools right-toc"><div class="post-tools-container border-box"><ul class="tools-list border-box"><li class="tools-item flex-center toggle-show-toc"><i class="fas fa-list"></i></li><li class="tools-item flex-center go-to-comments"><i class="fas fa-comment"></i> <span class="post-comments-count"></span></li><li class="tools-item flex-center full-screen"><i class="fa-solid fa-expand"></i></li></ul></div></div><div class="side-tools"><div class="side-tools-container border-box"><ul class="side-tools-list side-tools-show-handle border-box"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-toggle-theme-mode flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list border-box"><li class="tools-item toggle-show-toc-tablet flex-center"><i class="fas fa-list"></i></li><li class="tools-item go-to-comments-tablet flex-center"><i class="fas fa-comment"></i></li><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center show-arrow"><i class="arrow fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><div class="zoom-in-image-mask"><img class="zoom-in-image"></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="close-popup-btn"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div><div class="tablet-post-toc-mask"><div class="tablet-post-toc"><div class="post-toc-wrap border-box"><div class="post-toc border-box"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-text">Java语言</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="nav-text">1. 语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-text">1.1 基础语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-text">1.2 面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E6%8E%A5%E5%8F%A3"><span class="nav-text">1.3 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E5%AE%B9%E5%99%A8"><span class="nav-text">1.4 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-1-Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">1.4.1 Iterator迭代器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%BC%82%E5%B8%B8"><span class="nav-text">1.5 异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-1-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-text">1.5.1 异常的处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E6%B3%9B%E5%9E%8B"><span class="nav-text">1.6 泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E5%8F%8D%E5%B0%84"><span class="nav-text">1.7 反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-%E6%B3%A8%E8%A7%A3"><span class="nav-text">1.8 注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-I-O"><span class="nav-text">1.9 I&#x2F;O</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-JVM"><span class="nav-text">2. JVM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-text">2.1 类加载机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-text">2.2 字节码执行机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.3 jvm内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-text">2.4 gc垃圾回收机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-jvm%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D"><span class="nav-text">2.5 jvm性能监控和故障定位</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-jvm%E8%B0%83%E4%BC%98"><span class="nav-text">2.6 jvm调优</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B9%B6%E5%8F%91-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">3. 并发&#x2F;多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-text">3.1 并发编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">3.2 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-text">3.2.1 线程安全</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">3.3 线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E9%94%81"><span class="nav-text">3.4 锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="nav-text">3.5 并发容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-text">3.6 原子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-juc%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-text">3.7 juc并发工具类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">4. 网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="nav-text">4.1 网络通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-text">4.2 函数式接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Stream%E6%B5%81"><span class="nav-text">4.3 Stream流</span></a></li></ol></li></ol></li></ol></div></div></div></div></main>undefinedundefinedundefinedundefinedundefinedundefinedundefined<div></div></body></html>
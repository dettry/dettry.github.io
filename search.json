[{"title":"CentOS7学习笔记","url":"/2022/10/06/CentOS7_note/","content":"一、安装CentOS\n二、基本系统设置\n一二详细步骤参考我的另一篇文章：\n区块链环境配置教程 | CodeCook (dettry.github.io)\n三、远程SSH登录\n3.1 使用账号密码登录\n3.2 设置SSH通过密钥登录\n我们一般使用 PuTTY 等 SSH 客户端来远程管理 Linux 服务器。但是，一般的密码方式登录，容易有密码被暴力破解的问题。所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用 root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——那就是通过密钥方式登录。\n密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。\n下面来讲解如何在 Linux 服务器上制作密钥对，将公钥添加给账户，设置 SSH，最后通过客户端登录。\n3.2.1 制作密钥对\n首先在服务器上制作密钥对。首先用密码登录到你打算使用密钥登录的账户，然后执行以下命令：\n[root@host ~]$ ssh-keygen  &lt;== 建立密钥对\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/root/.ssh/id_rsa): &lt;== 按 Enter\nCreated directory ‘/root/.ssh’.\nEnter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，或直接按 Enter 留空\nEnter same passphrase again: &lt;== 再输入一遍密钥锁码\nYour identification has been saved in /root/.ssh/id_rsa. &lt;== 私钥\nYour public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 公钥\nThe key fingerprint is:\n0f:d3:e7:1a:1c:bd:5c:03:f1:19:f1:22:df:9b:cc:08 root@host\n密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录。\n现在，在 root 用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥。\n3.2.2 在服务器上安装公钥\n键入以下命令，在服务器上安装公钥：\n[root@host ~]$ cd .ssh\n[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys\n如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：\n[root@host .ssh]$ chmod 600 authorized_keys\n[root@host .ssh]$ chmod 700 ~/.ssh\n3.2.3 设置 SSH，打开密钥登录功能\n编辑 /etc/ssh/sshd_config 文件，进行如下设置：\nRSAAuthentication yes\nPubkeyAuthentication yes\n另外，请留意 root 用户能否通过 SSH 登录：\nPermitRootLogin yes\n当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：\nPasswordAuthentication no\n最后，重启 SSH 服务：\n[root@host .ssh]$ service sshd restart\n3.2.4 将私钥下载到客户端，然后转换为PuTTY能使用的格式\n使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。\n载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。\n今后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。\n3.3 配置防火墙\ncentos7 Firewall防火墙开启80端口\ncentos7 默认是FirewallD 提供支持网络/防火墙区域(zone)定义网络链接以及接口安全等级的动态防火墙管理工具，利用FirewallD开启80端口操作如下：\n开启80端口\n$ sudo firewall-cmd --zone=public --add-port=80/tcp --permanent\n出现success表明添加成功\n命令含义：\n–zone #作用域\n–add-port=80/tcp #添加端口，格式为：端口/通讯协议\n–permanent #永久生效，没有此参数重启后失效\n重启防火墙\nsystemctl restart firewalld.service\n1、运行、停止、禁用firewalld\n启动：# systemctl start firewalld\n查看状态：# systemctl status firewalld 或者 firewall-cmd –state\n停止：# systemctl disable firewalld\n禁用：# systemctl stop firewalld\n2、配置firewalld\n查看版本：$ firewall-cmd –version\n查看帮助：$ firewall-cmd –help\n查看设置：\n显示状态：$ firewall-cmd –state\n查看区域信息: $ firewall-cmd –get-active-zones\n查看指定接口所属区域：$ firewall-cmd –get-zone-of-interface=eth0\n拒绝所有包：# firewall-cmd –panic-on\n取消拒绝状态：# firewall-cmd –panic-off\n查看是否拒绝：$ firewall-cmd –query-panic\n更新防火墙规则：# firewall-cmd –reload\nfirewall-cmd –complete-reload\n两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务\n将接口添加到区域，默认接口都在public\nfirewall-cmd –zone=public –add-interface=eth0\n永久生效再加上 –permanent 然后reload防火墙\n设置默认接口区域\nfirewall-cmd –set-default-zone=public\n立即生效无需重启\n打开端口（貌似这个才最常用）\n查看所有打开的端口：\nfirewall-cmd –zone=dmz –list-ports\n加入一个端口到区域：\nfirewall-cmd –zone=dmz –add-port=8080/tcp\n若要永久生效方法同上\n打开一个服务，类似于将端口可视化，服务需要在配置文件中添加，/etc/firewalld 目录下有services文件夹，这个不详细说了，详情参考文档\nfirewall-cmd –zone=work –add-service=smtp\n移除服务\nfirewall-cmd –zone=work –remove-service=smtp\n原文链接：http://www.zhaokeli.com/article/6321.html\n附：systemctl命令如下 \nsystemctl is-enabled iptables.service \nsystemctl is-enabled servicename.service #查询服务是否开机启动 \nsystemctl enable *.service #开机运行服务 \nsystemctl disable *.service #取消开机运行 \nsystemctl start *.service #启动服务 \nsystemctl stop *.service #停止服务 \nsystemctl restart *.service #重启服务 \nsystemctl reload *.service #重新加载服务配置文件 \nsystemctl status *.service #查询服务运行状态 \nsystemctl –failed #显示启动失败的服务\n注：*代表某个服务的名字，如http的服务名为httpd\nCentOS6防火墙开启80，3306端口\n$ sudo vi /etc/sysconfig/iptables\n-A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT（允许80端口通过防火墙）\n-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT（允许3306端口通过防火墙）\n特别提示：很多网友把这两条规则添加到防火墙配置的最后一行，导致防火墙启动失败，正确的应该是添加到默认的22端口这条规则的下面\n添加好之后防火墙规则如下所示：\n代码如下：\nFirewall configuration written by system-config-firewall\nManual customization of this file is not recommended.\n*filter\n:INPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n-A INPUT -m state –state ESTABLISHED,RELATED -j ACCEPT\n-A INPUT -p icmp -j ACCEPT\n-A INPUT -i lo -j ACCEPT\n-A INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT\n-A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT\n-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT\n-A INPUT -j REJECT –reject-with icmp-host-prohibited\n-A FORWARD -j REJECT –reject-with icmp-host-prohibited\nCOMMIT\n最后重启防火墙使配置生效\n$ sudo /etc/init.d/iptables restart\n附录：Linux常用命令\n1、用户和组\n一、LINUX(UBUNTU/CENTOS)用户添加删除修改\nlinux 创建用户\n1、建用户：\nadduser web                             //新建web用户\nuseradd web    -m\t\t\t\t\t\t\t#添加web 用户\npasswd web                               //给web用户设置密码\nuseradd web -g admin -n -m //新建web用户并指定用户组为 admin用户组,并自动建立登录目录\npasswd web //给web 用户设置密码\nuseradd(选项)(参数)\n-c&lt;备注&gt;：加上备注文字。备注文字会保存在passwd的备注栏位中；\n-d&lt;登入目录&gt;：指定用户登入时的启始目录；\n-D：变更预设值；\n-e&lt;有效期限&gt;：指定帐号的有效期限；\n-f&lt;缓冲天数&gt;：指定在密码过期后多少天即关闭该帐号；\n-g&lt;群组&gt;：指定用户所属的群组；\n-G&lt;群组&gt;：指定用户所属的附加群组；\n-m：自动建立用户的登入目录；\n-M：不要自动建立用户的登入目录；\n-n：取消建立以用户名称为名的群组；\n-r：建立系统帐号；\n-s：指定用户登入后所使用的shell；\n-u：指定用户id。\n2、给已有的用户增加工作组\nusermod -G admin web\t\t\t\t\t#给web用户设置admin附属用户组\n#给用户设置添加多个用户组\nusermod -g web -G admin,www web\t\t\t\t\t#给web用户设置主用户组web组，admin,www附属用户组\ngpasswd -a web admin\t\t\t\t#给web用户设置admin用户组\n3、新建用户同时增加工作组\nuseradd -g admin web                      //新建web用户并增加到admin工作组\n注：：-g 所属组 -d 家目录 -s 所用的SHELL\n4、临时关闭\n方法一\n/etc/shadow文件中属于该用户的行的第二个字段（密码）前面加上*就可以了。想恢复该用户，去掉*即可。\n方法二\n使用命令关闭用户账号：\npasswd web –l\n重新释放：\npasswd web –u\n5、永久性删除用户账号\nuserdel web\ngroupdel web\nusermod –G web web   （强制删除该用户的主目录和主目录下的所有文件和子目录）\n7、从组中删除用户\n编辑/etc/group 找到用户组admin那一行，删除用户名web\n或者用命令\ngpasswd -d A web\n8、显示用户信息\nid user\ncat /etc/passwd\n二、用户组 LINUX(UBUNTU/CENTOS) 添加删除修改\n1、建工作组\ngroupadd admin                          //新建admin工作组\n2、修改用户组\ngroupmod -n newadmin admin\t\t\t\t#修改admin用户组名称改为newadmin\n3、删除用户组\ngroupdel admin\t\t\t\t\t\t\t#删除admin用户组\n4.查看用户的用户组信息\ngroups web\n2、目录和文件cd，ls，ll，rmdir，mkdir，pwd\n\\1)        pwd命令\n用途：查看工作目录（PrintWorking Directory）\n例：\n[root@web03 home]# pwd\n/home\npwd命令一般单独使用，无需特别注意命令格式；\n\\2)        cd命令\n用途：切换工作目录（Change Directory）\n格式：cd  [目录位置]\n例：\n         [root@localhost~]# cd /etc/httpd\n[root@localhost httpd]# cd conf\n[root@localhost conf]# cd ~benet\n      目录位置（包括文件位置）可以使用绝对路径，也可以使用相对路径\n绝对路径：以“/”开始的路径，表示从Linux目录结构的最顶点算起\n相对路径：不“/”开始的路径，可以相对于当前目录、父目录、其他用户的目录等作为起始点，使用形式如下：\n直接使用文件名/目录名；\n以“.”或 “…” 开始的路径；\n以“~用户名”的形式开始的路径\n  例：\n       cd:切换目录，Change Directory\ncd ：不带任何参数表示切换回当前用户的家目录\ncd /path/to/dir ：切换到指定目录\ncd - ：表示在上一个目录和这个目录来回切换，类似于电视遥控器上的返回之前\ncd ~ ：切换回当前的家目录。\ncd ~student ：表示切换到别人的家目录\ncd … ：可以切换到当前目录的父目录\ncd …/… ：可以切换到当前目录父目录的父目录\ncd命令指定短横线“-”作为参数时，表示切换到前一次（执行cd命令前）所在的工作目录\n\\3)        ls命令\n用途：用于显示某一个文件的属性，或者某一个目录旗下子目录的属性。\n格式：ls  [选项]…  [目录或文件名]\n常用命令选项\n-l ：以长格式显示\n-a：显示所有子目录和文件的信息，包括隐藏文件\n-d：显示目录本身的属性\n-A：类似于“-a”，但不显示“.”和“…”目录的信息\n-h：以更易读的字节单位（K、M等）显示信息\nHuman readable\n-R：递归显示内容\n–color：以颜色区分不同类型文件\n例：\nls /etc/inittab 直接显示这个文件\nls /：直接显示根下的文件和子目录\nls /etc 显示文件夹含有的目录\n-l :显示目录/文件内详细信息。比如 ls-l /etc 则显示etc目录的详细信息\nls -l后：这里面显示的是元数据信息，他们本身不属于文件内容的部分，但是却跟文件本身息息相关，称之为属性信息，我们都将他称之为元数据信息。\n-h : 将文件信息中的大小变成人类易读的\n-a : 显示所有文件，包括隐藏文件\n-d : 显示的是目录自身的属性，而不是目录中文件或者子目录的属性\n-r : 显示目录，将以逆序的方式进行排序。从Z-A\n-R : 递归现实，显示目录下的每一个文件和子目录，如果目录还有子目录，则继续显示子目录下的文件和子目录，直到显示完全。\nLinux的文件类型：\na)        普通文件：开头用“-”表示的\nb)        目录文件：开头用“d”表示的\nc)        符号链接文件（软连接文件）：开头用“l”表示\nd)        设备文件：\n             i.             块设备，用 b 表示。按照随机存取。通常一次存取一个块。(硬盘)\n             ii.             字符设备，用 c 表示，通常按照线性（有顺序）的方式进行存储，一次存取的一个单位是字节。比如键盘，鼠标显示器等。字符存储是串行的。\ne)        套接字文件：开头用“s”  表示 sock\nf)         命令管道文件：开头用“p”表示\n\\4)        mkdir命令\n用途：创建新的目录（Make Directory）\n格式：mkdir   [-p]  [/路径/]目录名\n例：\n         [root@localhost~]# mkdir -p mydir/level1/level2\nmkdir命令用于创建新的空目录，可以同时创建多个目录\n较常用到的选项为“-p”，该命令用于创建嵌套的多层目录结构\n若不使用“-p”选项，则只能在已经存在的目录中创建其他子目录\n\\5)        du命令\n用途：统计目录及文件的空间占用情况（estimate file space usage）\n格式：du  [选项]…  [目录或文件名]\n常用命令选项\n-a：统计时包括所有的文件，而不仅仅只统计目录\n-h：以更易读的字节单位（K、M等）显示信息\n-s：\n例：\n      [root@localhost~]# du -sh /etc/httpd/\ndu命令的“-s”、“-h”选项通常结合在一起使用，以统计指定文件夹总占用空间的大小\n2、文本编辑vi\n所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。但是目前我们使用比较多的是 vim 编辑器。vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。\n1、什么是 vim？\nVim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。vim 键盘图：\n2、vi/vim 的使用\n基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：\n命令模式：\n用户刚刚启动 vi/vim，便进入了命令模式。\n此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。\n以下是常用的几个命令：\n\ni 切换到输入模式，以输入字符。\nx 删除当前光标所在处的字符。\n: 切换到底线命令模式，以在最底一行输入命令。\n\n若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。\n命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。\n输入模式：\n在命令模式下按下i就进入了输入模式。\n在输入模式中，可以使用以下按键：\n\n字符按键以及Shift组合，输入字符\nENTER，回车键，换行\nBACK SPACE，退格键，删除光标前一个字符\nDEL，删除键，删除光标后一个字符\n方向键，在文本中移动光标\nHOME/END，移动光标到行首/行尾\nPage Up/Page Down，上/下翻页\nInsert，切换光标为输入/替换模式，光标将变成竖线/下划线\nESC，退出输入模式，切换到命令模式\n\n底线命令模式：\n在命令模式下按下:（英文冒号）就进入了底线命令模式。\n底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。\n在底线命令模式中，基本的命令有（已经省略了冒号）：\n\nq 退出程序\nw 保存文件\n\n按ESC键可随时退出底线命令模式。\n简单的说，我们可以将这三个模式想成底下的图标来表示：\n3、vi/vim 使用实例\n使用 vi/vim 进入一般模式\n如果你想要使用 vi 来建立一个名为 test.txt 的文件时，你可以这样做：\n$ vi runoob.txt\n直接输入 vi 文件名 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！\n按下 i 进入输入模式(也称为编辑模式)，开始编辑文字\n在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！\n在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。\n这个时候，键盘上除了 Esc 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。\n按下 ESC 按钮回到一般模式\n好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 Esc 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！\n在一般模式中按下 :wq 储存后离开 vi\nOK，我们要存档了，存盘并离开的指令很简单，输入 :wq 即可保存离开！\nOK! 这样我们就成功创建了一个 runoob.txt 的文件。\n4、vi/vim 按键说明\n除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。\n第一部份：一般模式可用的光标移动、复制粘贴、搜索替换等\n\n\n\n移动光标的方法\n\n\n\n\n\nh 或 向左箭头键(←)\n光标向左移动一个字符\n\n\nj 或 向下箭头键(↓)\n光标向下移动一个字符\n\n\nk 或 向上箭头键(↑)\n光标向上移动一个字符\n\n\nl 或 向右箭头键(→)\n光标向右移动一个字符\n\n\n如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！\n\n\n\n[Ctrl] + [f]\n屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)\n\n\n[Ctrl] + [b]\n屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)\n\n\n[Ctrl] + [d]\n屏幕『向下』移动半页\n\n\n[Ctrl] + [u]\n屏幕『向上』移动半页\n\n\n+\n光标移动到非空格符的下一行\n\n\n-\n光标移动到非空格符的上一行\n\n\nn\n那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20 则光标会向后面移动 20 个字符距离。\n\n\n0 或功能键[Home]\n这是数字『 0 』：移动到这一行的最前面字符处 (常用)\n\n\n$ 或功能键[End]\n移动到这一行的最后面字符处(常用)\n\n\nH\n光标移动到这个屏幕的最上方那一行的第一个字符\n\n\nM\n光标移动到这个屏幕的中央那一行的第一个字符\n\n\nL\n光标移动到这个屏幕的最下方那一行的第一个字符\n\n\nG\n移动到这个档案的最后一行(常用)\n\n\nnG\nn 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)\n\n\ngg\n移动到这个档案的第一行，相当于 1G 啊！ (常用)\n\n\nn\nn 为数字。光标向下移动 n 行(常用)\n\n\n搜索替换\n\n\n\n/word\n向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)\n\n\n?word\n向光标之上寻找一个字符串名称为 word 的字符串。\n\n\nn\n这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！\n\n\nN\n这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。\n\n\n使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！\n\n\n\n:n1,n2s/word1/word2/g\nn1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：『:100,200s/vbird/VBIRD/g』。(常用)\n\n\n:1,$s/word1/word2/g\n从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)\n\n\n:1,$s/word1/word2/gc\n从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)\n\n\n删除、复制与贴上\n\n\n\nx, X\n在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)\n\n\nnx\nn 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。\n\n\ndd\n删除游标所在的那一整行(常用)\n\n\nndd\nn 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)\n\n\nd1G\n删除光标所在到第一行的所有数据\n\n\ndG\n删除光标所在到最后一行的所有数据\n\n\nd$\n删除游标所在处，到该行的最后一个字符\n\n\nd0\n那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符\n\n\nyy\n复制游标所在的那一行(常用)\n\n\nnyy\nn 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)\n\n\ny1G\n复制游标所在行到第一行的所有数据\n\n\nyG\n复制游标所在行到最后一行的所有数据\n\n\ny0\n复制光标所在的那个字符到该行行首的所有数据\n\n\ny$\n复制光标所在的那个字符到该行行尾的所有数据\n\n\np, P\np 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)\n\n\nJ\n将光标所在行与下一行的数据结合成同一行\n\n\nc\n重复删除多个数据，例如向下删除 10 行，[ 10cj ]\n\n\nu\n复原前一个动作。(常用)\n\n\n[Ctrl]+r\n重做上一个动作。(常用)\n\n\n这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！\n\n\n\n.\n不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)\n\n\n\n第二部份：一般模式切换到编辑模式的可用的按钮说明\n\n\n\n进入输入或取代的编辑模式\n\n\n\n\n\ni, I\n进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)\n\n\na, A\n进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)\n\n\no, O\n进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！(常用)\n\n\nr, R\n进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)\n\n\n上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！\n\n\n\n[Esc]\n退出编辑模式，回到一般模式中(常用)\n\n\n\n第三部份：一般模式切换到指令行模式的可用的按钮说明\n\n\n\n指令行的储存、离开等指令\n\n\n\n\n\n:w\n将编辑的数据写入硬盘档案中(常用)\n\n\n:w!\n若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！\n\n\n:q\n离开 vi (常用)\n\n\n:q!\n若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。\n\n\n注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～\n\n\n\n:wq\n储存后离开，若为 :wq! 则为强制储存后离开 (常用)\n\n\nZZ\n这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！\n\n\n:w [filename]\n将编辑的数据储存成另一个档案（类似另存新档）\n\n\n:r [filename]\n在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面\n\n\n:n1,n2 w [filename]\n将 n1 到 n2 的内容储存成 filename 这个档案。\n\n\n:! command\n暂时离开 vi 到指令行模式下执行 command 的显示结果！例如『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！\n\n\nvim 环境的变更\n\n\n\n:set nu\n显示行号，设定之后，会在每一行的前缀显示该行的行号\n\n\n:set nonu\n与 set nu 相反，为取消行号！\n\n\n\n特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。\n举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。\n3、软件包安装yum和rpm\n一、源代码形式\n1.      绝大多数开源软件都是直接以原码形式发布的\n2.      源代码一般会被打成.tar.gz的归档压缩文件\n3.      源代码需要编译成为二进制形式之后才能够运行使用\n4.      源代码基本编译流程：\n1）.configure 检查编译环境；\n2）make对源代码进行编译；\n3）make insall 将生成的可执行文件安装到当前计算机中\n二、RPM\n1.源代码形式的特点：操作复杂、编译时间长、极易出现问题、依赖关系复杂\n2.为了方便，RPM（redhat package manager）\n3.RPM通过将代码基于特定平台系统编译为可执行文件，并保存依赖关系，来简化开源软件的安装管理。针对不同的系统设定不同的包\n4.常用命令规范：linuxcast-1.2.0-30.el6.1686.rpm 包名-版本号-适用平台-32/64-rpm\n5.使用rpm –i software.rpm(安装)；\nrpm -e software.rpm(卸载)；\nrpm –U software.rpm(升级形式安装)；\nrpm –ivh http://www.linuxcast.net/software.rpm(支持通过http\\ftp协议形式安装)\n-v 显示详细信息；-h显示进度条\n查询功能：rpm –qa 列出全部已经安装的.rpm软件  rpm –qa |grep ***\n三：YUM\n1.      rpm软件包形式的管理虽然方便，但是需要手工解决软件包的依赖关系。很多时候安装一个软件安装一个软件需要安装1个或者多个其他软件，手动解决时，很复杂，yum解决这些问题。Yum是rpm的前端程序，主要目的是设计用来自动解决rpm的依赖关系，其特点：\n1）  自动解决依赖关系；2）可以对rpm进行分组，基于组进行安装操作；3）引入仓库概念，支持多个仓库；4）配置简单\n2.      yum仓库用来存放所有的现有的.rpm包，当使用yum安装一个rpm包时，需要依赖关系，会自动在仓库中查找依赖软件并安装。仓库可以是本地的，也可以是HTTP、FTP、nfs形式使用的集中地、统一的网络仓库。\n3.      仓库的配置文件/etc/yum.repos.d目录下\n4.      使用：1）yum install 安装；\n2)yum remove卸载；\n3)yum update 升级制定软件\n5.      安装的时候，会下载软件包.Rpm在安装，所以用国内仓库\n改变镜像源1）访问地址http://mirrors.163.com/；2）点centos使用帮助；3）按步骤来\n6.      查询软件：可以使用yumsearch\nYum: 即Yellowdog Update Modifier,是一种基于rpm的包管理工具\nyum命令使用示例\n显示yum仓库\n显示所有仓库\nyum repolist all\n显示可用的仓库\nrepolist enabled\n显示可用的仓库\nrepolist disabled\n显示应用程序包\n显示所有的程序包\nyum list\n或\nyum list all\n[vathe@localhost ~]$yum list tre?\nInstalled Packages\ntree.x86_64                                         1.6.0-10.el7                                          @base\n还支持通配符格式的查询\n显示可安装的程序包\nyum list available\n[vathe@localhost ~]$yum list available php\nAvailable Packages\nphp.x86_64                                          5.4.16-42.el7                                          base\n显示可更新或已安装的程序包\nyum list updates\nyum list installed\n显示仓库中最近增加的程序包\nyum list recent\n安装程序包\n#安装 tree 程序\nyum install tree\n升级程序包\nyum update tree\n卸载程序包\nyum remove tree\n或\nyum erase tree\n查看程序包信息\nyum info tree\n查看文件的来源\n查看某一文件来自于那个程序包\n[vathe@localhost ~]$yum provides /bin/mv\ncoreutils-8.22-18.el7.x86_64 : A set of basic GNU tools commonly used in shell scripts\nRepo        : base\nMatched from:\nFilename    : /bin/mv\n#表示/bin/mv文件来自于coreutils-8.22-18.el7.x86_64程序包\n清理本地缓存\nyum clean all\n#清楚插件缓存\nyum clean plugins\n构建缓存\nyum makecache\n搜索\n[vathe@localhost ~]$yum search php\n============================================== N/S matched: php ===============================================\ngraphviz-php.x86_64 : PHP extension for graphviz\nphp.x86_64 : PHP scripting language for creating dynamic web sites\nphp-bcmath.x86_64 : A module for PHP applications for using the bcmath library\n…\n查看指定包所依赖的capabilities\n[vathe@localhost ~]$yum deplist php\npackage: php.x86_64 5.4.16-42.el7\n  dependency: httpd\n provider: httpd.x86_64 2.4.6-45.el7.centos\n…\n查看yum事务历史\n[root@localhost ~]# yum history\nRepository ‘base’ is missing name in configuration, using id\nID     | Login user               | Date and time    | Action(s)      | Altered\n-------------------------------------------------------------------------------\n   2 | Vathe Su          | 2017-04-17 17:07 | Install        |    1\n   1 | System            | 2017-03-23 22:19 | Install        | 1405\nhistory list\n包组相关的命令\nyum groupinstall    # 安装包组\nyum groupupdate     #更新包组\nyum grouplist       #显示包组\nyum groupremove     #移除包组\nyum groupinfo       #查看包组信息\nyum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。\nyum的命令形式一般是如下：yum [options] [command] [package …]\n其中的[options]是可选的，选项包括-h（帮助），-y（当安装过程提示选择全部为&quot;yes&quot;），-q（不显示安装的过程）等等。[command]为所要进行的操作，[package …]是操作的对象。\n概括了部分常用的命令包括：\n自动搜索最快镜像插件：   yum install yum-fastestmirror\n安装yum图形窗口插件：    yum install yumex\n查看可能批量安装的列表： yum grouplist\n1 安装\nyum install 全部安装\nyum install package1 安装指定的安装包package1\nyum groupinsall group1 安装程序组group1\n2 更新和升级\nyum update 全部更新\nyum update package1 更新指定程序包package1\nyum check-update 检查可更新的程序\nyum upgrade package1 升级指定程序包package1\nyum groupupdate group1 升级程序组group1\n3 查找和显示\nyum info package1 显示安装包信息package1\nyum list 显示所有已经安装和可以安装的程序包\nyum list package1 显示指定程序包安装情况package1\nyum groupinfo group1 显示程序组group1信息yum search string 根据关键字string查找安装包\n4 删除程序\nyum remove | erase package1 删除程序包package1\nyum groupremove group1 删除程序组group1\nyum deplist package1 查看程序package1依赖情况\n5 清除缓存\nyum clean packages 清除缓存目录下的软件包\nyum clean headers 清除缓存目录下的 headers\nyum clean oldheaders 清除缓存目录下旧的 headers\nyum clean, yum clean all (= yum clean packages; yum clean oldheaders) 清除缓存目录下的软件包及旧的headers\n比如，要安装游戏程序组，首先进行查找：\n＃：yum grouplist\n可以发现，可安装的游戏程序包名字是”Games and Entertainment“，这样就可以进行安装：\n＃：yum groupinstall “Games and Entertainment”\n所 有的游戏程序包就自动安装了。在这里Games and Entertainment的名字必须用双引号选定，因为linux下面遇到空格会认为文件名结束了，因此必须告诉系统安装的程序包的名字是“Games and Entertainment”而不是“Games&quot;。\nyum，是Yellow dog Updater Modified的简称，起初是由yellow dog这一发行版的开发者Terra Soft研发，用python写成，那时还叫做yup(yellow dog updater)，后经杜克大学的Linux@Duke开发团队进行改进，遂有此名。yum的宗旨是自动化地升级，安装/移除rpm包，收集rpm包的相关信息，检查依赖性并自动提示用户解决。yum的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http或ftp站点， 也可以是本地软件池，但必须包含rpm的header， header包括了rpm包的各种信息，包括描述，功能，提供的文件，依赖性等.正是收集了这些 header并加以分析，才能自动化地完成余下的任务。\n1.yum的一切配置信息都储存在一个叫yum.conf的配置文件中，通常位于/etc目 录下，这是整个yum系统的重中之重，我在的F9中查看了这一文件，大家一起来看下：\n[hanlong@localhost F9常用文档]$ sudo more /etc/yum.conf\n[main]\ncachedir=/var/cache/yum\nkeepcache=0\ndebuglevel=2\nlogfile=/var/log/yum.log\nexactarch=1\nobsoletes=1\ngpgcheck=1\nplugins=1\nmetadata_expire=1800\nPUT YOUR REPOS HERE OR IN separate files named file.repo\nin /etc/yum.repos.d\n下面简单的对这一文件作简要的说明：\ncachedir：yum缓存的目录，yum在此存储下载的rpm包和数据库，一般是/var/cache/yum。\ndebuglevel：除错级别，0──10,默认是2\nlogfile：yum的日志文件，默认是/var/log/yum.log。\nexactarch，有两个选项1和0,代表是否只升级和你安装软件包cpu体系一致的包，如果设为1，则如你安装了一个i386的rpm，则yum不会用686的包来升级。\ngpgchkeck= 有1和0两个选择，分别代表是否是否进行gpg校验，如果没有这一项，默认好像也是检查的。\n2.好了，接下来就是yum的使用了，首先用yum来升级软件，yum的操作大都须有超级用户的权限，当然可以用sudo。\nyum update，这一步是必须的，yum会从服务器的header目录下载rpm的header，放在本地的缓存中，这可能会花费一定的时间，但比起yum 给我们带来方便，这些时间的花费又算的了什么呢？header下载完毕，yum会判断是否有可更新的软件包，如果有，它会询问你的意见，是否更新，还是说 y吧，把系统始终up to date总是不错的，这时yum开始下载软件包并使用调用rpm安装，这可能要一定时间，取决于要更新软件的数目和网络状况，万一网络断了，也没关系，再 进行一次就可以了。升级完毕，以后每天只要使用yum check-update检查一下有无跟新，如果有，就用yum update进行跟新，时刻保持系统为最新，堵住一切发现的漏洞。用yum update packagename 对某个单独包进行升级。\n现在简单的把yum软件升级的一些命令罗列一下：\n(更新：我在安装wine的时候是用rpm一个一个安装的，先安装以来关系，然后在安装wine的主包，但是刚刚在论坛上发现来一个好的帖子，就yum的本地安装。参数是-localinstall\n$yum localinstall wine-*\n这样的话，yum会自动安装所有的依赖关系，而不用rpm一个一个的安装了，省了好多工作。\n还有一个与他类似的参数：\n$yum localupdate wine-*\n如果有wine的新版本，而且你也下载到来本地，就可以这样本地更新wine了。)\n1.列出所有可更新的软件清单\n命令：yum check-update\n2.安装所有更新软件\n命令：yum update\n3.仅安装指定的软件\n命令：yum install\n4.仅更新指定的软件\n命令：yum update\n5.列出所有可安裝的软件清单\n命令：yum list\n3.使用yum安装和卸载软件，有个前提是yum安装的软件包都是rpm格式的。\n安装的命令是，yum install xxx，yum会查询数据库，有无这一软件包，如果有，则检查其依赖冲突关系，如果没有依赖冲突，那么最好，下载安装;如果有，则会给出提示，询问是否要同时安装依赖，或删除冲突的包，你可以自己作出判断\n删除的命令是，yum remove xxx，同安装一样，yum也会查询数据库，给出解决依赖关系的提示。\n1.用YUM安装软件包\n命令：yum install\n2.用YUM删除软件包\n命令：yum remove\n4.用yum查询想安装的软件\n我们常会碰到这样的情况，想要安装一个软件，只知道它和某方面有关，但又不能确切知道它的名字。这时yum的查询功能就起作用了。你可以用 yum search keyword这样的命令来进行搜索，比如我们要则安装一个Instant Messenger，但又不知到底有哪些，这时不妨用 yum search messenger这样的指令进行搜索，yum会搜索所有可用rpm的描述，列出所有描述中和messeger有关的rpm包，于是我们可能得到 gaim，kopete等等，并从中选择。\n有时我们还会碰到安装了一个包，但又不知道其用途，我们可以用yum info packagename这个指令来获取信息。\n1.使用YUM查找软件包\n命令：yum search\n2.列出所有可安装的软件包\n命令：yum list\n3.列出所有可更新的软件包\n命令：yum list updates\n4.列出所有已安装的软件包\n命令：yum list installed\n5.列出所有已安装但不在 Yum Repository 內的软件包\n命令：yum list extras\n6.列出所指定的软件包\n命令：yum list 7.使用YUM获取软件包信息\n命令：yum info 8.列出所有软件包的信息\n命令：yum info\n9.列出所有可更新的软件包信息\n命令：yum info updates\n10.列出所有已安裝的软件包信息\n命令：yum info installed\n11.列出所有已安裝但不在 Yum Repository 內的软件包信息\n命令：yum info extras\n12.列出软件包提供哪些文件\n命令：yum provides\n5.清除YUM缓存\nyum 会把下载的软件包和header存储在cache中，而不会自动删除。如果我们觉得它们占用了磁盘空间，可以使用yum clean指令进行清除，更精确的用法是yum clean headers清除header，yum clean packages清除下载的rpm包，yum clean all 清除所有\n1.清除缓存目录(/var/cache/yum)下的软件包\n命令：yum clean packages\n2.清除缓存目录(/var/cache/yum)下的 headers\n命令：yum clean headers\n3.清除缓存目录(/var/cache/yum)下旧的 headers\n命令：yum clean oldheaders\n4.清除缓存目录(/var/cache/yum)下的软件包及旧的headers\n命令：yum clean, yum clean all (= yum clean packages; yum clean oldheaders)\n以上所有命令参数的使用都可以用man来查看：\n1、安装图形版yumex：yum install yumex。\n2、安装额外的软件仓库：\nrpm.livna.org 的软件包仓库:\nrpm -ivh http://livna-dl.reloumirrors.net … ease-7-2.noarch.rpm\nfreshrpms.net 的软件包仓库:\nrpm –ivh http://ftp.freshrpms.net/pub/fre … 1.1-1.fc.noarch.rpm\n3、安装最快源 yum install yum-fastestmirror\n资源真的是非常丰富，从Centos到Ubuntu，ISO镜像、升级包，应有尽有，上交的兄弟们真是幸福，羡慕啊。不过还好，我们好歹也算是在教育网内，凑合着也可以沾点光，下载一些。\n网址为：ftp://ftp.sjtu.edu.cn/\n相应的yum的repo为\n[updates]\nname=Fedora updates\nbaseurl=ftp://ftp.sjtu.edu.cn/fedora/linux/updates/$releasever/$basearch/\nenabled=1\ngpgcheck=0\n[fedora]\nname=Fedora $releasever - $basearch\nbaseurl=ftp://ftp.sjtu.edu.cn/fedora/linux/releases/$releasever/Everything/$basearch/os/\nenabled=1\ngpgcheck=1\ngpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora file:///etc/pki/rpm-gpg/RPM-GPG-KEY\n如果在机器上安装了apt管理器，则相应的源为\nrepomd ftp://ftp.sjtu.edu.cn/ fedora/linux/updates/$(VERSION)/$(ARCH)/\nrepomd ftp://ftp.sjtu.edu.cn/ fedora/linux/releases/$(VERSION)/Everything/$(ARCH)/os/\n4、压缩解压缩tar，zip\n本文介绍了linux下的压缩程式tar、gzip、gunzip、bzip2、bunzip2、compress 、uncompress、 zip、 unzip、rar、unrar等程式，以及如何使用它们对.tar、.gz 、.tar.gz、.tgz、.bz2、.tar.bz2、.Z、. tar.Z、.zip、.rar这10种压缩文件进行操作\nLinux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲tar命令的基本用法：\ntar命令的选项有很多(用man tar可以查看到)，但常用的就那么几个选项，下面来举例说明一下：\n?\n1\ntar -cf all.tar *.jpg\n这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包 ，-f指定包的文件名。\n?\n1\ntar -rf all.tar *.gif\n这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。\n?\n1\ntar -uf all.tar logo.gif\n这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。\n?\n1\ntar -tf all.tar\n这条命令是列出all.tar包中所有文件，-t是列出文件的意思\n?\n1\ntar -xf all.tar\n这条命令是解出all.tar包中所有文件，-x是解开的意思\n以上就是tar的最基本的用法。为了方便用户在打包解包的同时可以压缩或解压文件，tar提供了一种特殊的功能。这就是tar可以在打包或解包的同时调用其它的压缩程序，比如调用gzip、bzip2等。\n\\1) tar调用\ngzip是GNU组织开发的一个压缩程序，.gz结尾的文件就是gzip压缩的结果。与gzip 相对的解压程序是gunzip。tar中使用-z这个参数来调用gzip。下面来举例说明一下：\n?\n1\ntar -czf all.tar.gz *.jpg\n这条命令是将所有.jpg的文件打成一个tar包，并且将其用gzip压缩，生成一个gzip压缩过的包，包名为all.tar.gz\n?\n1\ntar -xzf all.tar.gz\n这条命令是将上面产生的包解开。\n\\2) tar调用bzip2\nbzip2是一个压缩能力更强的压缩程序，.bz2结尾的文件就是bzip2压缩的结果。\n与bzip2相对的解压程序是bunzip2。tar中使用-j这个参数来调用gzip。下面来举例说明一下：\n?\n1\ntar -cjf all.tar.bz2 *.jpg\n这条命令是将所有.jpg的文件打成一个tar包，并且将其用bzip2压缩，生成一个bzip2压缩过的包，包名为all.tar.bz2\n?\n1\ntar -xjf all.tar.bz2\n这条命令是将上面产生的包解开。\n3)tar调用compress\ncompress也是一个压缩程序，但是好象使用compress的人不如gzip和bzip2的人多。.Z结尾的文件就是bzip2压缩的结果。与 compress相对的解压程序是uncompress。tar中使用-Z这个参数来调用compress。下面来举例说明一下：\n?\n1\ntar -cZf all.tar.Z *.jpg\n这条命令是将所有.jpg的文件打成一个tar包，并且将其用compress压缩，生成一个uncompress压缩过的包，包名为all.tar.Z\n?\n1\ntar -xZf all.tar.Z\n这条命令是将上面产生的包解开\n有了上面的知识，你应该可以解开多种压缩文件了，下面对于tar系列的压缩文件作一个小结：\n1)对于.tar结尾的文件\ntar -xf all.tar\n2)对于.gz结尾的文件\ngzip -d all.gz\ngunzip all.gz\n3)对于.tgz或.tar.gz结尾的文件\ntar -xzf all.tar.gz\ntar -xzf all.tgz\n4)对于.bz2结尾的文件\nbzip2 -d all.bz2\nbunzip2 all.bz2\n5)对于tar.bz2结尾的文件\ntar -xjf all.tar.bz2\n6)对于.Z结尾的文件\nuncompress all.Z\n7)对于.tar.Z结尾的文件\ntar -xZf all.tar.z\n另外对于Window下的常见压缩文件.zip和.rar，Linux也有相应的方法来解压它们：\n1)对于.zip\nlinux下提供了zip和unzip程序，zip是压缩程序，unzip是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：\n?\n1\nzip all.zip *.jpg\n这条命令是将所有.jpg的文件压缩成一个zip包\n?\n1\nunzip all.zip\n这条命令是将all.zip中的所有文件解压出来\n2)对于.rar\n要在linux下处理.rar文件，需要安装RAR for Linux，可以从网上下载，但要记住，RAR for Linux 不是免费的；可从http://www.rarsoft.com/download.htm下载RARfor Linux 3.2.\n0，然后安装：\n?\n1\n2\n3\ntar -xzpvf rarlinux-3.2.0.tar.gz\ncd rar\nmake\n这样就安装好了，安装后就有了rar和unrar这两个程序，rar是压缩程序，unrar 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：\n?\n1\nrar a all *.jpg\n这条命令是将所有.jpg的文件压缩成一个rar包，名为all.rar，该程序会将.rar 扩展名将自动附加到包名后。\n?\n1\nunrar e all.rar\n这条命令是将all.rar中的所有文件解压出来\n到此为至，我们已经介绍过linux下的tar、gzip、gunzip、bzip2、bunzip2、compress 、 uncompress、 zip、unzip、rar、unrar等程式，你应该已经能够使用它们对.tar 、.gz、.tar.gz、.tgz、.bz2、.tar.bz2、. Z、.tar.Z、.zip、.rar这10种压缩文\n件进行解压了，以后应该不需要为下载了一个软件而不知道如何在Linux下解开而烦恼了。而且以上方法对于Unix也基本有效。\n5、用户和权限chmod，chown\nLinux下数字表示文件的操作权限(777,755,…)\nLinux下。查看某路径下用（ls -l）查看全部文件的具体属性列表时。会看到文件的操作权限。类似“drwxr-xr-x”的字符串。\n这串字符能够分成4段理解。结构为“d + 文件全部者操作权限 + 文件全部者所在组操作权限 + 其余人的操作权限”：\n1，第一段：样例中字母“d”，表示文件所在文件夹\n2，第二段：样例中字符串“rwx”，表示文件全部者对此文件的操作权限\n3，第三段。样例中字符串“r-x”。表示文件全部者所在组对些文件的操作权限\n4。第四段。样例中字符串“r-x”，表示除2、3两种外的不论什么人对此文件的操作权限\n通经常使用三个数字来表示文件的读取、写入、运行权限：\n运行：1\n写入：2\n读取：4\n随便写个数字：755，这个3位数分别相应前面所说的分段：7相应第二段，5相应第三段，5相应第四段。\n含义：\n7：表示文件全部者的权限，4+2+1=7，即文件全部者对该文件有生杀大权，读、写、运行随便。\n5：表示文件全部者所在组的权限：4+1=5。即文件全部者所在组对文件有读、运行权限。没有写权限。\n5：同上，其余人对该文件仅仅有读、运行权限，没有写权限。\n指令名称 : chmod\n使用权限 : 全部使用者\n使用方式 : chmod [-cfvR] [–help] [–version] mode file…\n说明 : Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其它。利用 chmod 能够藉以控制档案怎样被他人所调用。\n參数 :\nmode : 权限设定字串，格式例如以下 : [ugoa…][[±=][rwxX]…][,…]，当中\nu 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其它以外的人，a 表示这三者皆是。\n+ 表示添加权限、- 表示取消权限、= 表示唯一设定权限。\nr 表示可读取。w 表示可写入，x 表示可运行。X 表示仅仅有当该档案是个子文件夹或者该档案已经被设定过为可运行。\n-c : 若该档案权限确实已经更改，才显示其更修改作\n-f : 若该档案权限无法被更改也不要显示错误讯息\n-v : 显示权限变更的具体资料\n-R : 对眼下文件夹下的全部档案与子文件夹进行同样的权限变更(即以递回的方式逐个变更)\n–help : 显示辅助说明\n–version : 显示版本号\n范例 :将档案 file1.txt 设为全部人皆可读取 :\nchmod ugo+r file1.txt\n将档案 file1.txt 设为全部人皆可读取 :\nchmod a+r file1.txt\n将档案 file1.txt 与 file2.txt 设为该档案拥有者，与其所属同一个群体者可写入，但其它以外的人则不可写入 :\nchmod ug+w,o-w file1.txt file2.txt\n将 ex1.py 设定为仅仅有该档案拥有者能够运行 :\nchmod u+x ex1.py\n将眼下文件夹下的全部档案与子文件夹皆设为不论什么人可读取 :\nchmod -R a+r *\n此外chmod也能够用数字来表示权限如 chmod 777 file\n语法为：chmod abc file\n当中a,b,c各为一个数字，分别表示User、Group、及Other的权限。\nr=4，w=2，x=1\n若要rwx属性则4+2+1=7；\n若要rw-属性则4+2=6；\n若要r-x属性则4+1=5。\n范例：\nchmod a=rwx file\n和\nchmod 777 file\n效果同样\nchmod ug=rwx,o=x file\n和\nchmod 771 file\n效果同样\n若用chmod 4755 filename可使此程序具有root的权限.\n指令名称 : chown\n使用权限 : root\n使用方式 : chown [-cfhvR] [–help] [–version] user[] file…\n说明 : Linux/Unix 是多人多工作业系统，全部的档案皆有拥有者。利用 chown 能够将档案的拥有者加以改变。\n一般来说，这个指令仅仅有是由系统管理者(root)所使用。一般使用者没有权限能够改变别人的档案拥有者，也没有权限能够自己的档案拥有者改设为别人。\n仅仅有系统管理者(root)才有这种权限。\n參数 :\nuser : 新的档案拥有者的使用者\nIDgroup : 新的档案拥有者的使用者群体(group)\n-c : 若该档案拥有者确实已经更改，才显示其更修改作\n-f : 若该档案拥有者无法被更改也不要显示错误讯息\n-h : 仅仅对于连结(link)进行变更。而非该 link 真正指向的档案\n-v : 显示拥有者变更的具体资料\n-R : 对眼下文件夹下的全部档案与子文件夹进行同样的拥有者变更(即以递回的方式逐个变更)\n–help : 显示辅助说明\n–version : 显示版本号\n范例 :\n将档案 file1.txt 的拥有者设为 users 群体的使用者 jessie :\nchown jessie:users file1.txt\n将眼下文件夹下的全部档案与子文件夹的拥有者皆设为 users 群体的使用者 lamport :\nchmod -R lamport:users *\n-rw------- (600) – 仅仅有属主有读写权限。\n-rw-r–r-- (644) – 仅仅有属主有读写权限；而属组用户和其它用户仅仅有读权限。\n-rwx------ (700) – 仅仅有属主有读、写、运行权限。\n-rwxr-xr-x (755) – 属主有读、写、运行权限。而属组用户和其它用户仅仅有读、运行权限。\n-rwx–x–x (711) – 属主有读、写、运行权限；而属组用户和其它用户仅仅有运行权限。\n-rw-rw-rw- (666) – 全部用户都有文件读、写权限。\n这样的做法不可取。\n-rwxrwxrwx (777) – 全部用户都有读、写、运行权限。更不可取的做法。\n下面是对文件夹的两个普通设定:\ndrwx------ (700) - 仅仅有属主可在文件夹中读、写。\ndrwxr-xr-x (755) - 全部用户可读该文件夹，但仅仅有属主才干改变文件夹中的内容。\n--------------------------------------------------------------------------\n执行 .sh 文件类型的文件：\n用file命令測试一下看是什么类型的\nfile xxxx.sh\n假设是Bourne-Again shell script 能够sh xxxx.sh 或者chmod +x xxxx.sh 再./xxx.sh\n一般 .sh 的直接加入x(可运行属性) chmod +x xxx.sh 然后./xxx.sh就能够了\nchmod是一个改变用户拥有指定文件的权限的命令.r:仅仅读,w:写,x运行.也能够用数字\n6、系统管理systemd\nSystemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。历史上，Linux 的启动一直采用init进程。下面的命令用来启动服务。\n$ sudo /etc/init.d/apache2 start\n或者\n$ service apache2 start\n这种方法有两个缺点。一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。\n1、Systemd 概述\nSystemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。\n$ systemctl --version\n上面的命令查看 Systemd 的版本。\nSystemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反&quot;keep simple, keep stupid&quot;的Unix 哲学。\n图1  Systemd 架构图\n2、系统管理\nSystemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。\n2.1 systemctl\nsystemctl是 Systemd 的主命令，用于管理系统。\n# 重启系统$ sudo systemctl reboot# 关闭系统，切断电源$ sudo systemctl poweroff# CPU停止工作$ sudo systemctl halt# 暂停系统$ sudo systemctl suspend# 让系统进入冬眠状态$ sudo systemctl hibernate# 让系统进入交互式休眠状态$ sudo systemctl hybrid-sleep# 启动进入救援状态（单用户状态）$ sudo systemctl rescue\n2.2 systemd-analyze\nsystemd-analyze命令用于查看启动耗时。\n# 查看启动耗时$ systemd-analyze# 查看每个服务的启动耗时$ systemd-analyze blame# 显示瀑布状的启动过程流$ systemd-analyze critical-chain# 显示指定服务的启动流$ systemd-analyze critical-chain atd.service\n2.3 hostnamectl\nhostnamectl命令用于查看当前主机的信息。\n# 显示当前主机的信息$ hostnamectl# 设置主机名。$ sudo hostnamectl set-hostname rhel7\n2.4 localectl\nlocalectl命令用于查看本地化设置。\n# 查看本地化设置$ localectl# 设置本地化参数。$ sudo localectl set-locale LANG=en\\_GB.utf8$ sudo localectl set-keymap en\\_GB\n2.5 timedatectl\ntimedatectl命令用于查看当前时区设置。\n# 查看当前时区设置$ timedatectl# 显示所有可用的时区$ timedatectl list-timezones                                                                                   # 设置当前时区$ sudo timedatectl set-timezone America/New\\_York$ sudo timedatectl set-time YYYY-MM-DD$ sudo timedatectl set-time HH:MM:SS\n2.6 loginctl\nloginctl命令用于查看当前登录的用户。\n# 列出当前session$ loginctl list-sessions# 列出当前登录用户$ loginctl list-users# 列出显示指定用户的信息$ loginctl show-user ruanyf\n3、Unit\n3.1 含义\nSystemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。\nUnit 一共分成12种。\n\nService unit：系统服务\nTarget unit：多个 Unit 构成的一个组\nDevice Unit：硬件设备\nMount Unit：文件系统的挂载点\nAutomount Unit：自动挂载点\nPath Unit：文件或路径\nScope Unit：不是由 Systemd 启动的外部进程\nSlice Unit：进程组\nSnapshot Unit：Systemd 快照，可以切回某个快照\nSocket Unit：进程间通信的 socket\nSwap Unit：swap 文件\nTimer Unit：定时器\n\nsystemctl list-units命令可以查看当前系统的所有 Unit 。\n# 列出正在运行的 Unit$ systemctl list-units# 列出所有Unit，包括没有找到配置文件的或者启动失败的$ systemctl list-units --all# 列出所有没有运行的 Unit$ systemctl list-units --all --state=inactive# 列出所有加载失败的 Unit$ systemctl list-units --failed# 列出所有正在运行的、类型为 service 的 Unit$ systemctl list-units --type=service\n3.2 Unit 的状态\nsystemctl status命令用于查看系统状态和单个 Unit 的状态。\n# 显示系统状态$ systemctl status# 显示单个 Unit 的状态$ sysystemctl status bluetooth.service# 显示远程主机的某个 Unit 的状态$ systemctl -H root@rhel7.example.com status httpd.service除了status命令，systemctl还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。# 显示某个 Unit 是否正在运行$ systemctl is-active application.service# 显示某个 Unit 是否处于启动失败状态$ systemctl is-failed application.service# 显示某个 Unit 服务是否建立了启动链接$ systemctl is-enabled application.service\n3.3 Unit 管理\n对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。\n# 立即启动一个服务$ sudo systemctl start apache.service# 立即停止一个服务$ sudo systemctl stop apache.service# 重启一个服务$ sudo systemctl restart apache.service# 杀死一个服务的所有子进程$ sudo systemctl kill apache.service# 重新加载一个服务的配置文件$ sudo systemctl reload apache.service# 重载所有修改过的配置文件$ sudo systemctl daemon-reload# 显示某个 Unit 的所有底层参数$ systemctl show httpd.service# 显示某个 Unit 的指定属性的值$ systemctl show -p CPUShares httpd.service# 设置某个 Unit 的指定属性$ sudo systemctl set-property httpd.service CPUShares=500\n3.4 依赖关系\nUnit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。\nsystemctl list-dependencies命令列出一个 Unit 的所有依赖。\n$ systemctl list-dependencies nginx.service\n上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用–all参数。\n$ systemctl list-dependencies --all nginx.service\n4、Unit 的配置文件\n4.1 概述\n每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。\nSystemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。\nsystemctl enable命令用于在上面两个目录之间，建立符号链接关系。\n$ sudo systemctl enable clamd@scan.service\n等同于\n$ sudo ln -s ‘/usr/lib/systemd/system/clamd@scan.service’ ‘/etc/systemd/system/multi-user.target.wants/clamd@scan.service’\n如果配置文件里面设置了开机启动，systemctl enable命令相当于激活开机启动。\n与之对应的，systemctl disable命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。\n$ sudo systemctl disable clamd@scan.service\n配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。\n4.2 配置文件的状态\nsystemctl list-unit-files命令用于列出所有配置文件。\n# 列出所有配置文件$ systemctl list-unit-files# 列出指定类型的配置文件$ systemctl list-unit-files --type=service\n这个命令会输出一个列表。\n$ systemctl list-unit-files\nUNIT FILE              STATE\nchronyd.service        enabled\nclamd@.service         static\nclamd@scan.service     disabled\n这个列表显示每个配置文件的状态，一共有四种。\n\nenabled：已建立启动链接\ndisabled：没建立启动链接\nstatic：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖\nmasked：该配置文件被禁止建立启动链接\n\n注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。\n$ systemctl status bluetooth.service一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。$ sudo systemctl daemon-reload$ sudo systemctl restart httpd.service\n4.3 配置文件的格式\n配置文件就是普通的文本文件，可以用文本编辑器打开。\nsystemctl cat命令可以查看配置文件的内容。\n$ systemctl cat atd.service\n[Unit]\nDescription=ATD daemon\n[Service]\nType=forking\nExecStart=/usr/bin/atd\n[Install]\nWantedBy=multi-user.target\n从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。\n每个区块内部是一些等号连接的键值对。\n[Section]\nDirective1=value\nDirective2=value\n注意，键值对的等号两侧不能有空格。\n4.4 配置文件的区块\n[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。\n\nDescription：简短描述\nDocumentation：文档地址\nRequires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败\nWants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败\nBindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行\nBefore：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动\nAfter：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动\nConflicts：这里指定的 Unit 不能与当前 Unit 同时运行\nCondition…：当前 Unit 运行必须满足的条件，否则不会运行\nAssert…：当前 Unit 运行必须满足的条件，否则会报启动失败\n\n[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。\n\nWantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中\nRequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中\nAlias：当前 Unit 可用于启动的别名\nAlso：当前 Unit 激活（enable）时，会被同时激活的其他 Unit\n\n[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。\n\nType：定义启动时的进程行为。它有以下几种值。\nType=simple：默认值，执行ExecStart指定的命令，启动主进程\nType=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出\nType=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行\nType=dbus：当前服务通过D-Bus启动\nType=notify：当前服务启动完毕，会通知Systemd，再继续往下执行\nType=idle：若有其他任务执行完毕，当前服务才会运行\nExecStart：启动当前服务的命令\nExecStartPre：启动当前服务之前执行的命令\nExecStartPost：启动当前服务之后执行的命令\nExecReload：重启当前服务时执行的命令\nExecStop：停止当前服务时执行的命令\nExecStopPost：停止当其服务之后执行的命令\nRestartSec：自动重启当前服务间隔的秒数\nRestart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog\nTimeoutSec：定义 Systemd 停止当前服务之前等待的秒数\nEnvironment：指定环境变量\n\nUnit 配置文件的完整字段清单，请参考官方文档。\n5、Target\n启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。\n简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于&quot;状态点&quot;，启动某个 Target 就好比启动到某种状态。\n传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。\n# 查看当前系统的所有 Target$ systemctl list-unit-files --type=target# 查看一个 Target 包含的所有 Unit$ systemctl list-dependencies multi-user.target# 查看启动时的默认 Target$ systemctl get-default# 设置启动时的默认 Target$ sudo systemctl set-default multi-user.target# 切换 Target 时，默认不关闭前一个 Target 启动的进程，# systemctl isolate 命令改变这种行为，# 关闭前一个 Target 里面所有不属于后一个 Target 的进程$ sudo systemctl isolate multi-user.target\nTarget 与 传统 RunLevel 的对应关系如下。\nTraditional runlevel      New target name     Symbolically linked to…\nRunlevel 0           |    runlevel0.target -&gt; poweroff.target\nRunlevel 1           |    runlevel1.target -&gt; rescue.target\nRunlevel 2           |    runlevel2.target -&gt; multi-user.target\nRunlevel 3           |    runlevel3.target -&gt; multi-user.target\nRunlevel 4           |    runlevel4.target -&gt; multi-user.target\nRunlevel 5           |    runlevel5.target -&gt; graphical.target\nRunlevel 6           |    runlevel6.target -&gt; reboot.target\n它与init进程的主要差别如下。\n（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。\n（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。\n（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。\n6、日志管理\nSystemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。\njournalctl功能强大，用法非常多。\n# 查看所有日志（默认情况下 ，只保存本次启动的日志）$ sudo journalctl# 查看内核日志（不显示应用日志）$ sudo journalctl -k# 查看系统本次启动的日志$ sudo journalctl -b$ sudo journalctl -b -0# 查看上一次启动的日志（需更改设置）$ sudo journalctl -b -1# 查看指定时间的日志$ sudo journalctl --since=&quot;2012-10-30 18:17:16&quot;$ sudo journalctl --since &quot;20 min ago&quot;$ sudo journalctl --since yesterday$ sudo journalctl --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;$ sudo journalctl --since 09:00 --until &quot;1 hour ago&quot;# 显示尾部的最新10行日志$ sudo journalctl -n# 显示尾部指定行数的日志$ sudo journalctl -n 20# 实时滚动显示最新日志$ sudo journalctl -f# 查看指定服务的日志$ sudo journalctl /usr/lib/systemd/systemd# 查看指定进程的日志$ sudo journalctl \\_PID=1# 查看某个路径的脚本的日志$ sudo journalctl /usr/bin/bash# 查看指定用户的日志$ sudo journalctl \\_UID=33 --since today# 查看某个 Unit 的日志$ sudo journalctl -u nginx.service$ sudo journalctl -u nginx.service --since today# 实时滚动显示某个 Unit 的最新日志$ sudo journalctl -u nginx.service -f# 合并显示多个 Unit 的日志$ journalctl -u nginx.service -u php-fpm.service --since today# 查看指定优先级（及其以上级别）的日志，共有8级# 0: emerg# 1: alert# 2: crit# 3: err# 4: warning# 5: notice# 6: info# 7: debug$ sudo journalctl -p err -b# 日志默认分页输出，--no-pager 改为正常的标准输出$ sudo journalctl --no-pager# 以 JSON 格式（单行）输出$ sudo journalctl -b -u nginx.service -o json# 以 JSON 格式（多行）输出，可读性更好$ sudo journalctl -b -u nginx.serviceqq` `-o json-pretty# 显示日志占据的硬盘空间$ sudo journalctl --disk-usage# 指定日志文件占据的最大空间$ sudo journalctl --vacuum-size=1G# 指定日志文件保存多久$ sudo journalctl --vacuum-time=1years\n7、操作实例\n7.1 开机启动\n对于那些支持 Systemd 的软件，安装的时候，会自动在/usr/lib/systemd/system目录添加一个配置文件。\n如果你想让该软件开机启动，就执行下面的命令（以httpd.service为例）。\n$ sudo systemctl enable httpd\n上面的命令相当于在/etc/systemd/system目录添加一个符号链接，指向/usr/lib/systemd/system里面的httpd.service文件。\n这是因为开机时，Systemd只执行/etc/systemd/system目录里面的配置文件。这也意味着，如果把修改后的配置文件放在该目录，就可以达到覆盖原始配置的效果。\n7.2 启动服务\n设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行systemctl start命令。\n$ sudo systemctl start httpd\n执行上面的命令以后，有可能启动失败，因此要用systemctl status命令查看一下该服务的状态。\n$ sudo systemctl status httpd\nhttpd.service - The Apache HTTP Server\n Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled)\n Active: active (running) since 金 2014-12-05 12:18:22 JST; 7min ago\n Main PID: 4349 (httpd)\n Status: “Total requests: 1; Current requests/sec: 0; Current traffic:   0 B/sec”\n CGroup: /system.slice/httpd.service\n         ├─4349 /usr/sbin/httpd -DFOREGROUND\n         ├─4350 /usr/sbin/httpd -DFOREGROUND\n         ├─4351 /usr/sbin/httpd -DFOREGROUND\n         ├─4352 /usr/sbin/httpd -DFOREGROUND\n         ├─4353 /usr/sbin/httpd -DFOREGROUND\n         └─4354 /usr/sbin/httpd -DFOREGROUND\n12月 05 12:18:22 localhost.localdomain systemd[1]: Starting The Apache HTTP Server\n12月 05 12:18:22 localhost.localdomain systemd[1]: Started The Apache HTTP Server.\n12月 05 12:22:40 localhost.localdomain systemd[1]: Started The Apache HTTP Server.\n上面的输出结果含义如下。\n\nLoaded行：配置文件的位置，是否设为开机启动\nActive行：表示正在运行\nMain PID行：主进程ID\nStatus行：由应用本身（这里是 httpd ）提供的软件当前状态\nCGroup块：应用的所有子进程\n日志块：应用的日志\n\n7.3 停止服务\n终止正在运行的服务，需要执行systemctl stop命令。\n$ sudo systemctl stop httpd.service\n有时候，该命令可能没有响应，服务停不下来。这时候就不得不&quot;杀进程&quot;了，向正在运行的进程发出kill信号。\n$ sudo systemctl kill httpd.service\n此外，重启服务要执行systemctl restart命令。\n$ sudo systemctl restart httpd.service\n7.4 读懂配置文件\n一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。\n前面说过，配置文件主要放在/usr/lib/systemd/system目录，也可能在/etc/systemd/system目录。找到配置文件以后，使用文本编辑器打开即可。\nsystemctl cat命令可以用来查看配置文件，下面以sshd.service文件为例，它的作用是启动一个 SSH 服务器，供其他用户以 SSH 方式登录。\n$ systemctl cat sshd.service[Unit]Description=OpenSSH server daemonDocumentation=man:sshd(8) man:sshd\\_config(5)After=network.target sshd-keygen.serviceWants=sshd-keygen.service[Service]EnvironmentFile=/etc/sysconfig/sshdExecStart=/usr/sbin/sshd -D $OPTIONSExecReload=/bin/kill -HUP $MAINPIDType=simpleKillMode=processRestart=on-failureRestartSec=42s[Install]WantedBy=multi-user.target\n可以看到，配置文件分成几个区块，每个区块包含若干条键值对。\n下面依次解释每个区块的内容。\n7.5 [Unit] 区块：启动顺序与依赖关系。\nUnit区块的Description字段给出当前服务的简单描述，Documentation字段给出文档位置。\n接下来的设置是启动顺序和依赖关系，这个比较重要。\nAfter字段：表示如果network.target或sshd-keygen.service需要启动，那么sshd.service应该在它们之后启动。\n相应地，还有一个Before字段，定义sshd.service应该在哪些服务之前启动。\n注意，After和Before字段只涉及启动顺序，不涉及依赖关系。\n举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。\n设置依赖关系，需要使用Wants字段和Requires字段。\nWants字段：表示sshd.service与sshd-keygen.service之间存在&quot;弱依赖&quot;关系，即如果&quot;sshd-keygen.service&quot;启动失败或停止运行，不影响sshd.service继续执行。\nRequires字段则表示&quot;强依赖&quot;关系，即如果该服务启动失败或异常退出，那么sshd.service也必须退出。\n注意，Wants字段与Requires字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。\n7.6 [Service] 区块：启动行为\nService区块定义如何启动当前服务。\n7.6.1 启动命令\n许多软件都有自己的环境参数文件，该文件可以用EnvironmentFile字段读取。\nEnvironmentFile字段：指定当前服务的环境参数文件。该文件内部的key=value键值对，可以用$key的形式，在当前配置文件中获取。\n上面的例子中，sshd 的环境参数文件是/etc/sysconfig/sshd。\n配置文件里面最重要的字段是ExecStart。\nExecStart字段：定义启动进程时执行的命令。\n上面的例子中，启动sshd，执行的命令是/usr/sbin/sshd -D $OPTIONS，其中的变量$OPTIONS就来自EnvironmentFile字段指定的环境参数文件。\n与之作用相似的，还有如下这些字段。\n\nExecReload字段：重启服务时执行的命令\nExecStop字段：停止服务时执行的命令\nExecStartPre字段：启动服务之前执行的命令\nExecStartPost字段：启动服务之后执行的命令\nExecStopPost字段：停止服务之后执行的命令\n\n请看下面的例子。\n[Service]ExecStart=/bin/echo execstart1ExecStart=ExecStart=/bin/echo execstart2ExecStartPost=/bin/echo post1ExecStartPost=/bin/echo post2\n上面这个配置文件，第二行ExecStart设为空值，等于取消了第一行的设置，运行结果如下。\nexecstart2\npost1\npost2\n所有的启动设置之前，都可以加上一个连词号（-），表示&quot;抑制错误&quot;，即发生错误的时候，不影响其他命令的执行。比如，EnvironmentFile=-/etc/sysconfig/sshd（注意等号后面的那个连词号），就表示即使/etc/sysconfig/sshd文件不存在，也不会抛出错误。\n7.6.2 启动类型\nType字段定义启动类型。它可以设置的值如下。\n\nsimple（默认值）：ExecStart字段启动的进程为主进程\nforking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程\noneshot：类似于simple，但只执行一次，Systemd 会等它执行完，才启动其他服务\ndbus：类似于simple，但会等待 D-Bus 信号后启动\nnotify：类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务\nidle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合\n\n下面是一个oneshot的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。\n[Unit]Description=Switch-off Touchpad[Service]Type=oneshotExecStart=/usr/bin/touchpad-off[Install]WantedBy=multi-user.target\n上面的配置文件，启动类型设为oneshot，就表明这个服务只要运行一次就够了，不需要长期运行。\n如果关闭以后，将来某个时候还想打开，配置文件修改如下。\n[Unit]Description=Switch-off Touchpad[Service]Type=oneshotExecStart=/usr/bin/touchpad-off startExecStop=/usr/bin/touchpad-off stopRemainAfterExit=yes[Install]WantedBy=multi-user.target\n上面配置文件中，RemainAfterExit字段设为yes，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用systemctl stop命令停止服务，ExecStop指定的命令就会执行，从而重新开启触摸板。\n7.6.3 重启行为\nService区块有一些字段，定义了重启行为。\nKillMode字段：定义 Systemd 如何停止 sshd 服务。\n上面这个例子中，将KillMode设为process，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对 sshd 很重要，否则你停止服务的时候，会连自己打开的 SSH session 一起杀掉。\nKillMode字段可以设置的值如下。\n- control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉- process：只杀主进程- mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号- none：没有进程会被杀掉，只是执行服务的 stop 命令。\n接下来是Restart字段。\nRestart字段：定义了 sshd 退出后，Systemd 的重启方式。\n上面的例子中，Restart设为on-failure，表示任何意外的失败，就将重启sshd。如果 sshd 正常停止（比如执行systemctl stop命令），它就不会重启。\nRestart字段可以设置的值如下。\n- no（默认值）：退出后不会重启- on-success：只有正常退出时（退出状态码为0），才会重启- on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启- on-abnormal：只有被信号终止和超时，才会重启- on-abort：只有在收到没有捕捉到的信号终止时，才会重启- on-watchdog：超时退出，才会重启- always：不管是什么退出原因，总是重启\n对于守护进程，推荐设为on-failure。对于那些允许发生错误退出的服务，可以设为on-abnormal。\n最后是RestartSec字段。\nRestartSec字段：表示 Systemd 重启服务之前，需要等待的秒数。上面的例子设为等待42秒。\n7.7 [Install] 区块\nInstall区块，定义如何安装这个配置文件，即怎样做到开机启动。\nWantedBy字段：表示该服务所在的 Target。\nTarget的含义是服务组，表示一组服务。WantedBy=multi-user.target指的是，sshd 所在的 Target 是multi-user.target。\n这个设置非常重要，因为执行systemctl enable sshd.service命令时，sshd.service的一个符号链接，就会放在/etc/systemd/system目录下面的multi-user.target.wants子目录之中。\nSystemd 有默认的启动 Target。\n$ systemctl get-defaultmulti-user.target\n上面的结果表示，默认的启动 Target 是multi-user.target。在这个组里的所有服务，都将开机启动。这就是为什么systemctl enable命令能设置开机启动的原因。\n使用 Target 的时候，systemctl list-dependencies命令和systemctl isolate命令也很有用。\n# 查看 multi-user.target 包含的所有服务$ systemctl list-dependencies multi-user.target# 切换到另一个 target# shutdown.target 就是关机状态$ sudo systemctl isolate shutdown.target\n一般来说，常用的 Target 有两个：一个是multi-user.target，表示多用户命令行状态；另一个是graphical.target，表示图形用户状态，它依赖于multi-user.target。官方文档有一张非常清晰的 Target 依赖关系图。\n7.8 Target 的配置文件\nTarget 也有自己的配置文件。\n$ systemctl cat multi-user.target[Unit]Description=Multi-User SystemDocumentation=man:systemd.special(7)Requires=basic.targetConflicts=rescue.service rescue.targetAfter=basic.target rescue.service rescue.targetAllowIsolate=yes\n注意，Target 配置文件里面没有启动命令。\n上面输出结果中，主要字段含义如下。\nRequires字段：要求basic.target一起运行。\nConflicts字段：冲突字段。如果rescue.service或rescue.target正在运行，multi-user.target就不能运行，反之亦然。\nAfter：表示multi-user.target在basic.target 、 rescue.service、 rescue.target之后启动，如果它们有启动的话。\nAllowIsolate：允许使用systemctl isolate命令切换到multi-user.target。\n7.9 修改配置文件后重启\n修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。\n# 重新加载配置文件$ sudo systemctl daemon-reload# 重启相关服务$ sudo systemctl restart foobar\n7、查看设置时区\n一、GMT、UTC、CST、DST 时间\n\nUTC\n\n 　　整个地球分为二十四时区，每个时区都有自己的本地时间。在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时(UTC, Universal Time Coordinated)。\n\nGMT\n\n 　　格林威治标准时间 (Greenwich Mean Time)指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。(UTC与GMT时间基本相同，本文中不做区分)\n\nCST\n\n 　　中国标准时间 (China Standard Time)\n\n\n\n1\nGMT + 8 = UTC + 8 = CST\n\n\n\n\nDST\n\n 　　夏令时(Daylight Saving Time) 指在夏天太阳升起的比较早时，将时间拨快一小时，以提早日光的使用。（中国不使用）\n二、硬件时间和系统时间\n\n硬件时间\n\nRTC(Real-Time Clock)或CMOS时间，一般在主板上靠电池供电，服务器断电后也会继续运行。仅保存日期时间数值，无法保存时区和夏令时设置。\n\n系统时间\n\n一般在服务器启动时复制RTC时间，之后独立运行，保存了时间、时区和夏令时设置。\n三、timedatectl 命令\n3.1使用指南\n[root@localhost ~]# timedatectl -htimedatectl [OPTIONS...] COMMAND ... Query or change system time and date settings.   -h --help                Show this help message     --version             Show package version     --no-pager            Do not pipe output into a pager     --no-ask-password     Do not prompt for password  -H --host=[USER@]HOST    Operate on remote host  -M --machine=CONTAINER   Operate on local container\n3.2命令示例(查看当前系统时间)\n#timedatectl#timedatectl status\n3.3设置当前时间\ntimedatectl set-time &quot;YYYY-MM-DD HH:MM:SS&quot;timedatectl set-time &quot;YYYY-MM-DD&quot;timedatectl set-time &quot;HH:MM:SS&quot;\n3.4查看所有可用的时区\ntimedatectl list-timezones# 亚洲timedatectl list-timezones |  grep  -E &quot;Asia/S.*&quot;\n3.5设置时区\ntimedatectl set-timezone Asia/Shanghai\n3.6设置硬件时间\n# 硬件时间默认为UTCtimedatectl set-local-rtc 1# hwclock --systohc --localtime# 两条命令效果等同\n3.7启动自动同步时间\ntimedatectl set-ntp yes# yes或no; 1或0也可以\n四、Chrony 服务器\nChrony：是网络时间协议的 (NTP) 的另一种实现，由两个程序组成，分别是chronyd和chronyc。\nchronyd：是一个后台运行的守护进程，用于调整内核中运行的系统时钟和时钟服务器同步。它确定计算机增减时间的比率，并对此进行补偿。\nchronyc：提供了一个用户界面，用于监控性能并进行多样化的配置。它可以在chronyd实例控制的计算机上工作，也可以在一台不同的远程计算机上工作。\n优势：\n\n更快的同步只需要数分钟而非数小时时间，从而最大程度减少了时间和频率误差，这对于并非全天 24 小时运行的台式计算机或系统而言非常有用。\n能够更好地响应时钟频率的快速变化，这对于具备不稳定时钟的虚拟机或导致时钟频率发生变化的节能技术而言非常有用。\n在初始同步后，它不会停止时钟，以防对需要系统时间保持单调的应用程序造成影响。\n在应对临时非对称延迟时（例如，在大规模下载造成链接饱和时）提供了更好的稳定性。\n无需对服务器进行定期轮询，因此具备间歇性网络连接的系统仍然可以快速同步时钟。\n\n注意：在CentOS7下为标配的时间同步服务，当然也可以使用以前的NTP同步方式，不过要安装NTP服务。\n服务端\n4.1安装使用\nyum install chronysystemctl start chronydsystemctl enable chronyd\n4.2配置文件修改\n当Chrony启动时，它会读取/etc/chrony.conf配置文件中的设置。也就是锁，如果需要更改时间同步的服务器，修改此配置文件即可。\n4.3客户端配置\n客户端的配置文件是同一个文件（/etc/chrony.conf），删掉那些没用的server xxxxxxxxxx iburst\n4.4常用命令\n- accheck 检查NTP访问是否对特定主机可用- activity 该命令会显示有多少NTP源在线/离线- add server 手动添加一台新的NTP服务器- clients 在客户端报告已访问到服务器- delete 手动移除NTP服务器或对等服务器- settime 手动设置守护进程时间- tracking 显示系统时间信息\n4.5案例介绍\n查看当前时间服务器状态\n[root@localhost ~]# chronyc chronyc&gt; activity #查看当前服务器状态，如下服务器有两个NTP源在线\n查看时间同步的信息来源\n[root@localhost ~]# chronyc  sources210 Number of sources = 2MS Name/IP address         Stratum Poll Reach LastRx Last sample   ^* time5.aliyun.com              2   6   377    31   +267us[ +573us] +/- 3769us^- 203.107.6.88                  2   6   377    31  -2586us[-2586us] +/-   38ms\n五、日常使用案例\ncentos7从外网同步时间和时区设置\n# 安装yum install chrony# 启用systemctl start chronydsystemctl enable chronyd# 设置亚洲时区timedatectl set-timezone Asia/Shanghai# 启用NTP同步timedatectl set-ntp yes\n也可以用NTP同步时间（不推荐）\n# 安装ntp服务yum install ntp# 开机启动服务systemctl enable ntpd# 启动服务systemctl start ntpd# 设置亚洲时区timedatectl set-timezone Asia/Shanghai# 启用NTP同步timedatectl set-ntp yes# 重启ntp服务systemctl restart ntpd# 手动同步时间ntpq -p\n常见问题：\n1、#date看到上的时间和#timedatectl看到的本地时间不同，需要我们注意一样。\n2、(Real-Time Clock)或CMOS时间和本地时间不同，需要执行timedatectl set-local-rtc 0\n[root@localhost ~]# dateThu Apr  5 17:22:34 CST 2018[root@localhost ~]# timedatectl      Local time: Thu 2018-04-05 17:22:38 CST  Universal time: Thu 2018-04-05 09:22:38 UTC        RTC time: Thu 2018-04-05 17:22:35       Time zone: Asia/Shanghai (CST, +0800)     NTP enabled: yes     NTP synchronized: yes     RTC in local TZ: yes     DST active: n/a Warning: The system is configured to read the RTC time in the local time zone.         This mode can not be fully supported. It will create various problems         with time zone changes and daylight saving time adjustments. The RTC         time is never updated, it relies on external facilities to maintain it.         If at all possible, use RTC in UTC by calling         &#x27;timedatectl set-local-rtc 0&#x27;.\n参考：https://www.jianshu.com/p/fb32239ccf2b\n8、 常用Linux命令\n2.1.1 命令帮助\nCentOS安装完成，今后的操作都是基于命令行的，后续内容只列出操作命令，不解释该命令的使用方法，可查阅相关手册。可以用下列方法了解具体命令的使用方法和参数。\n列出某个命令的使用手册，PgUp - PgDn翻页，q退出\n$ man tar\n命令帮助，后面加上 | more或者 | less使内容分页，空格键翻页，q退出\n$ tar --help | more$ tar --help | less\n一般在VMware虚机（或者阿里云这类的远程虚机）和主机之间，可以用鼠标右键进行命令行的文本粘贴。\n2.1.2 文本编辑器vi\n对文本文件或脚本文件的编辑，一般用vi编辑器，简要介绍如下：\n1、编辑某文件，如果此文件不存在，则新建一个\n$ vi /etc/abc.txt\n2、打开文件后，默认为命令模式，按键“i”进入编辑模式，左下角会出现 – INSERT – 字样。在输入模式中，可以使用以下按键：\n•\t字符按键以及Shift组合，输入字符•\tENTER，回车键，换行•\tBACK SPACE，退格键，删除光标前一个字符•\tDEL，删除键，删除光标后一个字符•\t方向键，在文本中移动光标•\tHOME/END，移动光标到行首/行尾•\tPage Up/Page Down，上/下翻页•\tInsert，切换光标为输入/替换模式，光标将变成竖线/下划线•\tESC，退出输入模式，切换到命令模式\n3、编辑完成后ESC，退出输入模式，切换到命令模式。在命令模式下按下:（英文冒号）就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。\n常用的有 :w 保存，:wq 保存后退出，:q 直接退出。\n一般在VMware虚机（或者阿里云这类的远程虚机）和主机之间，可以用鼠标右键进行文本粘贴。\n2.1.3 压缩解压缩\n最常用的压缩解压缩的命令是tar#这条命令是解出all.tar包中所有文件，-x是解开的意思$ tar -xf all.tar#这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。$ tar -cf all.tar \\*.jpg#这条命令是将所有.gif的文件增加到all.tar的包里面去$ tar -rf all.tar \\*.gif#这条命令是更新原来tar包all.tar中logo.gif文件$ tar -uf all.tar logo.gif#这条命令是列出all.tar包中所有文件$ tar -tf all.tar\n常用压缩文件的处理：\n1、\\*.tar 用 tar -xvf 解压2、\\*.gz 用 gzip -d或者gunzip 解压3、\\*.tar.gz和\\*.tgz 用 tar -xzf 解压4、\\*.bz2 用 bzip2 -d或者用bunzip2 解压5、\\*.tar.bz2用tar -xjf 解压6、\\*.Z 用 uncompress 解压7、\\*.tar.Z 用tar -xZf 解压8、\\*.rar 用 unrar e解压9、\\*.zip 用 unzip 解压\n2.1.4 软件包安装\nyum和rpm是紧密相关的安装命令。#查询perl包安装了没有$ rpm -q perl#查询含perl关键词的包安装了没有$ rpm -qa | grep perl#安装abc.rpm包$ rpm -ivh abc.rpm#升级abc.rpm包$ rpm -Uvh abc.rpm$ yum install perl gcc kernel-devel wget\n9、系统命令\n命令信息\nwinver 检查windows版本arch 显示机器的处理器架构(1)uname -m 显示机器的处理器架构(2)uname -r 显示正在使用的内核版本dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)hdparm -i /dev/hda 罗列一个磁盘的架构特性hdparm -tT /dev/sda 在磁盘上执行测试性读取操作cat /proc/cpuinfo 显示CPU info的信息cat /proc/interrupts 显示中断cat /proc/meminfo 校验内存使用cat /proc/swaps 显示哪些swap被使用cat /proc/version 显示内核的版本cat /proc/net/dev 显示网络适配器及统计cat /proc/mounts 显示已加载的文件系统lspci -tv 罗列 PCI 设备lsusb -tv 显示 USB 设备date 显示系统日期cal 2007 显示2007年的日历表date 041217002007.00 设置日期和时间 - 月日时分年.秒clock -w 将时间修改保存到 BIOS\n关机\nshutdown -h now 关闭系统(1)init 0 关闭系统(2)telinit 0 关闭系统(3)shutdown -h hours:minutes &amp; 按预定时间关闭系统shutdown -c 取消按预定时间关闭系统shutdown -r now 重启(1)reboot 重启(2)logout 注销\n文件目录\ncd /home 进入 &#x27;/ home&#x27; 目录&#x27;cd .. 返回上一级目录cd ../.. 返回上两级目录cd 进入个人的主目录cd ~user1 进入个人的主目录cd - 返回上次所在的目录pwd 显示工作路径ls 查看目录中的文件ls -F 查看目录中的文件ls -l 显示文件和目录的详细资料ls -a 显示隐藏文件ls -R 显示目录结构和目录内文件ls \\*[0-9]\\* 显示包含数字的文件名和目录名tree 显示文件和目录由根目录开始的树形结构(1)lstree 显示文件和目录由根目录开始的树形结构(2)mkdir dir1 创建一个叫做 &#x27;dir1&#x27; 的目录&#x27;mkdir dir1 dir2 同时创建两个目录mkdir -p /tmp/dir1/dir2 创建一个目录树rm -f file1 删除一个叫做 &#x27;file1&#x27; 的文件&#x27;rmdir dir1 删除一个叫做 &#x27;dir1&#x27; 的目录&#x27;rm -rf dir1 删除一个叫做 &#x27;dir1&#x27; 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容mv dir1 new\\_dir 重命名/移动 一个目录cp file1 file2 复制一个文件cp dir/\\* . 复制一个目录下的所有文件到当前工作目录cp -a /tmp/dir1 . 复制一个目录到当前工作目录cp -a dir1 dir2 复制一个目录ln -s file1 lnk1 创建一个指向文件或目录的软链接ln file1 lnk1 创建一个指向文件或目录的物理链接touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)\n文件搜索\nfind / -name file1 从 &#x27;/&#x27; 开始进入根文件系统搜索文件和目录find / -user user1 搜索属于用户 &#x27;user1&#x27; 的文件和目录find /home/user1 -name \\\\*.bin 在目录 &#x27;/ home/user1&#x27; 中搜索带有&#x27;.bin&#x27; 结尾的文件find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件find / -name \\\\*.rpm -exec chmod 755 &#x27;&#123;&#125;&#x27; \\; 搜索以 &#x27;.rpm&#x27; 结尾的文件并定义其权限find / -xdev -name \\\\*.rpm 搜索以 &#x27;.rpm&#x27; 结尾的文件，忽略光驱、捷盘等可移动设备locate \\\\*.ps 寻找以 &#x27;.ps&#x27; 结尾的文件 - 先运行 &#x27;updatedb&#x27; 命令whereis halt 显示一个二进制文件、源码或man的位置which halt 显示一个二进制文件或可执行文件的完整路径\n文件系统\nmount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 &#x27;/ mnt/hda2&#x27; 已经存在umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 &#x27;/ mnt/hda2&#x27; 退出fuser -km /mnt/hda2 当设备繁忙时强制卸载umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用mount /dev/fd0 /mnt/floppy 挂载一个软盘mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrommount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrommount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个网络共享\n磁盘空间\ndf -h 显示已经挂载的分区列表ls -lSr |more 以尺寸大小排列文件和目录du -sh dir1 估算目录 &#x27;dir1&#x27; 已经使用的磁盘空间&#x27;du -sk \\* | sort -rn 以容量大小为依据依次显示文件和目录的大小rpm -q -a --qf &#x27;%10&#123;SIZE&#125;t%&#123;NAME&#125;n&#x27; | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)dpkg-query -W -f=&#x27;$&#123;Installed-Size;10&#125;t$&#123;Package&#125;n&#x27; | sort -k1,1n 以大小为依据显示已安装的deb包所使用的 空间 (ubuntu, debian类系统)\n","categories":["Linux专题"],"tags":["Linux"]},{"title":"Debian11安装HyperledgeFabric","url":"/2022/12/29/HyperledgeFabric_tutorial/","content":"与我的另一篇文章结合着使用\n区块链环境配置教程 | CodeCook (dettry.github.io)\n一、准备\n在Vmware里有一个干净的Debian 11系统的虚机\n\n虚机名：deb-hlf  2核，4G内存，已安装JDK8，没有防火墙\n静态IP：192.168.138.31，网关、DNS：192.168.138.2\nVmware主机IP：192.168.138.1\n虚机通过主机网关访问外网OK，主机和同网段其他虚机通过IP访问本虚机OK\n主机可通过Putty密码，密钥方式远程连接虚机\n用户root / 4geT%not，zadmin / d00r%Key 是sudo组成员\n软件源：清华大学，华为，中科大\n\n安装Hyperledge Fabric过程参考：https://hyperledger-fabric.readthedocs.io/en/latest/getting_started.html\n说明：\n1.1 关于操作系统\n1. 硬件\n本例中原来分配给虚机的硬件配置是1核2G\n实际运行中发现速度比较快，内存使用率从来没超过60%，但最终还是把硬件配置调成了2核4G，以防万一。\n2. Debian\n本例使用了Debian 11，基础安装，没有GUI，这也是硬件开销非常小的原因。\nCentOS除了安装软件源apt和yum的区别外，其他的linux命令与Debian基本一样。所以后面的内容基于CentOS实现应该没有任何问题。Debian默认没有安装防火墙，如果使用CentOS需要关闭防火墙。\n采用Debian的原因，首先是因为Hyperledge官网的教程是基于Debian的。其次CentOS从版本8之后已经丧失了开源Linux服务器的领导地位，Debian被认为是最好的继任者，其稳定性不弱于CentOS。再次，Debian的基础系统比CentOS最小化安装更节省硬件资源。\nDebian的默认文本编辑器是nano，比vi更容易上手。如果习惯用vi或vim的话，在Debian里需要先删除系统里的vi tiny版，安装完整版。\napt remove vim-common -y\napt install vim -y\n最后，Debian里操作软件源，软件安装，建议使用apt而不是apt-get或dpkg\n1.2 关于远程连接虚机\n建议用Putty远程连接虚机，配置好root密钥连接。\n1. Debian控制台的字体太小，难看，Putty连接的控制台字体看的舒服得多。且Putty终端控制台窗口可以调整大小。Putty控制台窗口可以在命令行输入中文。\n2. Putty控制台有滚动条，大段的输出可以翻看。从Putty控制台鼠标选中大段文字，自动复制到剪贴板，然后可以粘贴到Word或其他Windows编辑工具中。从Word或网页复制的内容，在Putty控制台里点鼠标右键可自动粘贴到光标处，或粘贴到nano里。\n3. Putty可以开启多个root终端连接到同一个虚机。后面的步骤里除了主终端窗口外，还需要开启另一个终端窗口，观察docker运行日志。\n二、安装前置软件\n1. 安装Git\napt install git -y\n2. 安装curl\napt install curl -y\n3. 安装Docker\napt install docker-compose -y\n安装完毕后，确认Docker和Docker Compose的版本\ndocker --versiondocker-compose --version启动docker服务：systemctl start docker设置docker服务开机启动：systemctl enable docker将用户加入docker组：usermod -a -G docker root将另一管理员用户加入docker组：usermod -a -G docker zadmin\n建议重启一下，虽然不需要\n4. 安装Go\n5. 安装JQ\napt install jq\n三、安装Fabric\n参考：https://hyperledger-fabric.readthedocs.io/en/latest/install.html\n1. 准备工作目录\nmkdir -p /opt/go/src/github.com/zlz8x8\ncd /opt/go/src/github.com/zlz8x8\n目录创建在 /opt 下，这里一般是空的。zlz8x8 是我在github 的用户名\n2. 下载安装脚本\ncurl -sSLO https://raw.githubusercontent.com/hyperledger/fabric/main/scripts/install-fabric.sh &amp;&amp; chmod +x install-fabric.sh\n3. 执行安装脚本\n./install-fabric.sh\n没有参数，表示默认 docker binary samples，正是我们要的\n主机全程开VPN，否则无法连接github，大概500M内容，VPN如果有15~30分钟稳定即可完成安装。\n中间如果VPN不稳定，失败后重新执行脚本，下载过的内容会跳过，下载没有完成的会继续完成。\n四、使用Fabric test network\n4.1 开始之前\n参考：https://hyperledger-fabric.readthedocs.io/en/latest/test_network.html\n使用Fabric test network，包括：\n\n两个peer orgnazation和一个ordering organization\n为简单化，配置了一个单独节点Raft ordering service\n为简单化，没有部署TLS CA，所有证书由root CA颁发\n这个sample network用Docker Compose部署了一个Fabric网络。因为在Docker Compose network里的所有节点是隔离开（孤立）的，test network没有配置连接其他运行中的Fabric节点。\n\n4.2 启动test network\n1. 启动test network\n工作目录 /opt/go/src/github.com/zlz8x8\ncd fabric-samples/test-network./network.sh up\n就启动了，下面的命令关闭\n./network.sh down\n2. 检查test network各组件\ndocker ps -a\n输出可以看到fabric-tools，fabric-peer，fabric-orderer，fabric-peer和各自使用的端口。\npeer是Fabric网络的基本组件，peer保存区块链账本并在交易transaction提交到账本前进行验证。peer运行智能合约smart contract（里面包含了商业逻辑business logic），用来管理区块链上的资产asset。\n每个peer必须属于一个organization。在test network里，每个organization只有一个peer。从上面图可看出，两个organization是org1.example.com和org2.example.com，对应的两个peer分别是peer0.org1.example.com和peer0.org2.example.com。\n每个Fabric网络包括一个排序服务ordering service，…\n这个sample network使用了单个节点Raft ordering service，由排序节点orderer的组织来操作，就是上面的 orderer.example.com\n4.3 创建通道\n创建三个通道：\n./network.sh createChannel./network.sh createChannel -c channel1./network.sh createChannel -c channel2\n第一个通道没有指定名字，默认创建了mychannel，后面用到的。\n上面的命令指定了两个通道的名字。命名规则：ASCII小写字母数字，.，-，小于250字符，开头为字母。如果不指定名字./network.sh createChannel，会自动生成一个名字。\n这三个通道都是org1和org2之间的，并且org1和org2的peer都被邀请进了通道，每个通道有分开的区块链账本。\n4.4 在channel中执行chaincode\n代码是go代码，执行过程中要下载相关依赖，要开VPN\n先关机poweroff，做个快照，以防万一\n当前目录：/opt/go/src/github.com/zlz8x8/fabric-samples/test-network\n经测试发现，当./network.sh down关闭网络之后，再./network.sh up，所有的channel就都没有了。这次起网络和创建channel同时进行 ./network.sh up createChannel\n然后执行chaincode，需要主机开启VPN，执行过程中要从github和golan.org下载，大概也就5分钟不到。\n./network.sh deployCC -ccn basic -ccp …/asset-transfer-basic/chaincode-go -ccl go\n从输出看，chaincode在通道上提交了，并在peer0.org1和peer0.org2上都成功\n4.5 与网络交互\n在网络起来后，可以用pear CLI（命令行界面）与网络进行交互。peer CLI可以调用已部署的智能合约，更新通道，或安装并部署新的智能合约。\n工作路径：/opt/go/src/github.com/zlz8x8\ntest network路径：/opt/go/src/github.com/zlz8x8/fabric-samples/test-network\n将此路径定义为 $HLF_TEST_PATH，以下路径以此为基准。\nCLI路径为 $HLF_TEST_PATH/…/bin，这个路径需要放到 $PATH里\n配置文件core.yaml所在路径 $FABRIC_CFG_PATH=$HLF_TEST/…/config/ 需要定义在 /etc/profile 里。\nnano /etc/profile 在文件最后添加如下内容\nexport HLF\\_TEST\\_PATH=/opt/go/src/github.com/zlz8x8/fabric-samples/test-networkexport PATH=$HLF\\_TEST\\_PATH/../bin:$PATHexport FABRIC\\_CFG\\_PATH=$HLF\\_TEST\\_PATH/../config/\n保存后，更新系统变量 source /etc/profile，然后 echo $HLF_TEST_PATH看看系统变量生效没有。\n以下默认在 /opt/go/src/github.com/zlz8x8/fabric-samples/test-network 路径工作，以下的命令都以此路径为基准，下文中出现的 ${PWD} 代表的就是这个路径。\n命令行输入如下命令，设置系统变量，后面的peer命令就是在Org1上运行的了\n这些系统变量没有写在 /etc/profile 里面，是临时的，系统关闭或重启就没有了。可以在该目录下新建一个文件setOrgEnv1，把下面的命令放在里面，需要执行这些命令的时候只需要执行source setOrgEnv1就可以了。\n因此，此时执行 source setOrgEnv1 即可，或执行下面命令：\nexport CORE\\_PEER\\_TLS\\_ENABLED=trueexport CORE\\_PEER\\_LOCALMSPID=&quot;Org1MSP&quot;export CORE\\_PEER\\_TLS\\_ROOTCERT\\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtexport CORE\\_PEER\\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE\\_PEER\\_ADDRESS=localhost:7051\n输入下面命令初始化资产的账本\npeer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot; -c &#x27;&#123;&quot;function&quot;:&quot;InitLedger&quot;,&quot;Args&quot;:[]&#125;&#x27;\n命令虽然很长，执行很快，不到1秒，看到输出 status:200 说明成功了\n现在可以通过CLI查询账本，运行下面命令查询添加到通道账本的资产\npeer chaincode query -C mychannel -n basic -c &#x27;&#123;&quot;Args&quot;:[&quot;GetAllAssets&quot;]&#125;&#x27;\n执行成功，查询结果输出如下：注意asset6的owner是Michel\n当一个网络成员希望转移或更改账本中的某项资产，就可以调用链码chaincode\npeer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot; -c &#x27;&#123;&quot;function&quot;:&quot;TransferAsset&quot;,&quot;Args&quot;:[&quot;asset6&quot;,&quot;Christopher&quot;]&#125;&#x27;\n执行成功，输出如下 status:200\n因为背书endorsement策略，资产转移 asset-tranfer (basic) 链码需要Org1和Org2的签名，因此链码调用需要用 --peerAddresses 标签指向 peer0.org1.example.com 和 peer0.org2.example.com 。另外，网络使用了TLS连接，命令需要用 --tlsRootCertFiles 引用TLS证书。\n在上述链码执行后，我们可以用另一个查询取看看这次调用如何改变了账本里的资产。已经使用org1进行了查询，下面使用org2 peer进行查询。\n命令行输入如下命令，设置系统变量，后面的peer命令就是在Org2上运行的了\n可以在该目录下新建一个文件setOrgEnv2，把下面的命令放在里面，需要执行这些命令的时候只需要执行source setOrgEnv2就可以了。\n执行 source setOrgEnv2 即可，或执行下面命令：\nexport CORE\\_PEER\\_TLS\\_ENABLED=trueexport CORE\\_PEER\\_LOCALMSPID=&quot;Org2MSP&quot;export CORE\\_PEER\\_TLS\\_ROOTCERT\\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtexport CORE\\_PEER\\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE\\_PEER\\_ADDRESS=localhost:9051\n相同的系统变量名，不同的值，会覆盖之前的Org1设置。\n然后执行下面命令查询资产转移（跑在peer0.org2.example.com上的basic链码）\npeer chaincode query -C mychannel -n basic -c &#x27;&#123;&quot;Args&quot;:[&quot;ReadAsset&quot;,&quot;asset6&quot;]&#125;&#x27;\n执行成功，可以看到asset6的owner已经变成了Christopher\n4.6 关闭网络\n使用下面命令关闭网络。这将停止并移除node和chaincode的容器，删除organization的加密内容，移除链码在Docker Registry里的镜像image，移除之前运行的通道和docker volume。\n./network.sh down\n4.7 启动有CA的网络\nHyperledge Fabric使用PKI（Public key infrastructure，公钥基础设施）验证所有的网络参与者。每个节点node，网络管理员和用户提交交易都必须提供公钥和私钥进行身份验证。这些证书由CA颁发。\n默认情况下，前面运行的 ./network.sh up 提供了加密工具cryptogen，供开发和测试。观察 ./network.sh up 的输出日志，可以看到加密工具为Org1，Org2和Orderer Org创建了证书和密钥。\ntest network也提供了选项在启动网络时使用CA（Certificate Authority，证书中心）。在生产网络production network，每个organization都运行一个CA（称为 中间CA）为其组织颁发证书。这些CA共享一个根信任root trust。虽然使用CA比使用cryptogen花费更多的时间，但分布式生产网络需要CA部署。CA还可以添加新的客户端身份认证和为应用程序创建证书和私钥。\n下面命令启动带CA的网络，第二个命令同时创建通道，第三个命令把执行命令的输出写到文件out.log中，方便查看，加参数 -a 表示末尾添加模式而不是删除重写模式。\n./network.sh up -ca./network.sh up createChannel -ca\n如果是用Putty连接虚机，执行命令后可以看到完整输出（窗口有滚动条）。可以看到创建网络后第一件是就是创建了3个CA。\n用下面命令查看Org1的MSP（Membership service provider）文件夹。执行发现没有tree命令，安装 apt install tree，然后执行下面命令。\ntree organizations/peerOrganizations/org1.example.com/users/Admin**@org1**.example.com/\n可以看到 *.pem 就是密钥文件，keystore里保存的也是密钥。\n五、向通道部署智能合约\n首先进入工作路径，启动网络：\ncd /opt/go/src/github.com/zlz8x8/fabric-samples/test-network./network.sh up createChannel\n设置Logspout，可选。\n如果是直接系统登录情况下是无法打开第二个终端窗口的。用Putty连接虚机，进行工作操作，然后再打开一个Putty连接到同一个虚机，就有两个终端窗口了。从第二个终端窗口进入工作目录，开启logspout\ncd /opt/go/src/github.com/zlz8x8/fabric-samples/test-network./monitordocker.sh fabric\\_test\n如果是第一次运行，需要拉取相应的image，似乎不需要VPN，很快\n然后光标就停在一长串数字下面了，这是正常的，等待输出。\n从第一个窗口工作路径下运行 docker stop logspout 就可以停止第二个窗口的等待状态，进入光标。从第二个窗口再次运行 ./monitordocker.sh fabric_test 就再次监视docker的状态，等待输出。\n5.1 打包智能合约\n本例中的智能合约有三种语言go，javascript，typescript写的代码。go语言的包被用在后面的步骤“向通道安装智能合约”中，javascript语言的包被用在后面的步骤“升级智能合约”中，typescript的包没有使用，要用的话步骤和go和javascript是一样的。\n5.1.1 Go\n在工作路径：/opt/go/src/github.com/zlz8x8/fabric-samples/test-network\ncd ../asset-transfer-basic/chaincode-go\n可以看一下这个目录下 go.mod 的内容，智能合约的部分是如何写的。\nGO111MODULE=on go mod vendor\n开始下载依赖包，编译，应该需要VPN，大概1秒钟，生成的模块在vendor目录下。\ncd ../../test-networkpeer versionpeer lifecycle chaincode package basic.tar.gz --path ../asset-transfer-basic/chaincode-go/ --lang golang --label basic\\_1.0\n在工作路径 /opt/go/src/github.com/zlz8x8/fabric-samples/test-network 下就生成了一个basic.tar.gz包。打包go完成。\n5.1.2 Javascript\n安装nodejs和npm，大概下载500M，设置了清华源，很快\napt install nodejs npm\n设置npm代理，否则运行时会卡死\nnpm config set registry https://registry.npm.taobao.orgnpm config get registry\n在工作路径：/opt/go/src/github.com/zlz8x8/fabric-samples/test-network\ncd ../asset-transfer-basic/chaincode-javascript\n可以看一下 lib/assetTransfer.js 的内容，智能合约的部分是如何写的。\nnpm install\n会新生成一个node_modules目录，生成的模块在此目录下\ncd ../../test-network\n不执行打包命令，后面会执行打包命令为升级包2.0。要执行的话，把go的打包命令中的–path …/asset-transfer-basic/chaincode-javascript/ 换了，–lang node 换了，并且要更改包名，否则会覆盖前面生成的 basic.tar.gz\n5.1.3 Typescript\n在工作路径：/opt/go/src/github.com/zlz8x8/fabric-samples/test-network\ncd ../asset-transfer-basic/chaincode-typescript\n可以看一下 src/assetTransfer.ts 的内容，智能合约部分是如何写的。\nnpm install\n会新生成一个node_modules目录，生成的模块在此目录下\ncd ../../test-network\n不执行打包命令，要执行的话，把go的打包命令中的–path …/asset-transfer-basic/chaincode-typescript/ 换了，–lang node 换了，并且要更改包名，否则会覆盖前面生成的 basic.tar.gz\n5.2 安装链码包\n在工作路径：/opt/go/src/github.com/zlz8x8/fabric-samples/test-network\n确认目录下有 basic.tar.gz，就是之前打包的go链码。关闭网络后，这个文件就被删除了，需要重新执行打包步骤。可以 cp basic.tar.gz basic.tar.gz.bak 留个备份。下次启动网络，可以跳过打包步骤，从备份拷贝回来cp basic.tar.gz.bak basic.tar.gz\n确认网络已启动，管道已创建\n确认有两个命令行窗口，一个是主窗口，另一个运行了./monitordocker.sh fabric_test 在等待输出。\n首先在org1 peer上安装链码，设置系统org1参数。执行 source setOrgEnv1 即可，或执行下面命令：\nexport CORE\\_PEER\\_TLS\\_ENABLED=trueexport CORE\\_PEER\\_LOCALMSPID=&quot;Org1MSP&quot;export CORE\\_PEER\\_TLS\\_ROOTCERT\\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtexport CORE\\_PEER\\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE\\_PEER\\_ADDRESS=localhost:7051\n执行下面命令。可以看到监视窗口有大量输出，可以看到安装链码的是 peer0.org1\npeer lifecycle chaincode install basic.tar.gz\n主窗口只输出结果，和监视窗口最后的输出是一样的。Putty窗口鼠标选中的内容就自动复制到剪贴板了，到这里粘贴如下：\n2022-12-10 21:34:34.245 CST 0001 INFO [cli.lifecycle.chaincode] submitInstallProposal -&gt; Installed remotely:  response:&lt;status:200 payload:“\\nJbasic_1.0:56069c8c46fe01a7837a218a6e2ab49a2b6c4a715c95ab2ab321a863b642d021\\022\\tbasic_1.0” &gt;\n2022-12-10 21:34:34.260 CST 0002 INFO [cli.lifecycle.chaincode] submitInstallProposal -&gt; Chaincode code package identifier: basic_1.0:56069c8c46fe01a7837a218a6e2ab49a2b6c4a715c95ab2ab321a863b642d021\n然后设置org2系统变量，在org2 peer上安装链码。执行 source setOrgEnv2 即可，或执行下面命令：\nexport CORE\\_PEER\\_LOCALMSPID=&quot;Org2MSP&quot;export CORE\\_PEER\\_TLS\\_ROOTCERT\\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtexport CORE\\_PEER\\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE\\_PEER\\_ADDRESS=localhost:9051\n执行下面命令。可以看到监视窗口有大量输出，主窗口输出和上面一样，安装成功。\npeer lifecycle chaincode install basic.tar.gz\n5.3 确认链码定义\n紧跟上面步骤，现在身份是org2，首先查询已安装的链码：\npeer lifecycle chaincode queryinstalled\n输出如下：\nInstalled chaincodes on peer:\nPackage ID: basic_1.0:56069c8c46fe01a7837a218a6e2ab49a2b6c4a715c95ab2ab321a863b642d021, Label: basic_1.0\n这里的Package ID在确认链码的时候要用，我们用它设置一个系统变量：\nexport CC\\_PACKAGE\\_ID=basic\\_1.0:56069c8c46fe01a7837a218a6e2ab49a2b6c4a715c95ab2ab321a863b642d021\n设置了这个系统参数，后面org1确认链码的时候也可以用，所以org1在确认的时候就省略这一步了。\n确认链码定义：\npeer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --package-id $CC\\_PACKAGE\\_ID --sequence 1 --tls --cafile &quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;\n输出如下：\n2022-12-11 17:04:26.913 CST 0001 INFO [chaincodeCmd] ClientWait -&gt; txid [700a4f809b4baa7b7ae2debf5ffd20626c4a035436b3e7e7e6430c76d27ba4be] committed with status (VALID) at localhost:9051\n上面步骤的解释（未翻译）：\nThe command above uses the --package-id flag to include the package identifier in the chaincode definition. The --sequence parameter is an integer that keeps track of the number of times a chaincode has been defined or updated. Because the chaincode is being deployed to the channel for the first time, the sequence number is 1. When the asset-transfer (basic) chaincode is upgraded, the sequence number will be incremented to 2. If you are using the low level APIs provided by the Fabric Chaincode Shim API, you could pass the --init-required flag to the command above to request the execution of the Init function to initialize the chaincode. The first invoke of the chaincode would need to target the Init function and include the --isInit flag before you could use the other functions in the chaincode to interact with the ledger.\nWe could have provided a --signature-policy or --channel-config-policy argument to the approveformyorg command to specify a chaincode endorsement policy. The endorsement policy specifies how many peers belonging to different channel members need to validate a transaction against a given chaincode. Because we did not set a policy, the definition of asset-transfer (basic) will use the default endorsement policy, which requires that a transaction be endorsed by a majority of channel members present when the transaction is submitted. This implies that if new organizations are added or removed from the channel, the endorsement policy is updated automatically to require more or fewer endorsements. In this tutorial, the default policy will require a majority of 2 out of 2 and transactions will need to be endorsed by a peer from Org1 and Org2.\n下面用org1来确认链码，执行 source setOrgEnv1 即可，或执行下面命令：\nexport CORE\\_PEER\\_LOCALMSPID=&quot;Org1MSP&quot;export CORE\\_PEER\\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE\\_PEER\\_TLS\\_ROOTCERT\\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtexport CORE\\_PEER\\_ADDRESS=localhost:7051\n然后用org1确认链码定义：\npeer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --package-id $CC\\_PACKAGE\\_ID --sequence 1 --tls --cafile &quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;\n输出如下，跟org2的输出比较一下，最后的端口号不一样了。\n2022-12-11 17:48:34.122 CST 0001 INFO [chaincodeCmd] ClientWait -&gt; txid [f6cd1365d631880f7753a7e4e91d1de34444e17659b6d5dc11869d5a7815e670] committed with status (VALID) at localhost:7051\n5.4 向通道提交链码定义\n紧跟上述步骤，现在peer身份是org1\n下面命令查询有哪些成员确认了链码：\npeer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; --output json\n输出如下，说明org1和org2已经确认了链码：\n{\n      “approvals”: {\n              “Org1MSP”: true,\n              “Org2MSP”: true\n      }\n}\n网络里只有org1和org2，都已经确认，现在链码定义已经可以提交到通道，用下面的命令提交链码定义：从下面的命令可以看出，以org1和org2身份提交了。\npeer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --sequence 1 --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;\n输出如下，说明org1和org2都提交了链码：\n2022-12-11 17:55:17.072 CST 0001 INFO [chaincodeCmd] ClientWait -&gt; txid [2950340b01b19046b2ed345900c6b50a32a947ff529263e728c53eea7247d718] committed with status (VALID) at localhost:9051\n2022-12-11 17:55:17.088 CST 0002 INFO [chaincodeCmd] ClientWait -&gt; txid [2950340b01b19046b2ed345900c6b50a32a947ff529263e728c53eea7247d718] committed with status (VALID) at localhost:7051\n用下面的命令查询已提交的链码：\npeer lifecycle chaincode querycommitted --channelID mychannel --name basic --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;\n输出如下，包含了已提交的链码的信息：\nCommitted chaincode definition for chaincode ‘basic’ on channel ‘mychannel’:\nVersion: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]\n5.5 调用链码\n链码已经提交到通道，可以被client application调用，并且链码会在各个加入的peer（org1和org2）上运行。\n执行下面命令调用链码，在账本创建一个初始化的资产集。注意调用命令要标的（target）足够多的peer以满足背书策略，现在只有org1和org2。\npeer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot; -c &#x27;&#123;&quot;function&quot;:&quot;InitLedger&quot;,&quot;Args&quot;:[]&#125;&#x27;\n输出如下，执行成功：\n2022-12-11 18:07:14.083 CST 0001 INFO [chaincodeCmd] chaincodeInvokeOrQuery -&gt; Chaincode invoke successful. result: status:200\n用下面的命令查询刚才创建的资产（cars）集：\npeer chaincode query -C mychannel -n basic -c &#x27;&#123;&quot;Args&quot;:[&quot;GetAllAssets&quot;]&#125;&#x27;\n输出如下：\n[{“AppraisedValue”:300,“Color”:“blue”,“ID”:“asset1”,“Owner”:“Tomoko”,“Size”:5},{“AppraisedValue”:400,“Color”:“red”,“ID”:“asset2”,“Owner”:“Brad”,“Size”:5},{“AppraisedValue”:500,“Color”:“green”,“ID”:“asset3”,“Owner”:“Jin Soo”,“Size”:10},{“AppraisedValue”:600,“Color”:“yellow”,“ID”:“asset4”,“Owner”:“Max”,“Size”:10},{“AppraisedValue”:700,“Color”:“black”,“ID”:“asset5”,“Owner”:“Adriana”,“Size”:15},{“AppraisedValue”:800,“Color”:“white”,“ID”:“asset6”,“Owner”:“Michel”,“Size”:15}]\n5.6 升级智能合约\n前面步骤已经安装、提交、调用了go链码。下面打包javascript链码并安装，对智能合约进行升级。\n5.6.1 打包链码\n前面没有执行javascript链码打包，现在执行打包命令：\ncd ../asset-transfer-basic/chaincode-javascriptnpm install\n回到工作路径\ncd ../../test-network\n执行系统参数设置：\nexport PATH=$&#123;PWD&#125;/../bin:$PATHexport FABRIC\\_CFG\\_PATH=$PWD/../config/export CORE\\_PEER\\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp\n注意：前两项设置已经在“4.5 与网络交互”写在 /etc/profile 里了，开机已经有了，这里只需要执行第三行。\n执行打包命令：\npeer lifecycle chaincode package basic\\_2.tar.gz --path ../asset-transfer-basic/chaincode-javascript/ --lang node --label basic\\_2.0\n工作目录下会多一个basic_2.tar.gz，网络关闭后，这个文件会被删除，我们备份一下cp basic_2.tar.gz basic_2.tar.gz.bak，下次重启网络，可以跳过打包步骤，把备份的文件恢复回来就行了cp basic_2.tar.gz.bak basic_2.tar.gz\n5.6.2 安装链码\n下面用org1来安装链码，执行 source setOrgEnv1 即可，或执行下面命令：\nexport CORE\\_PEER\\_TLS\\_ENABLED=trueexport CORE\\_PEER\\_LOCALMSPID=&quot;Org1MSP&quot;export CORE\\_PEER\\_TLS\\_ROOTCERT\\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtexport CORE\\_PEER\\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE\\_PEER\\_ADDRESS=localhost:7051\n安装链码：\npeer lifecycle chaincode install basic\\_2.tar.gz\n查询已安装的链码：\npeer lifecycle chaincode queryinstalled\n输出如下，可以看到已安装了两个链码：\nInstalled chaincodes on peer:\nPackage ID: basic_2.0:a496470e6e35a564619781f41bc17eef4db685c222aa0b89ed3dfb4b668206f5, Label: basic_2.0\nPackage ID: basic_1.0:56069c8c46fe01a7837a218a6e2ab49a2b6c4a715c95ab2ab321a863b642d021, Label: basic_1.0\n5.6.3 确认链码\n用上面的链码ID设置一个系统变量，注意这里的ID要和你的查询输出里的一致：\nexport NEW\\_CC\\_PACKAGE\\_ID=basic\\_2.0:a496470e6e35a564619781f41bc17eef4db685c222aa0b89ed3dfb4b668206f5\n现在以org1确认链码：\npeer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 2.0 --package-id $NEW\\_CC\\_PACKAGE\\_ID --sequence 2 --tls --cafile &quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;\n下面用org2来安装、确认链码，执行 source setOrgEnv2 即可，或执行下面命令：\nexport CORE\\_PEER\\_LOCALMSPID=&quot;Org2MSP&quot;export CORE\\_PEER\\_TLS\\_ROOTCERT\\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crtexport CORE\\_PEER\\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/mspexport CORE\\_PEER\\_ADDRESS=localhost:9051\n安装链码：\npeer lifecycle chaincode install basic\\_2.tar.gz\n确认链码：\npeer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 2.0 --package-id $NEW\\_CC\\_PACKAGE\\_ID --sequence 2 --tls --cafile &quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;\norg1和org2都安装，确认了链码。检查一下basic_2是否已准备好提交了：\npeer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 2.0 --sequence 2 --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; --output json\n从输出来看，org1和org2都确认了，可以提交：\n{\n      “approvals”: {\n              “Org1MSP”: true,\n              “Org2MSP”: true\n      }\n}\n5.6.4 提交链码\n提交新的链码，从前面的步骤可知，下面的命令是以org1或org2的身份执行的，都会以两者的身份提交。\npeer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 2.0 --sequence 2 --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;\n验证一下新的链码已经在各个peer上运行了：\ndocker ps\n下面输出（部分），可看到，basic_2.0在org1和org2上都有：\n7c2ad4f2b66d   dev-peer0.org2.example.com-basic_2.0-a496470e6e35a564619781f41bc17eef4db685c222aa0b89ed3dfb4b668206f5-a394028e6792b45700d3e09782af3f93d9c18f9bfb8be6f4f761730f94faad53   “docker-entrypoint.s…”   54 seconds ago      Up 53 seconds                                                                               dev-peer0.org2.example.com-basic_2.0-a496470e6e35a564619781f41bc17eef4db685c222aa0b89ed3dfb4b668206f5\n298b812c2dee   dev-peer0.org1.example.com-basic_2.0-a496470e6e35a564619781f41bc17eef4db685c222aa0b89ed3dfb4b668206f5-5113a692e1e282cd0168c26a4ec379486b6a8dfb8fe03e6043a805669c5b2696   “docker-entrypoint.s…”   54 seconds ago      Up 53 seconds                                                                               dev-peer0.org1.example.com-basic_2.0-a496470e6e35a564619781f41bc17eef4db685c222aa0b89ed3dfb4b668206f5\n5.6.5 调用链码\n如果使用了 --init-required 参数，则需要在使用链码前调用 Init 方法。本例中不需要执行 Init，下面测试创建一个新 car\npeer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot; -c &#x27;&#123;&quot;function&quot;:&quot;CreateAsset&quot;,&quot;Args&quot;:[&quot;asset8&quot;,&quot;blue&quot;,&quot;16&quot;,&quot;Kelley&quot;,&quot;750&quot;]&#125;&#x27;\n输出返回值 status:200 成功了。\n用下面的命令查询资产（cars）集：\npeer chaincode query -C mychannel -n basic -c &#x27;&#123;&quot;Args&quot;:[&quot;GetAllAssets&quot;]&#125;&#x27;\n输出如下，可以看到比“5.5 调用链码”里的输出多了一个asset8\n[{“AppraisedValue”:300,“Color”:“blue”,“ID”:“asset1”,“Owner”:“Tomoko”,“Size”:5},{“AppraisedValue”:400,“Color”:“red”,“ID”:“asset2”,“Owner”:“Brad”,“Size”:5},{“AppraisedValue”:500,“Color”:“green”,“ID”:“asset3”,“Owner”:“Jin Soo”,“Size”:10},{“AppraisedValue”:600,“Color”:“yellow”,“ID”:“asset4”,“Owner”:“Max”,“Size”:10},{“AppraisedValue”:700,“Color”:“black”,“ID”:“asset5”,“Owner”:“Adriana”,“Size”:15},{“AppraisedValue”:800,“Color”:“white”,“ID”:“asset6”,“Owner”:“Michel”,“Size”:15},{“AppraisedValue”:“750”,“Color”:“blue”,“ID”:“asset8”,“Owner”:“Kelley”,“Size”:“16”}]\n5.6.6 清理并关闭网络\n如果开了监视窗口，监视窗口无法输入，在主窗口执行下面命令停止监视：\ndocker stop logspoutdocker rm logspout\n关闭网络：\n./network.sh down\n建议这里把虚拟机拍个快照。虽然关闭网络把前面在网络里做的事情都清除了，但快照可以保留：tree，nodejs，npm的安装，自己写的文档 setOrgEnv1，setOrgEnv2，链码包的备份，写在 /etc/profile 里长期生效的系统变量。\n六、运行一个Fabric Application\n七、运行外部链码编译器\n八、在Fabric里使用私有数据\n九、在Fabric里保障资产转移的安全\n十、使用CouchDB\n十一、创建一个通道\n十二、向通道加入Org\n十三、更新一个通道的配置\n十四、编写第一个链码\n十五、在开发模式运行链码\n","categories":["Linux专题"],"tags":["HyperledgeFabric"]},{"title":"Java笔记","url":"/2023/05/05/Java_note/","content":"Java笔记\n基础篇\n\njava语言概述\n整体概述\n\njava语言的特点\n特点一：面向对象\n两概三特：类、对象；封装、继承、多态；\n特点二：健壮性\n去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等）\n特点三：跨平台性\n原理：先安装一个JVM虚拟机，然后由JVM负责JAVA程序在该系统上运行。\nJava核心机制\nJava虚拟机：对于不同的平台有不同的虚拟机；\n垃圾回收机制：\n注释\n单行和多行注释与c语言注释相同\n文档注释：JAVA所特有\n格式：/**  */\n作用：注释的内容可以被jdk提供的工具javadoc所解析，生成网页形式的程序说明文档。\njava API文档\n英文版：版本8\n中文版：版本6\nJava基本语法\n保留字\ngoto、const，java没有赋予其特殊含义，但在命名时尽量避开。\n标识符\n凡是可以自己起的名字都叫标识符。e.g：变量名、类名等等\n命名规范\n包名：多个单词组成时所有字母都小写\n类名、接口名：多单词组成时，所有单词首字母大写\n变量名、方法名：多单词组成时，第一个单词首字母小写，从第二个单词开始首字母大写。\n常量名：所有字母都大写，多单词时，每个单词用下划线连接。\n变量的类型\n\n变量运算规则的两种特殊情况\n定义long型变量：long len=78899786676l/L;\n定义float型变量：float len=12.3f/F;\n但现实经常使用double型变量，精度更高。\n整型常量默认类型：int\n浮点型常量默认类型：double\n算数运算符\n+、-、*、/、++、–、%\n赋值运算符\n=\n扩展运算符:+=、-=、*=、/+、%=\n比较运算符\n基本与c语言一样。\ninstanceof:检查是否是类的对象。\n进阶篇\nSpringBoot\n开发以后所用技术：mybatis+druid+远程服务器，别使用lombok进行开发。\n基础篇\n1. parent\n将以前spring开发时所需要配置的pom 文件进行整合，方便管理。\n\n小结\n\n\n开发springBoot程序要继承spring-boot-starter-parent\n\n\nspring-boot-starter-parent中定义了若干个依赖管理（不是具体的坐标，只是把你要用的版本管理好，而没提供具体的坐标）\n\n\n继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突（做版本的统一化管理)\n\n\n继承parent的形式也可以采用引入依赖的形式实现效果\n\n\n2. starter\nstarter\n​\t\t1. SpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标 ，以达到减少依赖配置的目的\nparent\n\t1. 所有SpringBoot项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的\n\t1. spring-boot-starter-parent各版本间存在着诸多坐标版本不同\n\n实际开发\n\n\n使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供，除非SpringBoot未提供对应版本V\n\n\n如发生坐标错误，再指定Version（要小心版本冲突)\n\n\n小结\n\n开发springBoot程序需要导入坐标时通常导入对应的starter\n每个不同的starter根据功能不同，通常包含多个依赖坐标\n使用starter可以实现快速配置的效果，达到简化配置的目的\n\n3. 引导类\n下图即为引导类\n\n无论是做spring程序还是做springmvc的程序，最后都会运行出来一个spring容器的对象。所有对象都以bean的形式交给spring容器管理。\nSpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目\nSpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean\n得到bean的方式有四种：\n\n以类型的形式（即class）\n\n\n4. 辅助功能\n\n\n内置服务器：\ntomcat(默认)\njetty\nundertow\n\n小结\n\n内嵌Tomcat服务器是SpringBoot辅助功能之一\n内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理\n变更内嵌服务器思想是去除现有服务器，添加全新的服务器\n\n5. Rest风格开发入门案例\n1.以前的开发\n\n\n2. 接受参数的三种方式\n\n3.现在的开发\n\n\n6. boot配置\n6.1 准备工作\n模板的制作\n\n在工作空间中复制对应工程，并修改工程名称\n删除与Idea相关配置文件，仅保留src目录与pom. xml文件\n修改pom.xml文件中的artifactId与新工程/模块名相同\n删除name标签（可选)\n保留备份工程供后期使用\n\n6.2 属性配置\n\n\n\nSpringBoot提供了3种配置文件的格式\nproperties (传统格式/默认格式)\nyml（主流格式)\nyaml\n\n\n配置文件间的加载优先级\nproperties (最高)\nyml（常用）\nyaml(最低)\n\n\n不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留\n\n\nyaml或者yml自动提示功能消失解决方案\n\nyaml书写格式：注意属性名冒号后面与数据之间有一个空格\n读取数据\n\n7. 整合第三方技术\n\n\n整合junit小结\n\n\n导入测试对应的starter(如果是自己手工创建的话)\n\n\n测试类使用@SpringBootTest修饰\n\n\n使用自动装配的形式添加要测试的对象\n\n\n测试类如果存在于引导类所在包或子包中无需指定引导类\n\n\n测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类\n\n\n\n\n整合mybatis小结\n\n\n勾选MyBatis技术，也就是导入MyBatis对应的starter\n\n\n数据库连接相关信息转换成配置\n\n\n数据库sQL映射需要添加@Mapper被容器识别到\nspringboot的版本过低导致的问题处理\n\n\n\n\n\n​\t\t\t2.1 MySQL 8.X驱动强制要求设置时区\n​\t\t\t\t修改url，添加serverTimezone设定\n​\t\t\t\t修改MySQL数据库配置（略)\n​\t\t\t2.2 驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver\n\nboot整合东西分为三个部分:\n\n导入对应的start\n做相应的配置\n直接使用对应的技术进行开发\n\n\n\n整合mybatis-plus小结 \n\n\n\n\n整合Druid(即数据源)\n\n​      \n\n\n\n","categories":["Java开发专题"],"tags":["Java"]},{"title":"Linux笔记","url":"/2023/05/05/Linux_note/","content":"Linux笔记\n1. 目录结构\n\n2. 常用命令\n2.1 ls\n对应英文：list\n作用： 查看当前目录下的内容\nll 对应 ls -l\n作用： 查看当前目录下的所有内容和每个文件的详细信息。\n2.2 pwd\n对应英文：print work directory\n作用： 查看当前所在目录\n2.3 touch\ntouch [文件名]\n作用：如果文件不存在，新建文件\n2.4 cd\n~表示当前用户的home目录\n.表示当前所在目录\n…表示当前目录位置的上级目录\n2.5 cat\ncat [-n] fileName\n-n: 由1开始对所有输出的行数编号\ncat /etc/profile   查看/etc目录下的profile文件内容\n2.6 rmdir\n作用：删除空目录\n语法：rmdir [-p] dirName\n-p: 当子目录被删除后使父目录为空目录的话，则一并删除\nrm\n作用：删除文件或者目录\n语法：rm [-rf] name\n-r:将目录及目录中的所有文件（目录）逐一删除，即递归删除\n-f: 无需确认直接删除\n2.7 tar\n作用：对文件进行打包、解包、压缩、解压\n语法：tar [-zcxvf] fileName [files]\n包文件后缀为.tar表示只是完成了打包，并没有压缩\n包文件后缀为.tar.gz表示打包的同时还进行了压缩\n说明：\n-z: z代表gzip，通过gzip命令处理文件，gzip可以对文件压缩或者解压\n-c: c代表的是create，即创建新的包文件\n-x: x代表的是extract，实现从包文件中还原文件\n-v: v代表的是verbose,显示命令的执行过程\n-f: f代表的是file ,用于指定包文件的名称\n","categories":["Linux专题"],"tags":["Linux"]},{"title":"SpringBoot学习笔记","url":"/2022/11/28/SpringBoot_learning/","content":"前言\n课程视频地址：https://www.bilibili.com/video/BV15b4y1a7yG/\nJava环境：JavaSE 1.8.0_351\n开发IDE：IntelliJ IDEA Community Edition 2022.2.3\n0.1 IDEA Community Edition设置\n0.1.1 统一设置编码为utf-8编码\n1、文件和项目编码File -&gt; Settings -&gt; Editor -&gt; File Encodings，其中的Project Encoding和Default encoding for properties files两项，后面Transparent native to ascii convension打勾。\n2、新项目文件编码：File -&gt; New Project Setup -&gt; Settings for New Projects -&gt; Editor -&gt; File Encodings，与上面相同。\n3、File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Compiler -&gt; Java Compiler，设置Additional command line parameters选项为-encoding utf-8\n4、将项目中的**.idea文件夹中的encodings.xml**文件中的编码格式改为utf-8，一般来说进行了上述第1步，这个文件中的编码格式自动改为utf-8，不需要手动修改。\n0.1.2 Maven设置\n本例中IDEA自带的Maven是3.8.1，一般网上教程要求是Maven 3即可。\n强烈建议在IDEA里安装Maven Helper插件。\n首先准备好自己的maven仓库目录，本例中是 D:\\Java\\mvn-repository\n准备好自己的一个 settings.xml，如下：\n\n&lt;settings xmlns=“http://maven.apache.org/SETTINGS/1.0.0”\n  xmlns:xsi=“http://www.w3.org/2001/XMLSchema-instance”\n  xsi:schemaLocation=“http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd”&gt;\n  \n  D:\\Java\\mvn-repository\n  \n      \n      \n          aliyunMaven\n          *\n          Aliyun Maven Mirror\n          https://maven.aliyun.com/repository/public\n      \n  \n  \n  \n      \n      \n          aliyunSpring\n          \n              \n                  spring\n                  https://maven.aliyun.com/repository/spring\n                  \n                  \n                      true\n                      \n                      \n                  \n                  \n                  \n                      \n                      \n                      \n                  \n              \n          \n      \n  \n  \n  \n  \n  \n  \n  \n      aliyunSpring\n  \n\n这个settings.xml里指定了自定义的仓库目录位置。后面定义了阿里云的spring仓库位置。\n菜单File -&gt; Settings -&gt; Build, … -&gt; Build Tools -&gt; Maven，将两个Override都勾上，在User settings file里打开自己的settings.xml，点下面的“Apply”，就行了。\n0.1.3 代码提示\n格式化代码快捷键：Ctrl + Alt + L\n不希望格式化代码时格式化注释：File -&gt; Settings -&gt; Editor -&gt; Code Style -&gt; Java，右边选择Javadoc将下面的Enable Javadoc formatting勾勾去掉。\n不要提示Dangling Javadoc comment：File -&gt; Settings -&gt; Editor -&gt; Inspections -&gt;Java -&gt; Javadoc把对应项后面的勾勾去掉。在自动生成Javadoc时不写入悬空的注释。\n不要Duplicated code提示：File -&gt; Settings -&gt; Editor -&gt; Inspections -&gt; General -&gt; Duplicated Code fragement把勾勾去掉。社区版好像没有这一项。\n不要拼写检查：File -&gt; Settings -&gt; Editor -&gt; Inspections -&gt; Proofreading勾勾去掉，就没有拼写和语法检查了。\n鼠标在类、方法、参数上悬停时出现相应说明信息：File -&gt; Settings -&gt; Editor -&gt; Code Editing右边把Show quick documentation on mouse hover打上勾。默认是有的。\n经常会警告（黄色标签）声明，或者方法没有被使用。File -&gt; Settings -&gt; Editor -&gt; Inspections -&gt; Java -&gt; Declaration redundancy -&gt; Unused declaration去掉勾。或者搜索unused就可以找到。\n0.1.4 设置Java代码文件头\n菜单File -&gt; Settings -&gt; Editor -&gt; File and Code Templates右边Includes -&gt; File Header，如下图所示输入作者信息，则新建Java Class文件时会自动加到头上。\n一、基础篇\n前置知识：\n\nJava基础语法\nSpring与SpringMVC，知道Spring是用来管理bean，能够基于Restful实现页面请求交互功能\nMybatis与MyBatis-Plus，基于MyBatis和Mybatis-Plus能够开发出包含基础CRUD功能的Dao模块\n数据库MySQL，能够读懂基础CRUD功能的SQL语句\n服务器，知道服务器与Web工程的关系，熟悉Web服务器的配置\nMaven，知道Maven的依赖关系，知道什么是依赖范围，依赖传递，排除依赖，可选依赖，继承\nWeb技术（含Vue，ElementUI），知道Vue如何发送ajax请求，如何获取响应数据，如何进行数据模型双向绑定\n\n学习目标：\n\n能够创建SpringBoot工程\n基于SpringBoot实现ssm整合\n\n1.1 快速上手SpringBoot\n在IDEA里新建一个Project，类型为Empty Project，名字为Springboot。IDEA里的Project相当于Eclipse里面的Work Space，只是一个容器或框架。后续的各个案例都将作为Module模块放在这个空的Project里面。\n1.1.1 IDEA联网版入门案例\n需要用到Spring Intilalizr，社区版里没有。之前有Spring Assistant插件可以用，现在该插件已被Spring Boot Helper取代，激活收费$15。\n略。\n1.1.2 官网创建版案例\n到Spring官网https://spring.io/，顶部的Projects里找到Spring Boot\n或者直接https://spring.io/projects/spring-boot进入，到最下面看到如下图标和链接\n点击Spring Initializr进入定制页面，或者直接https://start.spring.io/进入如下：\n1、选择Maven Project\n2、语言选择Java\n3、Spring Boot的版本为当前最新版2.7.5\n4、项目的元数据自定义，最后一项包名自动包含了项目名称，可以修改为短的\n5、右侧Dependencies选择增加Spring Web\n点击下方GENERATE按钮，会自动生成一个springboot_01_02_quickstart.zip压缩包并自动下载。解压缩后生成同名文件夹，把文件夹springboot_01_02_quickstart整个拷贝到项目文件夹（D:\\id-space\\Springboot）下。\n在IDEA菜单File -&gt; Project Structure 看看JDK设置好没有\n然后在下面Modules里面点击“+”Import Module添加一个模块，选中刚才拷贝过来的文件夹\n中间注意要选中Maven类型\n然后IDEA开始导入模块，如果是第一次，则开始下载Maven相关依赖包，插件等，需要几分钟。如“0.1.2 Maven设置”中的settings.xml中设置的是阿里云下载点，下载速度会很快。\nMaven更新完成后，pom.xml文件可能会报错“spring-boot-maven-plugin not found”，如下增加一行版本号，与Initializr里使用的Spring Boot版本号一致。如果IDEA里安装了Maven Helper，则在这个文件上右键Maven -&gt; reimport更新即可。\n在src/main/java/cn/zlz8x8下新建一个包controller，下面新建一个类BookControllerr如下。如果前面步骤都正常的话，在写上面代码时应正常出现代码补全的提示，并会自动根据代码在import载入相应的包。\npackage cn.zlz8x8.controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n//Rest模式\n@RestController\n@RequestMapping(“/books”)\npublic class BookController {\n  @GetMapping\n  public String getById() {\n      System.out.println(“springboot is running …”);\n      return “springboot is running …”;\n  }\n}\n运行Springboot0102QuickstartApplication.java，文件上右键run，或者打开这个文件，工具栏上自动会有run的图标。\n控制台会显示如上输出，最后一行springboot is running并没有。\n打开浏览器，输入http://localhost:8080/books，则会看到浏览器的输出，同时上面控制台也会输出最后一行springboot is running\n工具栏上红色方块停止按钮可以停止运行。\n1.1.3 阿里云版案例\n仍然要用到Spring Initializr，IDAE社区版没有。只是把Initailizr里的创建地址https://start.spring.io换成了https://start.aliyun.com而已。\n进入https://start.aliyun.com/bootstrap.html可以看到与Spring官网类似的在线生成器，但是Spring Boot的版本过低。但依赖包比官网多一些，比如有MyBatis-Plus\n这部分略过。\n1.1.4 手工制作版案例\n在项目Springboot下新建一个Module，Build system选择Maven，需要修改的是Name和GroupId，其他的会自动生成。点击按钮Create就可以创建一个Maven模块。\n修改pom.xml，参照“1.1.2 官网创建版案例”拷贝有用的部分，主要是，和的内容，里的内容可以保持不变。最终如下：\n如果安装了Maven Helper插件，文件上会出现一个悬浮刷新按钮，修改完点击刷新，没有报错即可。\n\n&lt;project xmlns=“http://maven.apache.org/POM/4.0.0”\n       xmlns:xsi=“http://www.w3.org/2001/XMLSchema-instance”\n       xsi:schemaLocation=“http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd”&gt;\n  4.0.0\n  \n      org.springframework.boot\n      spring-boot-starter-parent\n      2.7.5\n       \n  \n  cn.zlz8x8\n  springboot_01_04_quickstart\n  1.0-SNAPSHOT\n  \n      &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;\n      &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;\n      &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n  \n  \n      \n          org.springframework.boot\n          spring-boot-starter-web\n      \n      \n          org.springframework.boot\n          spring-boot-starter-test\n          test\n      \n  \n  \n      \n          \n              org.springframework.boot\n              spring-boot-maven-plugin\n          \n      \n  \n\n前面创建Module时，Add sample code打了勾，因此已经有一个cn.zlz8x8.Main文件，同样参照“1.1.2 官网创建版案例”修改如下：\npackage cn.zlz8x8;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n@SpringBootApplication\npublic class Main {\n  public static void main(String[] args) {\n      SpringApplication.run(Main.class, args);\n  }\n}\n同样参照“1.1.2 官网创建版案例”，新建一个包cn.zlz8x8.controller，把之前的BookController.java拷贝到这个包里，可以稍微修改一下输出，如下：\npackage cn.zlz8x8.controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n//Rest模式\n@RestController\n@RequestMapping(“/books”)\npublic class BookController {\n  @GetMapping\n  public String getById() {\n      System.out.println(“控制台: springboot is running … 4”);\n      return “页面: springboot is running … 4”;\n  }\n}\n然后运行Main，看控制台和浏览器输出（中文显示正常） … 停止。\n1.1.5 IDEA隐藏文件\n对比上面1.1.2和1.1.4会发现，手工创建的Module清爽很多。\n可以把多余的文件删除，又担心会出什么问题，那么就可以把这些文件或目录隐藏。\n菜单File -&gt; Settings -&gt; Editor -&gt; File Types，右边标签页，点“+”将需要隐藏的文件名添加进去即可。例如.mvn，.gitignore，HELP.md等，可以用通配符 * ，使用通配符时注意别把需要的文件隐藏了。\n1.1.6 入门案例解析：parent、starter\nSpring Boot的目的是用来简化Spring应用的初始搭建及开发过程。\n关键的pom.xml中可以看出，parent里定义的版本号2.7.5实际上就已经包含了几乎所有依赖包的版本号，经过测试，相互之间没有冲突。更改parent里的版本号，实际上相当于更换了了所有依赖包的版本号集合。\n后面里面根据需要引入依赖包，不用版本号。在IDEA里点击编辑器左边的小按钮可以直达相应引用处，看到依赖包定义的版本号。\n后面里面也不需要版本号，也都在parent里定义了。“1.1.2官网创建版案例”里提到：pom.xml文件可能会报错“spring-boot-maven-plugin not found”，需增加一行版本号，这种情况不常见。\nMaven会根据pom.xml定义的依赖，将相应依赖包的正确版本下载到本地Maven Repository里，因此第一次创建的时候会需要几分钟。如果后续再创建Spring Boot项目，只要主版本号没变，则不联网也可以创建成功。\n其中最重要的是下面的spring-boot-starter-web，点击左侧按钮，直达引用处，可以看到包含了spring-boot-starter、srping-boot-starter-tomcat、spring-web等包，这些也不是最终的依赖包，也是一系列依赖包的集合，向下层层扩展，形成了一个依赖包树形结构，最终用spring-boot-starter-web一行就解决了，不用自己手工罗列，也不用管版本之间的兼容和冲突。\n总结：parent定义了所有Spring Boot项目要继承的依赖包版本号，主要是进行依赖管理，达到减少依赖冲突的目的。而starter定义了当前项目使用的所有依赖包，以达到减少依赖配置工作量的目的。\n1.1.7 入门案例解析：引导类\n以“1.1.4 手工制作版案例”生成的项目为例。将cn.zlz8x8.Main改写为如下：\npackage cn.zlz8x8;\nimport cn.zlz8x8.controller.BookController;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ConfigurableApplicationContext;\n@SpringBootApplication\npublic class Main {\n  public static void main(String[] args) {\n      ConfigurableApplicationContext ctx = SpringApplication.run(Main.class, args);\n      //SpringApplicaiton.run 实际上是生成了一个Spring容器，也就是上下文Context\n      //项目里的其他 类（对象） 都是 bean 被放到了Spring容器里，如下\n      BookController beanBookController = ctx.getBean(BookController.class);\n      System.out.println(“这是一个Bean：” + beanBookController);\n      DemoUser beanDemoUser = ctx.getBean(DemoUser.class);\n      System.out.println(“这又是一个 bean：” + beanDemoUser);\n  }\n}\n为了上面代码最后两行正确执行，新建一个cn.zlz8x8.DemoUser类如下，空的，不需要执行任何功能，注意@Component不能少。\npackage cn.zlz8x8;\nimport org.springframework.stereotype.Component;\n@Component\npublic class DemoUser {\n}\n然后执行Main看输出。可知引导类SpringApplication.run生成了一个Spring容器。\n1.1.8 内嵌Tomcat\n从自己的pom.xml里spring-boot-starter-web处点左边小按钮，或者快捷键Ctrl + B，就可以打开 spring-boot-dependencies-2.7.5.pom，然后在spring-boot-starter-web同样快捷键Ctrl + B，就可以打开spring-boot-starter-web-2.7.5.pom，可以看到如下spring-boot-starter-tomcat一行，还可以继续扩展看这里面都有什么。正是有了这一行，我们的Spring Boot程序里自带了内嵌的Tomcat。\n如果不想用内嵌的Tomcat，或者想换成Jetty，则在我们自己的pom.xml里如下处理：\n改为如上内容后，右侧Maven工具栏展开，点刷新，可以看到很快就下载了jetty包。\n1.1.9 RESTful快速开发\n第一步：REST简介\nREST = Representational State Transfer\n特点：隐藏接口的访问行为，无法通过地址得知对接口的操作；书写简化\n根据REST风格对接口（资源）进行访问称为RESTful\n传统风格访问接口描述形式：\nhttp://localhost/user/getById?=1\nhttp://localhost/user/saveUser\nREST风格接口描述形式：\n\n\n\nhttp://localhost/users\n查询全部用户信息\nGET（查询）\n\n\n\n\nhttp://localhost/users/1\n查询全部指定信息\nGET（查询）\n\n\nhttp://localhost/users\n添加用户信息\nPOST（新增/保存）\n\n\nhttp://localhost/users\n修改用户信息\nPUT（修改/更新）\n\n\nhttp://localhost/users/1\n删除用户信息\nDELETE（删除）\n\n\n\n用postman可以看到对接口有多种动作，Spring Boot支持的包括上述等8种。\n到https://www.postman.com/注册一个免费用户，激活注册用的邮箱。就可以开始使用postman了。使用方式主要有三种：（1）在postman官网在线使用；（2）利用Chrome的插件在线使用；（3）下载postman的桌面程序在线使用。这三种方式都要求在线使用。本例下载了postman的Windows桌面程序，安装之后登录、在线使用。\n第二步：RESTful入门案例\n首先，采用复制的方式新建一个Module，如“1.2.1 模块Module复制”，名称为Springboot_01_06_rest，在其中新建一个类cn.zlz8x8.controller.UserController如下。\n可以看出一个API主要有两部分：\n@RequestMapping 首先指定API调用的路径，跟着是参数的调用形式。然后是调用的动作，POST、PUT、DELETE等。调用路径 /users/{userName} 对应的真实调用路径为http://localhost:8080/users/Tom，因为使用的内置Tomcat，默认端口是8080，对应的参数就是Tom。\n@ResponseBogy 里面的方法就是获得API传参后如何处理，下面都只做了简单输出，实际项目则可以进行希望的操作。里面的@PathVariable指明参数取自路径后面的哪部分。\npackage cn.zlz8x8.controller;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\n@Controller\npublic class UserController {\n  @RequestMapping(value = “/users/{userName}”, method = RequestMethod.POST)\n  @ResponseBody\n  public String save(@PathVariable String userName){\n      System.out.println(“user save …” + userName);\n      return “{‘module’: ‘user save’}”;\n  }\n  @RequestMapping(value = “/users/{id}”, method = RequestMethod.DELETE)\n  @ResponseBody\n  public String delete(@PathVariable Integer id){\n      System.out.println(“user delete …” + id);\n      return “{‘module’: ‘user delete’}”;\n  }\n  @RequestMapping(value = “/users/{userName}”, method = RequestMethod.PUT)\n  @ResponseBody\n  public String update(@PathVariable String userName){\n      System.out.println(“user update …” + userName);\n      return “{‘module’: ‘user update’}”;\n  }\n  @RequestMapping(value = “/users/{id}”, method = RequestMethod.GET)\n  @ResponseBody\n  public String getById(@PathVariable Integer id){\n      System.out.println(“user getById …” + id);\n      return “{‘module’: ‘user getById’}”;\n  }\n  @RequestMapping(value = “/users”, method = RequestMethod.GET)\n  @ResponseBody\n  public String getAll(){\n      System.out.println(“user getAll …”);\n      return “{‘module’: ‘user getAll’}”;\n  }\n}\n将这个模块运行起来。打开postman，可以发送不同的请求看结果以及IDEA控制台的输出。可以将若干个请求保存到一个collection里面，今后不需要重复输入，直接可以测试。本例中将对应上面5个API的请求保存到了一个名为Springboot_01_06_rest的集合里。\n注意：\n\n后期开发中，参数超过1个，以json格式为主，@RequestBody应用较广，用于接收json数据。\n如果发送非json格式参数，选用@RequestParam接收参数，用于url地址传参或表单传参。\n采用RESTful进行开发，如果参数较少，可以采用@PathVariable接收路径参数。\n\n第三步：简化开发\n复制生成的Springboot_01_06_rest里有一个cn.8x8.controller.BookController几乎是空的，将其改写如下，与上面的UserController进行对比。API的功能和调用方式完全一样，但是代码简洁了许多。\n1、原来类名上有个@Controller，方法名上有个@ResponseBody，将所有方法名上的@ResponseBody合并提升到类名上。然后再将@Controller和@ResponseBody合并成了@RestController\n2、原来方法名上相同的@RequestMapping(value = “/books” 合并提升到了类名上。剩下的方法动作 method = … 简化成了对应的@PostMapping、@DeleteMapping、@PutMapping和@GetMapping，里面的参数简化了相同路径部分（合并到了类名上面）。\npackage cn.zlz8x8.controller;\nimport org.springframework.web.bind.annotation.*;\n@RestController\n@RequestMapping(“/books”)\npublic class BookController {\n  @PostMapping(“/{userName}”)\n  public String save(@PathVariable String userName){\n      System.out.println(“book save …” + userName);\n      return “{‘module’: ‘book save’}”;\n  }\n  @DeleteMapping(“/{id}”)\n  public String delete(@PathVariable Integer id){\n      System.out.println(“book delete …” + id);\n      return “{‘module’: ‘book delete’}”;\n  }\n  @PutMapping(“/{userName}”)\n  public String update(@PathVariable String userName){\n      System.out.println(“book update …” + userName);\n      return “{‘module’: ‘book update’}”;\n  }\n  @GetMapping(“/{id}”)\n  public String getById(@PathVariable Integer id){\n      System.out.println(“book getById …” + id);\n      return “{‘module’: ‘book getById’}”;\n  }\n  @GetMapping\n  public String getAll(){\n      System.out.println(“book getAll …”);\n      return “{‘module’: ‘book getAll’}”;\n  }\n}\n在postman里测试，在原来的测试集下建两个目录，对应Users和Books，然后将不同的请求保存到对应的目录里，方便今后测试，不用重复输入。\n1.2 SpringBoot基础配置\n1.2.1 模块Module复制\n第一步：选定要复制的Module并简化\n“1.1.2 官网创建版”里创建的springboot_01_02_quickstart是用官网Initializr创建的，把它作为要复制的目标。首先进行简化。\n将pom.xml修改简化如下。主要修改的内容：\n1、删除了和，这样在IDEA显示的时候找不到就以显示。今后导入Module的时候只需要修改就行了。\n2、保留了里面的spring-boot-starter-test，以后用得着。\n3、插件里面删除了版本号。本来就是不需要，在starter里已定义了。\n\n&lt;project xmlns=“http://maven.apache.org/POM/4.0.0” xmlns:xsi=“http://www.w3.org/2001/XMLSchema-instance”\n\txsi:schemaLocation=“http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd”&gt;\n\t4.0.0\n\t\n\t\torg.springframework.boot\n\t\tspring-boot-starter-parent\n\t\t2.7.5\n\t\n\tcn.zlz8x8\n\tspringboot_01_02_quickstart\n\t0.0.1-SNAPSHOT\n\t\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t\n\t\n\t\t\n\t\t\torg.springframework.boot\n\t\t\tspring-boot-starter-web\n\t\t\n\t\t\n\t\t\torg.springframework.boot\n\t\t\tspring-boot-starter-test\n\t\t\ttest\n\t\t\n\t\n\t\n\t\t\n\t\t\t\n\t\t\t\torg.springframework.boot\n\t\t\t\tspring-boot-maven-plugin\n\t\t\t\n\t\t\n\t\n\nspringboot_01_02_quickstart里面的代码文件cn.zlz8x8.Springboot0102QuickstartApplication.java和cn.zlz8x8.controller.BookController只有几行基础代码，不需要修改。非常长的名字可以在复制之后修改。\n至此，要复制的Module就准备好了，这个Module以后就不动了，专门用来复制成新的模块。当然，每次从官网创建也可以。\n第二步：复制\n到IDEA工作空间的Springboot项目下，本例是D:\\id-space\\Springboot\n复制文件夹springboot_01_02_quickstart到同一个目录，形成副本，然后将文件夹名称改为新的模块名称，springboot_01_06_rest，进入这个文件夹。\n删除目录下的子目录.mvn，删除子目录target，删除除pom.xml之外的其他文件，最后只剩文件夹src和文件pom.xml，如下：\n用其他文本编辑器，如VSCode等打开pom.xml，修改里面的值为springboot_01_06_rest，与模块名一致。\n第三步，IDEA导入\nIDEA菜单File -&gt; Project Structure，在下面Modules里面点击“+”Import Module添加一个模块，选中刚才复制生成的springboot_01_06_rest文件夹，弹出对话框注意要选中Maven类型。然后就完事了，导入顺利，没有报错。\n此时主文件还是cn.zlz8x8.Springboot0102QuickstartApplication.java，在此文件上右键Refactor -&gt; rename …，将名称改为Springboot0106RestApplication，就自动将文件里的类名等都相应更改了，如果项目里其他地方有引用，也一并改了。今后改类名、方法名、变量名都用Refactor，不要手工改。运行此文件，看效果。\n模块复制完成。今后只用从第二步开始。\n1.2.2 属性配置方式\n默认内置的Tomcat端口是8080，比较麻烦。修改resources目录下的application.properties文件，打开看到是空的，添加server.port=80如下设置，启动项目，日志看到端口已变更为80，然后到postman修改调用url把8080端口号去掉，测试。\nIDEA社区版修改application.properties没有高亮颜色、代码提示和补全，几个插件用了也没效果，关系不大。以后用yml配置，就有提示和代码补全了。需要安装插件Spring Boot Assistant，这跟之前的插件Spring Assistant不一样（这个插件现在已经没有了，改成了收费插件）。不同IDEA版本现象不一样，网上搜解决方法。\n1.2.3 基础配置\n上面的application.properties文件再加一行 spring.main.banner-mode=off\n启动程序，发现控制台的Spring的字符画就没有了。也可以进行一些其他设置。\n设置项非常多。到官网 https://spring.io/projects/spring-boot#learn 下面的Documentation，找到与正在用的版本最接近的版本，点右侧的Reference Doc\n下一个页面找到下面附件中 Application Properties点进去就可以看到所有配置参数、解释、默认值等。\n1.2.4 配置文件类型\napplication.properties\nserver.port=80\napplication.yml\nserver:\n  port: 80\napplication.yaml\nserver:\n  port: 80\nSpring Boot配置文件的加载有先后顺序：yaml，yml，properties，后加载的会把先加载的覆盖。因此使用yml时，要先把properties移走。\n上一小节中的resources目录下新建一个目录bak，把application.properties文件移进去，然后再新建一个application.yml文件。按前面格式设定端口，编辑时有代码提示和补全，运行，发现有效。\n同样把yml移到bak目录，新建一个application.yaml，内容如上。测试。\n今后的开发中，主要用yml格式进行配置。\n1.2.5 yaml数据格式\nYaml优点：容易阅读，容易与脚本语言交互，以数据为中心，重数据轻格式。\n扩展名：yml 或 yaml\nYaml语法规则：\n\n大小写敏感\n属性层级关系用多行，属性名（key）和属性值（value）之间用“冒号+空格”\n使用缩进表示层级关系，同层级左侧对齐，缩进只能用空格不能用Tab\n注释用#\n\n对象与数组的格式与json类似，不赘述。下一小节有示例。\n1.2.6 读取yml数据\n下面的综合实例展示了：\n\n读取单一属性数据\n读取二级属性数据\n读取数组元素数据\n读取数组元素二级数据\n读取引用数据\n用env读取全部属性数据\n使用类封装yml数据\n\n步骤一：准备application.yml文件\nserver:\n  port: 80\nspring:\n  main:\n  banner-mode: off\n# 以下是自定义属性\ncountry: China\nprovince: 湖北\ncity: Wuhan\nuser1:\n  name: cat\n  age: 29\n  married: true\nuser2:\n  name: dog\n  age: 20\n# 数组，其中有数据引用，与顺序无关\nhobbies:\n  - video ${habbits[0]}\n  - basketball\n  - swiming\n# 数组简单形式，双引号内可解析转义字符\nhabbits: [game, “mu\\t\\nsic”, sleep]\n# 对象数组\nusers1:\n  - name: Alton John\n  age: 65\n  birthday: 1949-10-01\n  - name: Poppy Alex\n  age: 19\n# 对象数组简单形式\nusers2: [{name: Tylor Swift, age: 24, birthday: 2000-11-11}, {name: 李小龙, age: 46}]\n步骤二：准备User1.java封装yml结构化数据\n首先定义类的变量，然后可以用IDEA自动生成get，set，toString方法的代码。\npackage cn.zlz8x8.controller;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\n/* 定义User1类封装yml文件中对应的结构化数据\n * 定义User1类为Spring管理的bean，头上加@Component\n * 指定加载的数据，@ConfigureationProperties\n */\n@Component\n@ConfigurationProperties(prefix = “user1”)\npublic class User1 {\n  private String name;\n  private int age;\n  private Boolean married;\n  @Override\n  public String toString() {\n      return “User1{” +\n              “name='” + name + ‘'’ +\n              “, age=” + age +\n              “, married=” + married +\n              ‘}’;\n  }\n  public String getName() {\n      return name;\n  }\n  public void setName(String name) {\n      this.name = name;\n  }\n  public int getAge() {\n      return age;\n  }\n  public void setAge(int age) {\n      this.age = age;\n  }\n  public Boolean getMarried() {\n      return married;\n  }\n  public void setMarried(Boolean married) {\n      this.married = married;\n  }\n}\n步骤三：改写BookController.java\npackage cn.zlz8x8.controller;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.core.env.Environment;\nimport org.springframework.web.bind.annotation.*;\n@RestController\n@RequestMapping(“/books”)\npublic class BookController {\n  //读取yml数据\n  @Value(“${province}”)\n  private String country; // 上面定义的属性名不需要与变量名一致，数据为中文“湖北”\n  @Value(“${user1.age}”)\n  private int age;\n  @Value(“${habbits[1]}”)\n  private String hab1;\n  @Value(“${users1[0].birthday}”)\n  private String user1birth;\n  @Value(“${hobbies[0]}”)\n  private String hob1;\n  //使用自动装配，将所有yml里的数据读取到env中\n  //注意有多个Environment类，选择 org.springframework.core.env\n  @Autowired\n  private Environment env;\n  // 使用类封装yml数据，使用自动装配@Autowired\n  @Autowired\n  private User1 myUser1;\n  @GetMapping\n  public String getAll(){\n      System.out.println(“book getAll …”);\n      System.out.println(&quot;从yml文件中读取的单一属性数据：country ====&gt; &quot; + this.country);\n      System.out.println(&quot;从yml文件中读取的二级属性数据：user1.age ====&gt; &quot; + this.age);\n      System.out.println(&quot;从yml文件中读取的数组元素数据：habbits[1] ====&gt; &quot; + this.hab1);\n      System.out.println(&quot;从yml文件中读取的数组元素二级数据：users1[0].birthday ====&gt; &quot; + this.user1birth);\n      System.out.println(&quot;从yml文件中读取的引用数据：hobbies[0] ====&gt; &quot; + this.hob1);\n      System.out.println(&quot;用env读取全部数据并取出users2[1].name ====&gt; &quot; + env.getProperty(“users2[1].name”));\n      System.out.println(&quot;使用类封装的yml数据：User1 ====&gt; &quot; + myUser1.toString());\n      return “{‘module’: ‘book getAll’}”;\n  }\n  @PostMapping(“/{userName}”)\n  public String save(@PathVariable String userName){\n      System.out.println(“book save …” + userName);\n      return “{‘module’: ‘book save’}”;\n  }\n  @DeleteMapping(“/{id}”)\n  public String delete(@PathVariable Integer id){\n      System.out.println(“book delete …” + id);\n      return “{‘module’: ‘book delete’}”;\n  }\n  @PutMapping(“/{userName}”)\n  public String update(@PathVariable String userName){\n      System.out.println(“book update …” + userName);\n      return “{‘module’: ‘book update’}”;\n  }\n  @GetMapping(“/{id}”)\n  public String getById(@PathVariable Integer id){\n      System.out.println(“book getById …” + id);\n      return “{‘module’: ‘book getById’}”;\n  }\n}\n然后运行，看控制台输出。\n1.3 基于SpringBoot实现SSM整合\n1.3.1 官网创建新模块\n本小节内容可选。\n从官网创建新模块的目的是为后面的内容生成一个干净的基准模块。\n如下图所示，Spring Boot版本已经升到了2.7.6，另外除了基本Spring Web的依赖包，还选择了Spring Boot Dev Tools包和Spring Configuration Processor包。\n选择后两个包的目的是想试一下Dev Tools好不好用，另外application.properties会不会出现代码提示和补全。结果不理想。又从pom里把这两个包删除了。\n不过从这里可以看出，生成模块时选择依赖包是没关系的，今后可以很方便地在pom增加或删除依赖包。\n生成的springboot_base_quickstart模块导入IDEA，然后小修改一下：\n\n在pom里删除项目的name和description，这样IDEA就只认artifactId了\n在pom里删除不需要的包，只留下最基本的starter-web和starter-test\n把application.properties改名（用refactor -&gt; rename）为application.yml，这样配置文件里的代码提示和补全就有了。\n\n模块里除了main和test里各有一个类，其他类都没有，很干净。\n新模块导入IDEA后，Maven开始下载依赖包，大概几分钟。然后把之前的模块在pom里把parent的版本号改为2.7.6，很快就行了，因为2.7.6的依赖包已经下载。并且之前的2.7.5的包就都没有了。如果项目里各模块的Spring Boot主版本不一样，那么各个版本对应的依赖包都会下载到Maven本地库里。\n1.3.2 整合Junit\n首先复制一个模块备用。\n在IDEA工作目录把上一节中的springboot_base_quickstart目录复制到同一个目录，改名为springboot_04_junit，然后进入该目录，除了src文件夹和pom.xml，其他都删除。然后修改pom.xml的artifactId为springboot_04_junit，在IDEA导入该模块。\n用Refactor -&gt; rename改名SpringbootBaseQuickstartApplication.java为Springboot04JunitApplication.java，弹出对话框询问是否更改对应的test主类，把test主类勾上，然后点确定按钮，这样两个主类的名称都改了。\n通过改名发现Junit其实已经集成到Spring Boot里了，用就行了。\n第一步：新建要测试的对象和方法\n新建cn.zlz8x8.dao.BookDao.java，对话框里选interface而不是class，然后手写一个方法save，并不执行任何操作。生成的文件如下：\npackage cn.zlz8x8.dao;\npublic interface BookDao {\n  public void save();\n}\n新建cn.zlz8x8.dao.impl.BookDaoImpl.java，这次是选class，然后实现上面接口的方法，在控制台打印一句话。注意类头上加@Repository，表明这是一个受Spring管理的bean，生成的文件如下：\npackage cn.zlz8x8.dao.impl;\nimport cn.zlz8x8.dao.BookDao;\nimport org.springframework.stereotype.Repository;\n@Repository\npublic class BookDaoImpl implements BookDao {\n  @Override\n  public void save() {\n      System.out.println(“Message from BookDaoImpl …”);\n  }\n}\n第二步，改写test主类\n改写test主类Springboot04JunitApplicationTests.java，如下。注意导入要测试对象时，头上加@Autowired表示自动装配。注意主类头上的@SpringBootTest，表明这是一个Spring Boot的测试类。注意import的包，就包括了org.junit\npackage cn.zlz8x8;\nimport cn.zlz8x8.dao.BookDao;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n@SpringBootTest\nclass Springboot04JunitApplicationTests {\n\t// 1.注入要测试的对象\n\t@Autowired\n\tprivate BookDao bookDao;\n\t@Test\n\tvoid contextLoads() {\n\t\t// 2.执行要测试的对象的方法\n\t\tbookDao.save();\n\t}\n}\n类名、方法contextLoads()旁边都有运行按钮，随便哪一个。运行后控制台显示相应的消息，并且会显示Tests passed 测试通过。与之前运行Spring Boot主类不同，不需要停止或重启，测试运行后自动就停止了。\n第三步，关于classes属性\n将测试主类Springboot04JunitApplicationTests.java拷贝到cn包下，在原主类（位于cn.zlz8x8下）上右键Refactor -&gt; copy class … 弹出对话框中将包修改为cn\n运行新拷贝的测试类，发现报错。修改代码如下，就OK了。\n报错的原因是测试类在test下的同级包中找哪个类头上有@SpringBootApplication，显然原来的测试类在cn.zlz8x8下，与main下的主类Springboot04JunitApplication在同级包下，可以找到。拷贝后的测试类提升了一级就找不到了，则需要如下指定。指定的方法有两种，如下注释，第二种方法两行@与第一种方法效果一样。\npackage cn;\nimport cn.zlz8x8.Springboot04JunitApplication;\nimport cn.zlz8x8.dao.BookDao;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n@SpringBootTest(classes = Springboot04JunitApplication.class)\n// @SpringBootTest\n// @ContextConfiguration(classes = Springboot04JunitApplication.class)\nclass Springboot04JunitApplicationTests {\n\t// 1.注入要测试的对象\n\t@Autowired\n\tprivate BookDao bookDao;\n\t@Test\n\tvoid contextLoads() {\n\t\t// 2.执行要测试的对象的方法\n\t\tbookDao.save();\n\t}\n}\n1.3.3 整合MyBatis\n本节内容涉及MySQL数据库，先按顺序看完并实现“附录一、Vmware安装CentOS7”和“附录二、CentOS7安装MySQL”就有了一个MySQL数据库服务器。\n数据库类型：MySQL 8.0\n数据库连接：mysql://192.168.138.21:3306/ssm_db\n用户名：ssmaster\n密码：1gE=M!ka\n数据表：tbl_book，字段id（主键，自增，不需要值），type（字符串），name（字符串），description（字符串）。已经有2条数据。\n第一步：复制导入新模块\n从“1.3.1官网创建新模块”springboot_base_quickstart复制出一个新模块springboot_05_mybatis，只保留src文件夹和pom.xml，并将pom.xml中artifactId修改为springboot_05_mybatis，在IDEA中导入。Refactor修改主类方法名为Springboot05MybatisApplication，并勾选自动修改测试主类方法名。\n第二步：引入相关依赖包\n修改pom.xml如下，增加了mybatis和mysql driver依赖。刷新一下Maven，就会自动分析并下载相应的依赖包。注意mybatis版本号与视频课里不一样。\n\n&lt;project xmlns=“http://maven.apache.org/POM/4.0.0” xmlns:xsi=“http://www.w3.org/2001/XMLSchema-instance”\n\txsi:schemaLocation=“http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd”&gt;\n\t4.0.0\n\t\n\t\torg.springframework.boot\n\t\tspring-boot-starter-parent\n\t\t2.7.6\n\t\t \n\t\n\tcn.zlz8x8\n\tspringboot_05_mybatis\n\t0.0.1-SNAPSHOT\n\t\n\t\t&lt;java.version&gt;1.8&lt;/java.version&gt;\n\t\n\t\n\t\t\n\t\t\torg.mybatis.spring.boot\n\t\t\tmybatis-spring-boot-starter\n\t\t\t2.2.2\n\t\t\n\t\t\n\t\t\tmysql\n\t\t\tmysql-connector-java\n\t\t\truntime\n\t\t\n\t\t\n\t\t\torg.springframework.boot\n\t\t\tspring-boot-starter-web\n\t\t\n\t\t\n\t\t\torg.springframework.boot\n\t\t\tspring-boot-starter-test\n\t\t\ttest\n\t\t\n\t\n\t\n\t\t\n\t\t\t\n\t\t\t\torg.springframework.boot\n\t\t\t\tspring-boot-maven-plugin\n\t\t\t\n\t\t\n\t\n\n自己手工怎么知道如何写mybatis和mysql的依赖？\n（1）IDEA正式版中用Spring Initializr生成模块的时候，勾选上mybatis和mysql driver依赖，生成的pom.xml里就有了。\n（2）使用官网Initializr生成模块，也勾选上mybatis和mysql driver\n手工写的时候，可以参考上面两种方式生成的pom.xml\n第三步：配置相关信息\n修改application.yml如下，可以看到，多了spring.datasource一段。其中driver-class-name的值与视频课里讲的不一样，mysql-connector 8开始就用如下这样的驱动了。\nserver:\n  port: 80\nspring:\n  datasource:\n  driver-class-name: com.mysql.cj.jdbc.Driver\n  url: jdbc:mysql://192.168.138.21:3306/ssm_db\n  username: ssmaster\n  password: 1gE=M!ka\n第四步：编写测试代码\n（1）新建一个实体类cn.zlz8x8.domain.Book，只需要定义出与数据库tbl_book表中字段对应的四个属性就可以，后面的toString和setter，getter代码都可以自动生成。\npackage cn.zlz8x8.domain;\npublic class Book {\n  private Integer id;\n  private String type;\n  private String name;\n  private String description;\n  @Override\n  public String toString() {\n      return “Book{” +\n              “id=” + id +\n              “, type='” + type + ‘'’ +\n              “, name='” + name + ‘'’ +\n              “, description='” + description + ‘'’ +\n              ‘}’;\n  }\n  public Integer getId() {\n      return id;\n  }\n  public void setId(Integer id) {\n      this.id = id;\n  }\n  public String getType() {\n      return type;\n  }\n  public void setType(String type) {\n      this.type = type;\n  }\n  public String getName() {\n      return name;\n  }\n  public void setName(String name) {\n      this.name = name;\n  }\n  public String getDescription() {\n      return description;\n  }\n  public void setDescription(String description) {\n      this.description = description;\n  }\n}\n（2）新建一个接口类cn.zlz8x8.dao.BookDao，注意接口类头上的@Mapper和方法名上的@Select，方法并没有方法体，通过@Select里面的SQL查询语句实现了。\npackage cn.zlz8x8.dao;\nimport cn.zlz8x8.domain.Book;\nimport org.apache.ibatis.annotations.Mapper;\nimport org.apache.ibatis.annotations.Select;\n@Mapper\npublic interface BookDao {\n  @Select(“select * from tbl_book where id = #{id}”)\n  Book getById(Integer id);\n}\n（3）改写测试类，运行测试\npackage cn.zlz8x8;\nimport cn.zlz8x8.dao.BookDao;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\n@SpringBootTest\nclass Springboot05MybatisApplicationTests {\n\t@Autowired\n\tprivate BookDao bookDao;\n\t@Test\n\tvoid contextLoads() {\n\t\tSystem.out.println(bookDao.getById(2));\n\t}\n}\n代码编辑器左边点击运行按钮，运行这个测试类。看结果\n到此整合MyBatis的实例完成。回过头看，没有用到spring-boot-starter-web依赖，也没有用到application.yml里的server.port=80的配置，这两项都可以删掉，留着也行。\n1.3.4 整合MyBatis常见问题\n主要讲的是在设置数据源时\ncom.mysql.jdbc.Driver 是MySQL connector 5 的写法\ncom.mysql.cj.jdbc.Driver 是MySQL connector 8的写法，本例中就是这样写的\n第二个问题，是使用了8的驱动，会出现没有设置时区的报错，解决方法是在url里加上时区设置：\nurl: jdbc:mysql://192.168.138.21:3306/ssm_db?serverTimezone=UTC\nurl: jdbc:mysql://192.168.138.21:3306/ssm_db?serverTimezone=Asia/Shanghai\n本例中没有设置时区，并没有报错。\n1.3.5 整合MyBatisPlus\nMyBatis-Plus与MyBatis的区别：导入依赖不同，数据层实现简化\nSpring官方并没有把MyBatis-Plus纳入其主要可选依赖，在定义pom依赖的时候，可以从阿里云Initializr里导入MyBatis-Plus依赖，然后看其pom里是怎么写的。\n另外：**https://mvnrepository.com/ 是Maven库的大本营，可以去查！！！\n二、实用篇\n前置知识：\n\nLinux（CentOS 7），熟悉常用Linux基础命令，熟悉Linux系统目录结构\n使用开发技术：缓存：redis、MongoDB；消息中间件：RocketMQ、RabbitMQ\n\n2.1 运维实用篇\n学习目标：\n\n能够掌握SpringBoot程序多环境开发\n能够基于Linux系统发布SpringBoot工程\n能够解决线上灵活配置SpringBoot工程的需求\n\n2.2 开发实用篇\n学习目标：\n\n能够基于SpringBoot整合任意第三方技术\n\n三、原理篇\n前置知识：\n\n了解Spring加载bean的各种方式\n知道Spring容器底层工作原理，能够阅读简单的Spring底层源码\n\n学习目标：\n\n掌握SpringBoot内部工作流程\n理解SpringBoot整合第三方技术的原理\n实现自定义开发整合第三方技术的组件\n\n附录一、Vmware安装CentOS 7\n本例中采用虚拟化软件VMware Workstation安装CentOS 7-2009（最小安装minimal）。实际应用中，单个服务器一般都设定为单一功能，比如Web服务器，数据库服务器，LDAP服务器等，或者多台服务器分布式部署云计算组件如Hadoop等，单个服务器只需要操作系统的基本功能，因此CentOS最小化安装符合需求，如果需要额外的功能，可以在使用过程中增加。云服务提供商（例如阿里云）提供的云服务器操作系统一般是CentOS minimal。\n本例CentOS安装环境如下：\n主机（Host Machine）：CPU 20核，内存32G，操作系统Windows 11家庭版64位\n虚拟化软件：VMware Workstation 16 pro\n到 https://www.centos.org/ 下载安装包，本例是CentOS-7-x86_64-DVD-2009.iso\n1.1 安装前Vmware设置\n1、在VMware菜单“编辑-首选项”可以设置虚拟机默认放置的目录，应选择有足够空间的硬盘分区。本例中是 D:\\MyVM\n2、创建虚拟机采用“自定义(高级)”配置，选择安装来源时，载入CentOS的ISO后，VMware会自动识别出操作系统类型和版本。选择“稍后安装操作系统”不采用简易安装，而采用手动安装。后面“客户机操作系统”选择Linux，下拉框选择CentOS 7 64位。\n3、虚拟机名称 CentOS7-min，选择 D:\\MyVM\\CentOS7-min作为存储位置\n4、为虚机分配处理器1个，内核数量1个，2G内存。本例中这个虚拟机实例是作为干净基准系统，具体的应用虚拟机可以克隆这个虚拟机，不用重新安装。分配的CPU核数，内存数在克隆后可以在Vmware里修改。实验用虚机一般1核2G内存即可，可租用的轻量级云服务器一般是1核1G内存。实际应用虚机则根据需要分配资源，计算单元则对CPU要求较高，内容服务器则对内存要求较高。\n5、使用NAT网络（默认选项），虚机没有与主机同级的IP地址。\n桥接，NAT，仅主机模式，三者的简要区别如下：\n（1）桥接：虚机与主机在网络中地位一样，虚机拥有与主机同级的独立IP地址。\n（2）NAT：虚机共享主机的IP地址访问Internet，同一个主机中的各个虚机在同一网段中，可互相访问。外部无法直接访问虚机，但可通过主机的转接访问虚机。\n（3）仅主机模式：同一主机中的各个虚机可互相访问，虚机无法访问Internet，外部也无法访问虚机。\n6、I/O类型：默认LSI Logic，磁盘类型：默认SCSI，选择磁盘：创建新虚拟磁盘。\n7、分配20G虚拟磁盘空间，存为多个文件（默认选项）。没有勾选“立即分配所有磁盘空间”，会稍微影响虚机的速度。\n8、指定虚机磁盘文件，保持默认（拆分成多个文件）。方便虚拟机的拷贝。\n9、开始安装时，可能会提示要更改BIOS设置以支持64位操作系统之类的，按照提示修改主机BIOS设置，再回来安装。\n注意：一般新的电脑无需设置自动支持64位虚拟化，有些电脑需要在BIOS里设置以支持64位虚拟化，有些更旧的电脑完全不支持64位虚拟化，则无法在VMware里安装64位的操作系统。\n如上完成新建虚拟机设置。会出现该虚拟机配置画面，点击“编辑虚拟机设置”，打开对话框，核对硬件配置。如果CD/DVD是自动检测，则选择“使用ISO印象文件”，并选中CentOS的安装镜像文件。\n然后点击上图中的“开启此虚拟机”，开始安装。\n开始安装后，窗口下面会出现“我已完成安装”，不要点，等安装完了再点。\n1.2 安装过程\n注意：安装过程中，鼠标点击虚机界面即可进入虚机操作，组合键ctrl + alt 可使鼠标返回主机。在VMware Workstation窗口的左下角会有提示。\n1、安装过程与在真实裸机上安装一样，初始界面按键“i”选择“Install CentOS”，然后回车进入安装过程。\n2、选择安装过程中的语言：保持默认 English - Englisth (United States)\n3、如下图所示，设置安装选项：\nDate &amp; Time 选到 Asia / Shanghai\nLanguage Support 可以把中文，简体中文(中国)选上\nSoftware Selection 保持Minimal Install不变\nInstallation Destination 需要点开，默认是自动配置磁盘，不需要修改，直接点“Done”按钮返回即可，黄色的感叹号才会消失，此界面右下角“Begin Installation”按钮才会亮起。\nNetwork &amp; Hostname 点进去，如果有显示有线网络ens33之类的，打开ON\nKDUMP可以设置为Disabled，保持默认也可以。\n设置完成后，点击右下角“Begin Installation”按钮开始安装。\n4、安装的过程中给root用户设置密码（4geT%not），如果密码太弱，需点击两次确定才能完成操作。\n新建一个用户admin（密码d00r%Key），勾选“Make this user administrator”，今后的系统管理员用户。如果密码太弱，需点击两次确定才能完成操作。\n安装完成，点击“Reboot”重新启动。\n5、系统是最小化安装，没有GUI，以root登录，安装完成。\n关闭虚拟机后，可以编辑虚拟机设置。把CD/DVD 改回为自动检测。\n关闭虚机后，可以编辑虚机设置，修改CPU核数，硬盘大小，内存等。\n小技巧：虚机屏幕有时候不匹配VMware的窗口，需要拉动窗口的滚动条才能看见全部的虚机屏幕内容。或者，虚机屏幕太小，Vmware经常自动改变窗口大小去适应虚机。从VMware菜单“编辑 - 首选项 - 显示”，把“自动适应窗口”前的勾去掉（自动适应下面的两个选项都不勾）。然后再开启此虚机，可解决这个问题。\n1.3 忘记root密码\n下面是CentOS 7的root密码修改，一般情况可略过。\n开机按ESC\n选择CentOS Linux (3.10.0-693…)  按 e键\n光标移动到 linux 16开头的行，找到 ro改为 rw init=sysroot/bin/sh\n按 Ctrl+x执行\n进入后输 chroot /sysroot\n输入 passwd\n根据提示输入2次新密码\n完成后输入  touch /.autorelabel  更新系统信息\nexit\nreboot重启\n重启过程慢，耐心等等\n重启后用新密码登录\n1.4 安装后设置\n1.4.1 关于用户\n目前系统里有2个用户，root是超级管理员；admin是系统管理员。\n系统提示符为 # 表明用户为root，提示符为$ 表明用户为其他用户。\n每个用户都有自己的主目录，以 ~表示，root用户是 /root，其他用户是 /home/用户名。例如admin输入命令 cd ~ 则会进入其主目录 /home/admin\nadmin需要执行root权限的命令时，可以用 sudo 临时获得权限，也可以用 su 切换身份为root。\n使用sudo时，需要输入admin用户自己的密码，使用 su时，需要输入root用户的密码，使用“sudo su”则可以使用admin自己的密码切换到root用户身份，在root用户没有设置密码时，这个方法很好用。\n1、使用sudo不需要输入密码\n$ sudo visudo -f /etc/sudoers\n文件编辑的方式与vi一样，进入界面后，按i进入编辑（insert）模式，左下角会有INSERT提示。移动光标修改内容。修改完毕后按ESC进入命令模式，输入 :w 回车，就保存，再输入 :q 回车就退出。或者输入 :wq 一次性保存退出。\n如下修改内容，在 %wheel ALL=(ALL) ALL 前加注释符#，去掉 %wheel ALL=(ALL) NOPASSWD:ALL 前的注释符。保存退出就行了。用户admin 命令exit退出，然后再登录，就发现已经生效，使用sudo不需要输入密码了。\n这是针对wheel这个组的设置，这个组的成员都不需要输入密码就可以使用sudo，admin是wheel组的成员。\n传统修改方法是在 root ALL=(ALL) ALL 下面增加一行 admin ALL=(ALL) NOPASSWD:ALL 但在这里会被后面的 %wheel ALL=(ALL) ALL 覆盖掉。原因是在安装过程中，创建 admin用户时使其成为管理员，便成为了 wheel组的成员。系统只允许wheel组的用户来执行“su”命令登录为root用户，而让其他组的用户即使执行“su”、输入了正确的root密码，也无法登录为root用户。\n用visudo编辑sudoers文件是正确的做法。有些做法是增加文件sudoers的写权限，用vi修改，再去掉其写权限。可能会出现文件权限错乱，如下恢复sudoers文件的正确属性：\n$ sudo chmod 0440 /etc/sudoers\n1.4.2 配置静态IP地址\n第一步：在Vmware里确认网络配置\n菜单“编辑”-“虚拟网络编辑器”，这个界面，有很多网络文章说要修改，其实不用。选中列表里的Vmnet8（NAT模式），只需要看一下子网IP 192.168.138.0 及 子网掩码 255.255.255.0 记住就行了。“使用本地DHCP服务将IP地址分配给虚拟机”前面的勾不用去掉。\n然后确认一下虚拟机的网络适配器是否是NAT，安装的时候默认就是这项。如果不是，就在虚拟机关机状态下，编辑虚拟机设置，改为NAT。\n在Vmware里只需要确认上述配置就行了，不用做任何修改！\n第二步：在虚拟机设置静态IP\n以root用户登录虚拟机，下面的命令都不带sudo了。\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n因为是虚拟机，所以配置脚本文件是ens33这样的，如果是在物理机上的CentOS，则会是eth0这样的，可以先到目录里看一下是否有这个文件，再编辑。\n如下修改文件，保存退出。首先将BOOTPROTO改为static，然后增加下面的内容，设置静态IP，网关，DNS，注意要和上面的Vmware里的一致。\n这里设置的网关是 192.168.138.2 而不是习惯上的 192.168.138.1 这是Vmware的内外网隔离措施。而 192.168.138.1 是从虚拟机角度看到的主机的IP地址。\n重启网络服务 service network restart\n测试网络是否通了 ping www.baidu.com 信息滚动过程中可以用Ctrl + C中断\n然后从主机开一个命令行窗口 ping 192.168.138.11 能通，就说明双向OK了。\n1.4.3 安装常用工具\n前提是网络连接没有问题。\n更新系统（可选）：yum update\n没想到新下载的CentOS7-2009，更新居然有255M，现在比较智能，会找最快的镜像站点，大概更新用了5分钟。\n因为是最小化安装，很多工具没有，安装常用工具：\nyum -y install perl gcc kernel-devel wget\nyum -y install yum-utils\nyum -y install net-tools\nyum -y install unzip zip\n安装了上面的net-tools以后，就有ifconfig命令了，试一下\nifconfig\n可以看到自己的静态IP地址\n更新完毕后，可以重新启动一下系统 systemctl reboot\n1.5 用Putty连接虚拟机上传下载文件\n到Putty官网https://putty.org/，选第一个Download PuTTY，下面是第三方项目。\n下载64-bit x86版本，形如putty-64bit-0.77-installer.msi的安装文件。\n安装完成后，有多个程序，首先运行Putty，输入IP地址，点open就可以连接。\n连接后以root身份登录，可以看到显示的主机IP是192.168.138.1，命令exit可以退出登录，断开连接。\n然后运行PSFTP，窗口中输入open 192.168.138.11 进行连接，以root登录，可以看到提示当前工作路径是 /root，命令exit可以退出登录，断开连接。\n以后可以在虚拟机开机状态下，关闭Vmware，选择让虚拟机后台运行，然后用Putty连接进行操作，上传下载文件。\n需要在虚拟机里安装JDK，安装文件为主机 D:\\software\\jdk-8u351-linux-x64.rpm，这个文件是事先从Oracle网站下载来的。打开PSFTP连接，root登录。使用put命令将文件上传到虚拟机 /root 目录下。注意路径分隔符使用 / 而不是Windows风格的 \\，然后ls命令查看虚拟机上是否有这个文件了。exit退出，断开连接。\n1.6 密钥方式连接虚机\n密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。\n第一步：制作密钥对\n在虚机上制作密钥对。首先用root登录，然后执行以下命令：\nssh-keygen  &lt;== 建立密钥对\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/root/.ssh/id_rsa): &lt;== 回车\nCreated directory ‘/root/.ssh’.\nEnter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，或回车\nEnter same passphrase again: &lt;== 再输入一遍密钥锁码，回车\nYour identification has been saved in /root/.ssh/id_rsa. &lt;== 私钥\nYour public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 公钥\nThe key fingerprint is:\n…\nThe key’s randomart image is:\n…\n现在，在 /root 生成了一个 .ssh 的隐藏目录，内含两个密钥文件，id_rsa 为私钥，id_rsa.pub 为公钥。\n密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。本例中没有密钥锁码，方便使用。\n第二步：在虚机上安装公钥\n键入以下命令，在服务器上安装公钥：\ncd .ssh\ncat id_rsa.pub &gt;&gt; authorized_keys\n如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：\nchmod 600 authorized_keys\nchmod 700 ~/.ssh\n第三步：虚机开启密钥登录\n执行命令vi /etc/ssh/sshd_config，如下找到PubkeyAuthentication yes这一项，把前面的注释符号去掉。如果要禁用密码登录方式，则把下面的PasswordAuthentication改为no，本例中没有改，保留了密码登录方式。\n保存，退出编辑。重启ssh服务systemctl restart sshd\n第三步：用PSFTP下载私钥到主机\n用PSFTP密码登录方式连接虚机，下载id.rsa到本地重命名192.168.138.11.rsa\n第四步：将密钥导入到Putty\n首先打开PuttyGen，点Load按钮，选择文件对话框里的文件类型默认是*.ppk，改为*.*，找到刚才的192.168.138.11.rsa，就导入成功了，提示是旧的pem格式。\n然后点击Save private key，保存为192.168.138.11.ppk，与刚才的文件最好在同一文件夹下，询问是否要个锁码，不理他。\n关闭PuttyGen，打开Putty，左侧选择Session，右边填写Host Name为root@192.168.138.11，这里指定了登录用户为root，如果为其他用户则改为其他用户名。然后下面Saved Sessions空格里填上一个名字vm-192.168.138.11，点右侧Save就保存了。\n然后左侧Connection - SSH - Auth，直接点Auth不用展开，右边Browse找到刚才保存的192.168.138.11.ppk\n回到上一张图的Session，选中vm-192.168.138.11的情况下，点Save，一定要保存，否则下次又要找密钥。然后点下面的Open就连接成功了，不需要输入密码，直接root登录成功。\n今后要连接的时候，打开Putty，选中保存的vm-192.168.138.11，点Load，然后点下面的Open就可以连接上了。\n主机运行Putty组件Pageant，会在Windows右下角出现一个常驻的代理，从中可以快速连接已经保存的session或者进行一些密钥操作。\n1.7 安装JDK8\n前面“1.5 用Putty连接虚拟机上传下载文件”已经把JDK安装文件上传到 /root目录下了，执行 rpm -ivh jdk-8u351-linux-x64.rpm就可以安装JDK了。\n完成后执行java -version看到版本号就说明OK了\n命令alternatives --config java可以看到系统里有几个JDK，并设置默认JDK，本例只有一个，回车保持默认。\nvi /etc/profile\n在文件最后添加\nexport JAVA_HOME=/usr/java/default\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n注意CLASSPATH=后面是个英文句号，这样设置可以解决很多命令行下运行java程序找不到类的问题。\nOracle JDK安装后，在安装目录 /usr/java/ 下会生成3个目录。其中一个是真实的目录jdk1.8.0_351-amd64、目录链接latest表示最新版本、目录链接default表示默认版本。当前latest 指向真实的目录，default 指向 latest。上面的 JAVA_HOME 使用了 default目录，今后如果有多个版本，默认版本有变化，只需要修改default的指向就可以了，不需要修改系统变量。\n注销当前用户，重新登录，执行下面命令验证各变量正确：\necho $JAVA_HOME\necho $CLASSPATH\njava -version\n附录二、CentOS7安装MySQL\n2.1 克隆虚机\n上一章已经创建了一个虚机CentOS7-min，更新了系统，安装了常用工具，设置了密钥连接，安装了JDK8，为此虚机创建一个快照。菜单“虚拟机 - 快照 - 拍摄快照”，输入名字和描述就行了。\n菜单“虚拟机 - 管理 - 克隆”，克隆源选择“现有快照”，找到刚才拍摄的快照。\n克隆类型选择“创建完整克隆”\n输入虚机名称CentOS7-mysql，确认保存位置，完成。\n2.2 设置虚机\n开启新的虚机CentOS7-mysql，以root登录，首先要修改的是静态IP地址。\nvi /etc/sysconfig/network-scripts/ifcfg-ens33\n将静态IP地址改为192.168.138.21就行了，其他的不用动。\n重启网络服务service network restart\n虚机ping www.baidu.com，主机ping 192.168.138.21都OK\n参照“1.6密钥方式连接虚机”，打开Putty，在Session里新建保存一个名称为db-192.168.138.21，连接地址为root@192.168.138.21，左侧Connection - SSH - Auth，直接点Auth不用展开，右边Browse找到刚才保存的192.168.138.11.ppk（就是这个旧的密钥，不需要到虚机上创建新的密钥对了，因为是克隆的，所有信息都一样）\nSave，Open 连接成功。\n一般安全起见，新的虚机要创建新的密钥对。本例直接使用了旧的密钥，简便。\n2.3 安装MySQL\n2.3.1 安装MySQL8\n到MySQL官网，下载MySQL Yum Repository，操作系统是CentOS7，要安装的MySQL8.0，因此下载到的对应版本是mysql80-community-release-el7-7.noarch.rpm\n下载需要登录。注册一个免费的MySQL或Oracle账号即可，以后用得着。\n用PSFTP将文件上传到虚机 /root 目录下。\n安装yum库：rpm -Uvh mysql80-community-release-el7-7.noarch.rpm\n安装MySQL：yum install mysql-community-server\n中间可能有几个需要确认的地方，输入y回车即可。这个版本只有80M左右，非常快，不到1分钟就安装完毕。\n查询mysqld的状态systemctl status mysqld.service\n如果是inactive（active是绿色的）则启动之systemctl start mysqld.service\n启动完毕再查询状态systemctl status mysqld.service，正常\n查看安装过程中生成的随机密码，并以此密码登录mysql\ngrep ‘temporary password’ /var/log/mysqld.log\n可以看到下面的z6iv!b7Q8Zjt就是临时密码\n以临时密码登录MySQL，如下命令，提示输入密码时输入临时密码\nmysql -u root -p\n进入MySQL后，修改root（这个root用户是MySQL的用户）密码，大小写，数字，符号，8位，否则提示密码不合要求\nalter user ‘root’@’localhost’ identified by ‘sql=R00T’;\n命令quit或exit退出MySQL，然后用新密码登录MySQL成功。\n开启3306端口：firewall-cmd --zone=public --add-port=3306/tcp --permanent\n配置立即生效：firewall-cmd --reload\n以后会用到的其他防火墙命令：\n关闭端口firewall-cmd --zone=public --remove-port=5672/tcp --permanent\n查看所有开放端口firewall-cmd --zone=public --list-ports\n查看防火墙状态firewall-cmd --state\n关闭防火墙systemctl stop firewalld.service\n查看所有监听端口netstat -lnpt\n重启虚机reboot，查询mysqld的状态systemctl status mysqld.service\n发现是active的，说明MySQL服务是随系统启动而启动的，一切正常。\n到此，MySQL安装完毕，初始化配置root密码完毕。关闭虚机，拍摄快照，启动虚机，以后没事就不再安装MySQL了。\n（1）此虚机将作为数据库服务器长期保持运行，关闭Vmware界面时让其后台运行。今后操作MySQL以远程为主，比如用IDEA里的database navigator\n（2）MySQL有其备份方式，定期备份保障数据安全。另外，此虚机也可定期拍摄快照，如遇系统级故障，可以用快照恢复。\n2.3.2 特殊故障\nMySQL一段时间不操作则服务停掉。有时几天，有时十几天。\n参考解决方法：https://124654439.iteye.com/blog/2174953\n注意该文章的后半部分，否则就白看了。关键点是修改参数要带 global\n以root身份连接登录进mysql\nmysql&gt; show global variables like ‘wait_timeout’;\nmysql&gt; set global interactive_timeout= 31536000;\nmysql&gt; set global wait_timeout=31536000;\n在MySQL8.1的版本有这个问题，此方法可以解决。\n如果没这个问题，则略过。\n2.3.3 建立数据库、用户、表、数据\n数据库服务器建好后，一般远程操作。这里仅展示在服务器上的基本操作。\n本例中建立的库、用户、表、数据是为了配合前面的Spring Boot案例。\n用root登录MySQL，建立一个数据库ssm_db，建立一个用户ssmaster，然后把数据库ssm_db的所有权限赋予ssmaster\nmysql -u root -p\n输入root的密码登录，下面的命令都是MySQL里了\nmysql&gt; create database ssm_db DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;\nmysql&gt; create user ssmaster@‘%’ identified by ‘1gE=M!ka’;\nmysql&gt; create user ssmaster@localhost identified by ‘1gE=M!ka’;\nmysql&gt; grant all on ssm_db.* to ssmaster@‘%’;\nmysql&gt; grant all on ssm_db.* to ssmaster@localhost;\nmysql&gt; quit;\n库和用户都建好了，然后用ssmaster登录MySQL\nmysql -u ssmaster -p\n输入用户ssmaster的密码，下面的命令都是MySQL里了\nmysql&gt; use ssm_db;\nmysql&gt; CREATE TABLE IF NOT EXISTS tbl_book(id INT UNSIGNED AUTO_INCREMENT,type VARCHAR(100) NOT NULL,name VARCHAR(100) NOT NULL,description VARCHAR(200),PRIMARY KEY (id))DEFAULT CHARSET=utf8;\nmysql&gt; INSERT INTO tbl_book(type,name,description) VALUES (‘novel’,’Learning Spring Boot’,’How to coding with Spring Boot.’);\nmysql&gt; select * from tbl_book;\n可以看到表建好了，并且插入了一条数据。id是自增的，不需要输入。\nmysql&gt; quit;\n2.3.4 远程操作数据库\nIDEA社区版安装Database Navigator插件就可以远程操作数据库了。\n一般工具栏在左侧，点开后，点绿色 + 号新建一个MySQL连接如下。输入Name不一定要与数据库名一致，Description可以留空，Host填写IP地址，确认端口号是3306，Database填上面创建的库ssm_db，下面的用户名密码填上面创建的用户名密码，Driver用内置库。可以先点Test Connection按钮测试一下连接，显示成功。然后点最下面的OK，这个数据库连接就完成了。\n连接建好后，就可以看到ssm_db的整个结构，并可以进行建表，修改数据等操作。\n一般对数据库进行操作，是通过SQL方式。点击Open SQL console按钮打开SQL的控制台，在控制台输入如下，插入一条数据\ninsert into tbl_book(type,name,description) VALUES (‘技术’,’大学物理’,’全国通用大学物理教程’);\n点Execute Statement就可以执行这条SQL语句。执行完毕，就生效了，另外两个按钮Commit和Rollback还亮着，说明这条SQL语句还没有正式提交数据库，可以回滚。点击Commit按钮正式提交，然后Commit和Rollback两个按钮就灰了。\n再输入select * from tbl_book; 执行，就可以看到查询出的数据。\n完结撒花！\n","categories":["Java开发专题"],"tags":["Spring Boot"]},{"title":"Java基础","url":"/2024/03/16/Java_language/","content":"Java语言\n1. 语言基础\n1.1 基础语法\n\n数据类型\n\n数据类型分为两类：基本数据类型、引用数据类型。\nJava中的基本数据类型只有**四类八种**整数型：byte、short、int、longshort占两字节int 占用四个字节long 占用八个字节\n\n浮点型\n\n浮点型有两种：float、doublefloat占用四位，double占用八位\n\n字符型\n\n字符型为char，char类型是一个单一的16位Unicode字符。\n\n布尔型\n\n The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its &quot;size&quot; isn&#x27;t something that&#x27;s precisely defined. 翻译：布尔数据类型只有两种可能的值：true和false。使用这个数据类型用于追踪true/false状况的简单标识。这个数据类型表示1bit的信息，但是它的”大小“没有被精确定义。\n\n\n引用数据类型\n\n只要不是基本数据类型就是引用数据类型。\n\n自动类型转换（隐式）\n\n转换规则： 数据范围必须是**从小到大**，即由小的转换成大的，自动转换。\n\n强制类型转换（显式）\n\n注意事项：1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。 2. byte/short/char这三种类型都可以发生数学运算，例如加法“+”。3. byte/short/char这三种类型在运算的时候都会首先提升成为int类型，然后再计算。例：byte+byte-&gt;int+int-&gt;int4. boolean类型不能发生数据类型转换\n\n运算符的优先级\n\n单目（一元）&gt;算术运算符&gt;移位&gt;关系&gt;位&gt;条件(三元)&gt;赋值\n\n基础语法\n\n1. 大小写敏感： Java是大小写敏感的语言，例如Hello和hello是不同的，这其实就是Java的字符串表示方式。2. 类名：类名使用 UpperCamelCase 风格，但以下情形例外： DO / BO / DTO / VO / AO /PO / UID 等。正例： ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion反例： forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion3. 包名：包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。正例： 应用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils（此规则参考 spring 的框架结构）4. 方法名、变量名、参数名：都统一使用 lowerCamelCase 风格正例： localValue / getHttpMessage() / inputUserId\n\n方法\n构造方法\n\n作用：用来创建对象的注意事项：1. 构造方法的名称必须和所在类的名称完全一样，就连大小写也要一样2. 构造方法不要写返回值类型，连void都不写3. 构造方法不能return一个具体的返回值4. 如果没有编写任何构造方法，那么编译器会默认分配一个构造方法5. 一旦编写了一个构造方法，那么编译器就不会再分配任何构造方法\n\n静态方法\n\n静态方法又叫类方法。\n\n非静态方法（成员方法）\n\n方法之间的调用注意事项：1. 同类型的方法之间可以直接调用2. 静态方法调用非静态方法需要先new一个对象，然后通过对象进行调用。3. 非静态方法可以直接调用静态方法。\n\n方法重载\n\n多个方法的名称相同，但是参数列表不一样。方法重载与下列因素相关：1. 参数个数不同2. 参数类型不同3. 多参数类型顺序不同方法重载与下列因素无关：1. 与参数名称无关2. 与方法的返回值类型无关3. \n\n参数传递机制\n\nJava的参数传递机制都是：值传递\n\n数组\n\nJava的内存划分成为5个部分：1. 栈内存（stack）：存放的都是方法中的局部变量。  方法的运行一定要在栈中运行。         局部变量： 方法的参数、方法&#123;&#125;内部的变量2. 堆内存（heap）: 凡是new出来的东西都在堆当中。        堆内存里面的东西都有一个地址值：16进制        堆内存中的数据都有默认值。规则：                 整数         默认0                 浮点数       默认0.0                 字符         默认&#x27;\\u0000&#x27;                 布尔         默认false                 引用类型      默认null3. 方法区（）: 存储.class相关信息，包含方法的信息。4. 本地方法栈（）： 与操作系统相关5. 寄存器（）： 与cpu相关\n1.2 面向对象\n\n特点\n\n面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成指挥者。\n面向对象语言包含三大基本特征：\n\n\n封装\n就是将一些细节信息隐藏起来，对外界不可见。\n\n方法就是一种封装\nprivate关键字也是一种封装\n\n一旦使用private进行修饰，那么本类当中仍然可以随意访问，但是超出了本类范围之外就不能再直接访问了。\n可以使用getter/setter方法间接访问private成员变量。\n\n\n继承\n\n\n​        继承是多态的前提，如果没有继承，就没有多态。\n​        继承主要解决的问题就是：共性抽取\n  **变量重名的解决方法**\n\n​        \t 局部变量：                    直接写成员变量名\n​        \t 本类的成员变量：          this.成员变量名\n​          \t父类的成员变量：          super.成员变量名\n **重写（override）**    \n\n​        \t 概念：在继承关系中，方法的名称一样，参数列表一样。\n​        \t 方法重写（override）：方法名称一样，参数列表也一样。（覆盖重写）\n​        \t 方法重载（overload）：方法名称一样，参数列表不一样。\n **覆盖重写的注意事项：**\n\n          1. 必须保证父子类之间的方法名称相同，参数列表也相同。\n          2. 子类方法的权限必须大于等于父类方法的权限修饰符。\n\n​         public&gt;protected&gt;(default)&gt;private\n​         备注：（default）不是关键字default，而是什么修饰符也不用。\n​\t继承关系中，父子类构造方法的访问特点：\n1. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造\n\n​\t\t注意事项：\n​\t\t\t子类必须调用父类构造方法，不写则默认super（），写了则用写的指定的super调用，super只能有一个，还必须是第一个。\n​\t\tJava继承的三大特点\n\nJava语言是单继承的，即一个类的直接父类只能有唯一一个。\nJava语言可以多级继承。\n一个子类只能有一个父类，但是一个父类可以有多个子类。\n\n如果父类当中的方法不确定如何进行{}方法体实现，那么这就应该是一个抽象方法。\n抽象类：抽象方法所在的类必须是抽象类才行。在class之前写上abstract即可。\npublic abstract class Animal&#123;    //这是一个抽象方法，代表吃东西，但是具体吃什么不确定。    public abstract void eat();&#125;\n如何使用抽象类和抽象方法\n\n\n不能直接创建new抽象类对象\n\n\n必须用一个子类来继承抽象父类。\n\n\n子类必须覆盖重写抽象父类当中的所有抽象方法。\n覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号\n\n创建子类对象进行使用。\n\npublic  class Cat extends Animal&#123;    @Override    public void eat()&#123;        &#125;&#125;\n\n\n\n多态\n\n一个对象拥有多种形态，这个就叫对象的多态性。\n代码当中体现多态性，其实就是一句话，父类引用指向子类对象。\n格式：\n父类名称 对象名 = new 子类名称（）；\n或者\n接口名称 对象名 = new  实现类名称（）；\n访问成员变量和方法的规则：\n访问成员方法：等号右边new的谁，优先用谁，没有则向上找。\n直接通过对象名称访问成员变量：等号左边是谁，优先用谁，没有则向上找。\n间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。\n对象的转型\n\n对象的向上转型，其实就是多态写法：\n\n格式：父类名称 对象名 = new 子类名称（）；\n\n对象的向下转型，其实是一个【还原】的动作\n\n格式：子类名称 对象名 = （子类名称） 父类对象\n注意事项：\n\n必须保证对象本来创建的时候就是A,才能向下转型成为A。\n如果创建的对象本来不是A，非要向下转型为A就会报错。\n\n四种权限修饰符\n内部类\n\n成员内部类\n局部内部类（包含匿名内部类）\n\n成员内部类的定义格式：\n修饰符 class 外部类名称&#123;      修饰符 class 内部类名称&#123;            &#125;&#125;注意：内用外，随意访问； 外用内，需要内部类对象。\n局部内部类的定义格式：\n修饰符 class 外部类名称&#123;      修饰符 返回值类型 方法名称（参数列表）&#123;              class 局部内部类名称&#123;                   &#125;      &#125;    &#125;\n匿名内部类的定义格式：\n接口名称 对象名称 =  new 接口名称（）&#123; 覆盖重写所有抽象方法&#125;；注意事项：    1. 匿名内部类在创建对象的时候只能使用唯一一次    \n\n类和对象\n\n什么是类\n\n类：是一组相关属性和行为的集合。\n\n现实中，描述一类事物：\n\n\n属性：就是该事物的特征信息。（是什么）（成员变量）\n\n\n行为：就是该事物能够做什么。（成员方法）成员方法不要写static关键字。\n\n\n什么是对象\n\n对象：是一类事物的具体体香。对象是类的一个实例。\n\n类与对象的关系\n\n类是对一类事物的描述，是抽象的。\n对象是一类事物的实例，是具体的。\n类是对象的模板，对象是类的实体。\n\n成员变量和局部变量的区别\n1. 定义的位置不一样局部变量：在方法的内部成员变量：在方法的外部，直接写在类当中。2. 作用范围不一样局部变量：只有方法当中才可以使用成员变量：整个类全可以通用3. 默认值不一样局部变量：没有默认值，如果要想使用，必须手动赋值成员变量：如果没有赋值，会有默认值，规则和数组一样。4. 内存的位置不一样局部变量：位于栈内存成员变量：位于堆内存5. 生命周期不一样局部变量：随着方法进栈而生，随着方法出栈而亡成员变量：随着对象创建而生，随着对象被垃圾回收而亡。\n\n对象数组\n\n数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变。\n\n字符串\n\n1. 字符串的内容不可变2. 字符串可以共享使用3. 字符串效果上相当于char[]字符数组，但是底层原理是byte[]字节数组在堆内存中有一个字符串常量池。常用方法：equalslength()concat:连接字符串charAt:indexOf:\nStringBuilder类：字符串缓冲区，可以提高字符串的效率\n常用方法：\nappend\ntoString\n\n静态关键字static\n\n一旦用了static关键字，那么这样的内容不再属于对象自己，\n而是属于类的，所以凡是本类的对象，都共享同一份。\n一旦使用static修饰成员方法，那么就成为了静态方法，静态方法不属于对象，而是属于类的。如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。无论是成员变量还是方法，如果有了static，都推荐使用类名称进行调用。静态变量：类名称.静态变量静态方法：类名称.静态方法（）注意事项：1. 静态方法当中不能使用this\n静态代码块\n特点：当第一次用到本类时，静态代码块执行唯一的一次。\n静态内容总是优先于非静态，所以静态代码块比构造方法先执行。\n静态代码块的用途：\n用来一次性的对静态成员变量进行赋值。\nArrays工具类\ntoString(数组)：将参数数组变成字符串（按照默认格式：[元素1，元素2,…]）\n1.3 接口\n接口就是多个类的公共规范\n接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。\n从Java 8开始，接口 里允许定义默认方法。\n备注：接口当中的默认方法可以解决接口升级的问题。\n什么是接口升级？\n就是已经投入使用的接口，想在其中添加新的方法，这时如果直接添加，会导致所有实现该接口的类报错，但是使用default默认方法可以解决此问题，并且该方法也可以被其他接口实现类覆盖重写。\n格式：\npublic default 返回值类型 方法名称（参数列表）&#123;方法体&#125;\n从Java 9 开始，接口中允许定义私有方法。\n\n普通私有方法，解决多个默认方法之间的重复代码问题\n\n格式：\nprivate 返回值类型 方法名称（参数列表）&#123;&#125;\n\n静态私有方法：解决多个静态方法之间重复代码问题\n\n格式：\nprivate static 返回值类型 方法名称（参数列表）&#123;方法体&#125;\n接口与接口之间是多继承的。\n\n日期时间类\n\ndate\n\nDateFormat类\n\n日期时间格式化类\n\n包装类\n\n基本类型             对应的包装类byte                  Byteshort                 Shortint                   Integerlong                  Longfloat                 Floatdouble                Doublechar                  Characterboolean               Boolean\n装箱与拆箱\n装箱：从基本类型转换成对应的包装类对象\n拆箱：从包装类对象转换为对应的基本类型\nInteger i= Integer.valueOf(4)//装箱int num = i.intValue();//拆箱\n1.4 容器\n\ncollection集合\n\n**集合：**集合是Java中提供的一种容器，可以用来存储多个数据。\n集合和数组既然都是容器，它们有啥区别？\n\n数组的长度是固定的，集合的长度是可变的\n数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象，而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。\n\n常用共性方法\npublic boolean add(E e): 添加对象public void clear(): 清空集合public boolean remove(E e): 把给定对象从当前集合删除public boolean contains(E e): 判断当前集合中是否包含给定的对象public boolean isEmpty():public int size(): 返回集合中的元素个数public Object[] toArray(): 把集合中的元素，存储到数组中\nList\n\n有序的集合（存储和取出元素顺序相同）\n允许存储重复的元素\n有索引，可以使用普通的for循环遍历\n\n\nArrayList（查询快，增删慢）\n\nArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();\n常用方法：\nadd,get,remove,size\n\nLinkedList（查询慢，增删快）\n\nLinkedList&lt;E&gt; linked = new LinkerdList&lt;&gt;();\nSet\n\n不允许存储重复的元素\n没有索引\n\n\nHashSet\n\nHashSet&lt;E&gt; set = new HashSet&lt;&gt;();\n\n是一个无序集合\n底层是一个哈希表结构\n\n哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑i地址，是模拟出来的地址，不是数据实际存储的物理地址）\nint hashCode():获取对象的哈希码值\n哈希表（查询快）\n哈希表的结构，jdk1.8之后：\n\n哈希表=数组+链表；\n哈希表=数组+红黑树；\n\n\nLInkedHashSet\n\nLInkedHashSet特点：\n底层是一个哈希表+链表，多了一条链表（记录元素的存储顺序），保证元素有序。\nHashSet存储自定义类型元素\n给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。\n可变参数\n格式\n修饰符 返回值类型 方法名（数据类型...变量名）&#123;&#125;实例    public static int add(int... arr) &#123;        int sum = 0;        for (int i : arr) &#123;            sum += i;        &#125;        return sum;    &#125;注意事项    1. 一个方法的参数列表只能有一个可变参数    2. 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾。可变参数的特殊（终极）写法    实例     public static void method(Object...obj)&#123;        &#125;\nMap\n特点\n\nmap集合是一个双列集合，一个元素包含两个值（key:value）\nmap集合中的元素，key和value的数据类型可以相同，也可以不同\nmap中key是不允许重复的，value可以重复\nmap中的key和value一一对应\n\n\nHashMap（初始长度16）\n\n特点：\n\nHashMap集合底层是哈希表：查询速度特别快\nhashMap是一个无序集合，存储和取出元素的顺序可能不一致\n\n\nLinkedHashMap\n\n特点：\n\n底层是哈希表+链表（保证迭代的顺序）\n是一个有序的集合，存储和取出元素的顺序是一致的\n\n\nTreeMap\n\n\nCollections工具类\n常用方法\npublic static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements) ：往集合中添加一些元素public static void shuffle(List&lt;?&gt; list) ：打乱集合顺序public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)：将集合按照默认规则排序public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)：将集合中元素按照指定规则排序\n1.4.1 Iterator迭代器\n迭代：Collection集合元素的通用获取方式。\n迭代器的使用案例\npublic static void main(String[] args) &#123;       Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();       coll.add(&quot;姚明&quot;);       coll.add(&quot;科比&quot;);       coll.add(&quot;詹姆斯&quot;);       coll.add(&quot;库里&quot;);       //获取一个迭代器对象       Iterator&lt;String&gt; iterator = coll.iterator();       while (iterator.hasNext())&#123;           String s = iterator.next();           System.out.println(s);       &#125;&#125;\n1.5 异常\n异常：指的是程序在执行过程中，出现非正常的情况，最终导致JVM非正常停止。\nJava处理异常的方式是中断处理。\n异常产生的过程解析\n1.5.1 异常的处理\nJava异常处理的五个关键字：try、catch、finally、throw、throws\n\n抛出异常throw\n\nthrow作用：\n可以使用throw关键字在指定的方法中抛出指定的异常\n使用格式：\nthrow new xxxException（“异常产生的原因”）;\n注意：\n\nthrow关键字必须写在方法的内部\nthrow后面new的对象必须是Exception或者Exception的子类对象\nthrow抛出指定的异常对象，我们必须处理这个异常对象，要么用throws，要么try…catch\n\n以后（工作中）我们首先必须对方法传递过来的参数进行合法性校验如果参数不合法，那么我们就必须使用抛出异常的方式，告知方法的调用者，传递的参数有问题。\n\n声明异常throws（异常处理的第一种方式）\n\n作用：\n当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象\n可以使用throws处理异常对象，把异常声明抛出给方法的调用者处理（自己不处理，谁调用我让谁处理），最终交给jvm处理–&gt;中断异常\n使用格式：在方法声明时使用\n修饰符 返回值类型 方法名（参数列表） throws xxxException,.....&#123;\tthrow new xxxException(&quot;产生原因&quot;);&#125;注意    1. throws 必须写在方法声明处    2. throws 后边声明的异常必须是Exception或者其子类    3. 方法内部如果抛出多个异常，那么throws后边也必须声明多个异常        如果多个异常之间有子父类关系，直接声明父类异常就行    4. 调用了一个声明抛出异常的方法，我们就必须处理声明的异常        要么继续使用 throws 声明抛出，交给方法的调用者处理，最终交给 JVM        要么 try....catch 自己处理。\n\n捕获异常try…catch（异常处理的第二种方式）\n\n格式：\ntry&#123;    &#125;catch(xxxException e)&#123; //try中抛出什么异常，catch就定义什么异常对象，用来接收这个异常。    一般在工作中，会把异常的信息记录在一个日志中。&#125;注意    1. try 可能会抛出多个异常，那么可以使用多个 catch 来处理    2. 如果 try 中产生了异常，就会执行 catch 中的异常处理逻辑，执行完后，继续执行 try...catch 后的代码。    3. 如果 try 中没有异常，就不执行 catch ，执行完 try 后，继续执行 try...catch 后的代码。\n1.6 泛型\n泛型是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型。\n泛型的数据类型在创建对象的时候确定\n创建集合对象，使用泛型\n好处：\n\n避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型\n把运行期异常（代码运行之后抛出的异常）提升到了编译期\n\n弊端：\n\n泛型是什么类型，只能存储什么类型的数据\n\n含有泛型的方法\n定义格式\n 修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表（使用泛型）)&#123;        方法体;    &#125;实例 public &lt;H&gt; void genericMethod(H h)&#123;        System.out.println(h);    &#125;\n含有泛型的接口\n定义格式\n第一种使用方式，定义接口的实现类，实现接口并指定接口的泛型实例    public interface Iterator&lt;E&gt; &#123;\t\t\tE next();  &#125;\tpublic final class Scanner implements Iterator&lt;String&gt;&#123;\t&#125;第二种使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走   public interface List&lt;E&gt;&#123;        boolean add(E e);      &#125;   public class ArrayList&lt;E&gt; implements List&lt;E&gt;&#123;       public boolean add(E e) &#123;       &#125;   &#125;\n泛型通配符\n​\t？：代表任意的数据类型\n使用方式：\n​\t不能创建对象使用\n​\t  只能作为方法的参数使用\n高级使用-受限泛型（要求只要看源码能看懂就行）\n作用：限定数据的使用类型。\n泛型的上限限定：？extends E 代表使用的泛型只能是E类型的子类/本身\n泛型的下限限定：？super E 代表使用的泛型只能是E类型的父类/本身\n\n数据结构\n\n红黑树\n特点：\n\n趋近于平衡树，查询的速度非常快，查询叶子节点最大次数和最小次数不能超过2倍\n\n约束：\n\n节点可以是红色或者黑色\n根节点是黑色\n叶子节点（空节点）是黑色\n每个红色的节点的子节点都是黑色\n任何一个节点到其每一个叶子节点所有路径上的黑色节点数相等\n\n1.7 反射\n作用\n\n基本作用：可以得到一个类的全部成分然后操作\n可以破坏封装性\n最重要的用途是：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。\n\n1.8 注解\n就是Java的特殊标记，作用是：让其他程序根据注解信息来决定怎么执行该程序\n特殊属性名：value\n如果注解只有一个value属性，使用注解时，value名称可以不写。\n元注解\n修饰注解的注解\n常见的元注解\n1. @Target    作用：声明被修饰的注解只能在哪些位置使用    @@Target(ElementType.TYPE)    1. TYPE,类，接口    2. FIELD， 成员变量    3. METHOD，成员方法    .....      2. @Retention    作用：声明注解的保留周期    @Retention(RetentionPolicy.RUNTIME)    1. SOURCE    只作用在源码阶段，字节码文件中不存在    3.RUNTIME（开发常用）    一直保留到运行阶段\n注解的解析\n要解析谁上面的注解，就先拿到谁\n1.9 I/O\n重点：记住三个单词\n​          file： 文件\n​          directory：文件夹/目录\n​          path： 路径\n递归：指在当前方法内部调用自己的这种现象\n递归的分类：\n\n直接递归\n\n​        方法自身调用自身\n\n间接递归\n\n​\t\tA方法调用B方法，B方法调用C方法，C方法调用A方法。\nJava中的I/O操作主要是指使用Java.io包下的内容，进行输入、输出操作。\n\n字节流（InputStream/OutputStream）\n\nFileInputStream     文件字节输入流    作用：把硬盘文件中的数据，读取到内存中使用FileOutputStream    文件字节输出流    作用：把内存中的数据写入到硬盘的文件中\n使用字节流读取中文文件容易产生乱码\n一个中文\n​\t\tGBK： 占用两个字节\n\tUTF-8：占用三个字节\n\n\n字符流（reader/writer）\n\n作用：读取字符信息，一次读取一个字符\njdk7的新特性\n在try后边可以增加一个()，在括号中可以定义流对象\n那么这个流对象的作用域就在try中有效\ntry中的代码执行完毕会自动把流对象释放，不用写finally\n格式\ntry(定义流对象；定义流对象...)&#123;    可能会产生异常的代码&#125;catch(异常类变量 变量名)&#123;    异常的处理逻辑&#125;实例public class ThreadPoll &#123;    public static void main(String[] args) &#123;        try(//创建一个字符输出流对象，构造方法绑定需要写入的目的地            FileWriter fw = new FileWriter(&quot;test.txt&quot;,true);) &#123;//            //创建一个字符输入流对象，构造方法绑定需要读取的数据源//            FileReader fr = new FileReader(&quot;test.txt&quot;);            for (int i = 0; i &lt; 10; i++) &#123;                fw.append(&quot;helloword&quot;+i+&quot;\\r\\n&quot;);            &#125;        &#125;catch (Exception e)&#123; \t\t\te.printStackTrace();        &#125;    &#125;&#125;\n\n缓冲流\n\n作用：提高文件读写的效率\n字节缓冲流（BufferedInputStream &amp; BufferedOutputStream）\n字符缓冲流（BufferedReader &amp; BufferWriter）\n\n转换流(OutputStreamWriter &amp; InputStreamReader)\n\n作用：能够转换编码\n\n序列化流(ObjectOutputStream &amp; ObjectInputStream )\n\n作用：能够持久化存储对象\nSerializable 接口也叫标记型接口    要进行序列化和反序列化的类必须实现 Serializable 接口，就会给类添加一个标记    当我们进行序列化和反序列化的时候，就会检测是否有这个标记    有：就可以序列化和反系列化    没有：就会抛出 NotSerializableException 异常 transient关键字：瞬态关键字    被 transient 修饰的成员变量，不能被序列化问题：    每次修改类的定义，都会给class文件生成一个新的序列号，这样在进行序列化与反序列化时就会报invalidClassException异常解决方法：    无论是否对类的定义进行修改，都不重新生成新的序列号    可以手动给类添加一个序列号  格式：    private static final long serialVersionUID = 6161825669842708241L;等号后面的常量可以为任意值，不可改变。\n序列化集合\n当我们想在文件中保存多个对象的时候，可以把多个对象存储到一个集合中，然后对集合进行序列化和反序列化。\n2. JVM\n2.1 类加载机制\n2.2 字节码执行机制\n2.3 jvm内存模型\n2.4 gc垃圾回收机制\n2.5 jvm性能监控和故障定位\n2.6 jvm调优\n3. 并发/多线程\n3.1 并发编程\n3.2 多线程\n创建线程的步骤：\n\n声明Thread类的子类\n重写Thread类的run方法\n\n实例public class MyThread extends Thread&#123;    @Override    public void run() &#123;        //设置线程任务    &#125;&#125;创建线程的第二种方式    1. 创建一个runnable接口的实现类    2. 在实现类中重写runnable接口的run方法，设置线程任务 实例public class MyRunnableThreadImpl implements Runnable&#123;    @Override    public void run() &#123;        //设置线程任务        for (int i = 0; i &lt; 20; i++) &#123;            System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+i);        &#125;    &#125;&#125;public class RunnableThreaTest &#123;    public static void main(String[] args) &#123;        //多态写法        //Runnable runnable= new MyRunnableThreadImpl();        MyRunnableThreadImpl runnable= new MyRunnableThreadImpl();        Thread t = new Thread(runnable);        t.start();        for (int i = 0; i &lt; 20; i++) &#123;            System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+i);        &#125;    &#125;&#125;使用runnable接口创建多线程的好处：    1. 避免了单继承的局限性    2. 增强了程序的扩展性，降低了程序的耦合性（解耦）\nThread类中的常用方法\npublic final String getName()：获取；当前线程名public synchronized void start() ：此线程开始执行，Java虚拟机调用此线程的run方法public static void sleep(long millis, int nanos):使当前线程暂停指定多长时间public void run()：线程要执行的任务都在此处编写public static native Thread currentThread()：返回当前正在执行的线程对象的引用        \n并发与并行\n并发：指两个或多个事件在同一时间段内发生\n并行：指两个或多个事件在同一时刻发生（同时发生）\n线程与进程\n进程： 是指一个内存中运行的应用程序\n线程： 是指进程中的一个执行单元，负责当前进程中程序的执行，一个进程至少有一个线程。一个进程中是可以有多个线程的，这个应用程序称为多线程程序。\n线程调度\n分时调度： 所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。\n抢占式调度： 优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java使用的为抢占式调度。\n3.2.1 线程安全\n解决线程安全问题\n\n同步代码块: synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。\n\n使用synchronized关键字容易产生死锁（如何解决，在后续内容中写）\n格式：\nsynchronized（同步锁（锁对象））&#123;    //需要同步操作的代码即：可能出现线程安全问题的代码（访问了共享数据的代码）&#125;同步锁（锁对象）注意事项：    1. 同步代码块中的锁对象，可以使用任意的对象    2. 必须保证多个线程使用的锁对象是同一个    3. 锁对象作用：             把同步代码块锁住，只让一个线程在同步代码块中执行实例public class MyRunnableThreadImpl implements Runnable&#123;    private Integer ticket = 100;    Object obj = new Object();    @Override    public void run() &#123;        //同步锁        synchronized (obj)&#123;            while (true)&#123;                if (ticket&gt;0)&#123;                    try &#123;                        Thread.sleep(10);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+ticket);                    ticket--;                &#125;            &#125;        &#125;    &#125;&#125;\n\n同步方法\n\n格式：\n修饰符 synchronized 返回值类型 参数名（参数列表）&#123;    //需要同步操作的代码即：可能出现线程安全问题的代码（访问了共享数据的代码）&#125;实例public class MyRunnableThreadImpl implements Runnable&#123;    private Integer ticket = 100;    @Override    public void run() &#123;            while (true)&#123;                payTicket();            &#125;        //同步方法        public synchronized void payTicket()&#123;        if (ticket&gt;0)&#123;            try &#123;                Thread.sleep(10);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+ticket);            ticket--;        &#125;    &#125;&#125;**静态同步方法**锁对象是谁？不能是thisthis是创建对象之后产生的，静态方法优先于对象静态方法的锁对象是本类的class属性--&gt;class文件对象(反射)\n\nLock锁\n\nLock接口中的方法：\nvoid lock() 获取锁\nvoid unlock() 释放锁\n实例public class RunnableImpl implements Runnable&#123;    private Integer ticket = 100;   Lock l = new ReentrantLock();    @Override    public void run() &#123;        while (true) &#123;            l.lock();            if (ticket &gt; 0) &#123;                try &#123;                    Thread.sleep(10);                    System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + ticket);                    ticket--;                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    l.unlock();                &#125;            &#125;        &#125;    &#125;&#125;\n3.3 线程池\n线程池： 其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作。\n3.4 锁\n3.5 并发容器\n3.6 原子类\n3.7 juc并发工具类\n4. 网络编程\n软件结构：c/s，b/s\n4.1 网络通信\n网络通信协议的分类\n\nUDP：用户数据报协议\n\n特点：消耗资源小，通信效率高\n通常用于音频、视频和普通数据的传输例如视频会议都使用udp协议，即使丢一两个数据包，也不会对接受结果产生太大影响。\n\nTCP：传输控制协议\n\n是面向连接的通信协议。在TCP连接中必须要明确客户端与服务器端，每次连接的创建都需要经过“三次握手”。\n特点：传输安全\n网络编程的三要素\n\n协议\nIP地址\n\n\nIPv4：32位的二进制数，通常被分为4个字节，表示a.b.c.d的形式，每个字节的范围都是0~255.\nIPv6：\n\n\n端口号\n\n4.2 函数式接口\n函数式接口：只有一个抽象方法的接口，称之为函数式接口\n当然接口中可以包含其他的方法（默认，静态，私有）\nLambda表达式\n函数式编程思想：\n​\t只要能获取到结果，谁去做，怎么做的都不重要，重视的是结果，不重视过程。\n使用前提\n\n使用Lambda必须具有接口，且要求接口中有且只有一个抽象方法。\n使用Lambda必须具有上下文推断\n\n有些场景的代码执行后结果不一定被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，正好可以作为解决方案，提升性能。\n常用函数式接口\n\nSupplier接口\n\nSupplier:被称为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据public class Demo01Test &#123;    /**     * 定义一个方法，用于获取int类型数组中元素的最大值，     * 方法的参数传递Supplier接口，泛型使用Integer     * @param sup     * @return     */    public static int getMax(Supplier&lt;Integer&gt; sup)&#123;        return sup.get();    &#125;    public static void main(String[] args) &#123;        int[] arr = &#123;100,0,-50,88,99&#125;;       int max= getMax(()-&gt;&#123;           int temp= arr[0];           for (int i = 1; i &lt; arr.length; i++) &#123;               if (temp&lt;arr[i])&#123;                   temp=arr[i];               &#125;           &#125;           return temp;        &#125;);        System.out.println(max);    &#125;&#125;\n\nConsumer接口\n\nConsumer:消费型接口，泛型执行什么类型，就可以使用accept方法使用什么类型的数据至于怎么消费（使用），需要自定义（输出，计算）默认方法：andThen作用：将两个Consumer接口连接到一起，然后再对数据进行消费（使用）public class DemoConsumer &#123;    public static void printMessage(String[] arr, Consumer&lt;String&gt; con1,Consumer&lt;String&gt; con2)&#123;        for (String s : arr) &#123;            con1.andThen(con2).accept(s);        &#125;    &#125;    public static void main(String[] args) &#123;        String[] arr =  &#123;&quot;迪丽热巴，女&quot;,&quot;古力娜扎，女&quot;,&quot;沈腾，男&quot;&#125;;        printMessage(arr,                (s)-&gt;&#123;                    System.out.print(&quot;姓名：&quot;+s.split(&quot;，&quot;)[0]+&quot;\\t&quot;);                &#125;,                (s)-&gt;&#123;                    System.out.println(&quot;性别：&quot;+s.split(&quot;，&quot;)[1]+&quot;。&quot;);                &#125;);    &#125;&#125;  \n\nPredicate接口\n\n对某种类型的数据进行判断，从而得到一个Boolean值结果。public class DemoPredicate &#123;    /**     * 定义一个方法，方法的参数传递一个字符串     * 传递两个Predicate接口     * 一个用于判断字符串的长度大于5     * 一个用于判断字符串中是否包含a     * 两个条件必须同时满足     * @param pre1     * @return     */    public static boolean checkString(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)&#123;          // return pre1.test(s) &amp;&amp; pre2.test(s);        //return pre1.test(s) || pre2.test(s);//        return pre1.or(pre2).test(s);          return pre1.and(pre2).test(s);    &#125;    public static void main(String[] args) &#123;        String test = &quot;Hello world!!&quot;;       boolean b= checkString(test,                (s)-&gt;&#123;            return s.length()&gt;5;                &#125;,                (s)-&gt;&#123;            return s.contains(&quot;H&quot;);                &#125;);        System.out.println(b);    &#125;&#125;\n4.3 Stream流\nIO流和Stream流是两个概念，IO流是用于数据的读写，而Stream流可以用来对集合和数组进行简化操作。\n","categories":["Java开发专题"],"tags":["Java"]},{"title":"Vmware安装Debian 11","url":"/2022/12/29/Vmware_install_Debian11/","content":"一、Vmware安装Debian 11\n本例中采用虚拟化软件VMware Workstation安装Debian 11.5.0（base system安装）。实际应用中，单个服务器一般都设定为单一功能，比如Web服务器，数据库服务器，LDAP服务器等，或者多台服务器分布式部署云计算组件如Hadoop等，单个服务器只需要操作系统的基本功能，因此Debian最小化安装符合需求，如果需要额外的功能，可以在使用过程中增加。\n本例Debian安装环境如下：\n主机（Host Machine）：CPU 20核，内存32G，操作系统Windows 11家庭版64位\n虚拟化软件：VMware Workstation 16 pro\n到 https://www.debian.org/ 下载安装包，本例是debian-11.5.0-amd64-DVD-1.iso\n1.1 安装前Vmware设置\n1、在VMware菜单“编辑-首选项”可以设置虚拟机默认放置的目录，应选择有足够空间的硬盘分区。本例中是 D:\\MyVM\n2、创建虚拟机采用“自定义(高级)”配置，选择安装来源时，载入Debian的ISO后，Vmware无法识别版本，其识别的版本最高是Debian 10.x。选择“稍后安装操作系统”不采用简易安装，而采用手动安装。后面“客户机操作系统”选择Linux，下拉框选择Debian 10.x 64位。\n3、虚拟机名称 deb-min，选择 D:\\MyVM\\deb-min作为存储位置\n4、为虚机分配处理器1个，内核数量1个，2G内存。本例中这个虚拟机实例是作为干净基准系统，具体的应用虚拟机可以克隆这个虚拟机，不用重新安装。分配的CPU核数，内存数在克隆后可以在Vmware里修改。实验用虚机一般1核2G内存即可，可租用的轻量级云服务器一般是1核1G内存。实际虚机则根据需要分配资源，计算单元则对CPU要求较高，内容服务器则对内存要求较高。\n5、使用NAT网络（默认选项），虚机没有与主机同级的IP地址。\n桥接，NAT，仅主机模式，三者的简要区别如下：\n（1）桥接：虚机与主机在网络中地位一样，虚机拥有与主机同级的独立IP地址。\n（2）NAT：虚机共享主机的IP地址访问Internet，同一个主机中的各个虚机在同一网段中，可互相访问。外部无法直接访问虚机，但可通过主机的转接访问虚机。\n（3）仅主机模式：同一主机中的各个虚机可互相访问，虚机无法访问Internet，外部也无法访问虚机。\n6、I/O类型：默认LSI Logic，磁盘类型：默认SCSI，选择磁盘：创建新虚拟磁盘。\n7、分配20G虚拟磁盘空间，存为多个文件（默认选项）。没有勾选“立即分配所有磁盘空间”，会稍微影响虚机的速度。\n8、指定虚机磁盘文件，保持默认（拆分成多个文件）。方便虚拟机的拷贝。\n9、开始安装时，可能会提示要更改BIOS设置以支持64位操作系统之类的，按照提示修改主机BIOS设置，再回来安装。\n注意：一般新的电脑无需设置自动支持64位虚拟化，有些电脑需要在BIOS里设置以支持64位虚拟化，有些更旧的电脑完全不支持64位虚拟化，则无法在VMware里安装64位的操作系统。\n如上完成新建虚拟机设置。会出现该虚拟机配置画面，点击“编辑虚拟机设置”，打开对话框，核对硬件配置。如果CD/DVD是自动检测，则选择“使用ISO印象文件”，并选中Debian的安装镜像文件。\n然后点击上图中的“开启此虚拟机”，开始安装。\n开始安装后，窗口下面会出现“我已完成安装”，不要点，等安装完了再点。\n1.2 安装过程\n注意：安装过程中，鼠标点击虚机界面即可进入虚机操作，组合键ctrl + alt 可使鼠标返回主机。在VMware Workstation窗口的左下角会有提示。\n1、安装过程与在真实裸机上安装一样，初始界面选择**“Advanced options” - “Graphical expert Install”，非常重要！！！**，然后回车进入安装过程。选择图形expert模式可以设置静态IP地址，最重要的是可以跳过更新，否则要等很长时间，甚至安装失败。\n2、选择安装过程中的语言（也是安装后系统的默认语言）：选择English (English)，下一步，Location选other - Asia - China，然后locales选“en_US.UTF-8”，下一步Additional locales，勾上zh_CN.UTF-8，下一步System locale保持默认en_US.UTF-8\n3、然后blind person，speech synthesizer跳过，进入keyboard，保持默认American Englis，下一步\n4、进入Detect and mount installation media，保持默认勾选usb-storage，下一步，提示找到了，下一步，Installer components，列在这里的都是可选非必须的，直接下一步，\n5、进入Detect network hardware，下一步Configure the network，是否自动配置网络，选No，下一步，IP address填192.168.138.9，下一步，Netmask保持默认255.255.255.0，下一步，Gateway修改为192.168.138.2，下一步，Nameserver，默认和网关一样，确认192.168.138.2，下一步，列出所有网络配置，检查确认Yes，下一步，默认3次，下一步。注意：先到Vmware“虚拟网络编辑器”里看一下IP段，确认是192.168.x.x之后再设置IP地址，包括掩码（一般都是255.255.255.0）。\n6、配置Hostname：localhost，下一步，Domain name 填localdomain，下一步\n7、设置用户和密码，下一步，Yes - Enable shadow password，Yes - Allow login as root，下一步，设置root密码：4geT%not，下一步\n8、创建新用户：Yes，下一步，全名zadmin，下一步，用户名zadmin，下一步，设置密码d00r%Key，下一步\n9、设置时钟：Yes - Set the clock using NTP，下一步，保持默认，下一步，保持默认Asia/Shanghai，下一步\n10、检测磁盘 - 磁盘分区，默认Guided - use entire disk，下一步，保持默认，下一步，保持默认All files in one partition，下一步，完成分区并写入，下一步，Yes确认写入，下一步\n11、Install the base system，下一步，Kernel to install 保持默认，下一步，默认generic: include all available drivers，下一步，\n12、Configure the package manager，下一步，默认No - scan extra media，下一步， Yes - use a network mirror，下一步，选择https，下一步，默认manually，下一步\nmirror hostname填mirrors.tuna.tsinghua.edu.cn\nmirror directory保存默认/debian/，下一步\nHTTP proxy默认留空，下一步，yes - use non-free，下一步，默认Yes - Enable source … in APT，下一步，默认两项更新勾去掉，啥都不选（非常重要！！！），下一步\n13、Select and install software，下一步，默认No automatic updates，下一步，默认No - survey，下一步，只留SSH server和standard system utilities其他都不要，下一步\n14、Install GRUB boot loader，下一步，默认Yes - GRUB to primary drive，下一步，不要选第一项手工输入，选第二项/dev/sda，下一步，默认No - Force GRUB installation to the EFI removable media path，下一步\n15、Finish the installation，下一步，默认Yes - Is the system clock set to UTC，下一步，安装完成，提示移除光盘，下一步\n16、系统没有安装GUI，以root登录，安装完成。\n关闭虚拟机后，可以编辑虚拟机设置。把CD/DVD 改回为自动检测。\n关闭虚机后，可以编辑虚机设置，修改CPU核数，硬盘大小，内存等。\n小技巧：虚机屏幕有时候不匹配VMware的窗口，需要拉动窗口的滚动条才能看见全部的虚机屏幕内容。或者，虚机屏幕太小，Vmware经常自动改变窗口大小去适应虚机。从VMware菜单“编辑 - 首选项 - 显示”，把“自动适应窗口”前的勾去掉（自动适应下面的两个选项都不勾）。然后再开启此虚机，可解决这个问题。\n1.3 安装后设置\n1.3.1 更新数据源\nDebian的编辑器推荐nano，进入后编辑习惯比较像Windows记事本，下面提示了快捷键，Ctrl + o保存，下面提示保存的文件名，回车即可；Ctrl + x退出。\n1. 首先编辑数据源 nano /etc/apt/sources.list，把第一行 deb cdrom 注释掉，然后加入清华大学的数据源。安装的时候已经指定了清华大学的数据源，所以有两行，删除，将下面的内容复制进去。复制了文本内容后，在nano界面，从Vmware菜单“编辑”-“粘贴”可以直接将主机中复制的文本粘贴到虚机nano中。\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free\ndeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free\ndeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free\ndeb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free\ndeb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free\ndeb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free\n2. 要增加更多的镜像，可以在/etc/apt/sources.list.d/目录下建立 *.list 文件\nnano /etc/apt/sources.list.d/huawei.list\ndeb https://mirrors.huaweicloud.com/debian/ bullseye main non-free contrib\ndeb-src https://mirrors.huaweicloud.com/debian/ bullseye main non-free contrib\ndeb https://mirrors.huaweicloud.com/debian-security/ bullseye-security main\ndeb-src https://mirrors.huaweicloud.com/debian-security/ bullseye-security main\ndeb https://mirrors.huaweicloud.com/debian/ bullseye-updates main non-free contrib\ndeb-src https://mirrors.huaweicloud.com/debian/ bullseye-updates main non-free contrib\ndeb https://mirrors.huaweicloud.com/debian/ bullseye-backports main non-free contrib\ndeb-src https://mirrors.huaweicloud.com/debian/ bullseye-backports main non-free contrib\nnano /etc/apt/sources.list.d/ustc.list\ndeb https://mirrors.ustc.edu.cn/debian/ bullseye main contrib non-free\ndeb-src https://mirrors.ustc.edu.cn/debian/ bullseye main contrib non-free\ndeb https://mirrors.ustc.edu.cn/debian/ bullseye-updates main contrib non-free\ndeb-src https://mirrors.ustc.edu.cn/debian/ bullseye-updates main contrib non-free\ndeb https://mirrors.ustc.edu.cn/debian/ bullseye-backports main contrib non-free\ndeb-src https://mirrors.ustc.edu.cn/debian/ bullseye-backports main contrib non-free\ndeb https://mirrors.ustc.edu.cn/debian-security/ bullseye-security main contrib non-free\ndeb-src https://mirrors.ustc.edu.cn/debian-security/ bullseye-security main contrib non-free\n3. 如上添加了清华，华为，中科大三个镜像，更新数据源apt update，提示有若干可升级，升级apt upgrade\n4. apt与apt-get的区别\n尽快适应并使用apt，广大Linux发行商都在推荐。\n\n\n\napt 命令\n取代的命令\n命令的功能\n\n\n\n\napt install\napt-get install\n安装软件包\n\n\napt remove\napt-get remove\n移除软件包\n\n\napt purge\napt-get purge\n移除软件包及配置文件\n\n\napt update\napt-get update\n刷新存储库索引\n\n\napt upgrade\napt-get upgrade\n升级所有可升级的软件包\n\n\napt autoremove\napt-get autoremove\n自动删除不需要的包\n\n\napt full-upgrade\napt-get dist-upgrade\n在升级软件包时自动处理依赖关系\n\n\napt search\napt-cache search\n搜索应用程序\n\n\napt show\napt-cache show\n显示安装细节\n\n\n\n\n\n\n新的apt命令\n命令的功能\n\n\n\n\napt list\n列出包含条件的包（已安装，可升级等）\n\n\napt edit-sources\n编辑源列表\n\n\n\n从这里可以看出，刚才nano /etc/apt/sources.list命令可以用apt edit-sources命令替代，同样是打开nano编辑sources.list文件。\n1.3.2 关于用户\n目前系统里有2个用户，root是超级管理员；zadmin是系统管理员。\n系统提示符为 # 表明用户为root，提示符为$ 表明用户为其他用户。\n每个用户都有自己的主目录，以 ~表示，root用户是 /root，其他用户是 /home/用户名。例如zadmin输入命令 cd ~ 则会进入其主目录 /home/zadmin\nzadmin需要执行root权限的命令时，可以用 sudo 临时获得权限，也可以用 su 切换身份为root。\n使用sudo时，需要输入admin用户自己的密码，使用 su时，需要输入root用户的密码，使用“sudo su”则可以使用admin自己的密码切换到root用户身份，在root用户没有设置密码时，这个方法很好用。\n1. Debian默认没有安装sudo，安装apt install sudo\n2. 一般修改/etc/sudoers来增加zadmin，使其可以用sudo，打开此文件，首先提示此文件必须！！！由root用visudo命令打开；第二行推荐在/etc/sudoers.d/目录下添加文件的方式代替修改此文件；最后一行显示其包含了/etc/sudoers.d目录；最下面红色提示此文件为只读。可见，用nano修改此文件是不对的，也不要试图修改其只读属性再修改。\n方法1是在/etc/sudoers.d目录下新建一个zadmin的文件，内容为：\nzadmin ALL=(ALL)ALL\n方法2是将用户加入sudo组，本例用第2中方法。usermod是修改用户，参数-a是将用户添加到某个组，并且不删除此用户其他组身份，参数-G指定用户的组。\nusermod -aG sudo zadmin\n然后命令cat /etc/group查看各组情况，可以看到sudo组里已经有zadmin了，如果输出太多，一屏放不下，可以用more /etc/group翻页查看，空格显示下一页，或者less。\n然后切换身份su zadmin看看是否可用sudo\n1.3.3 配置静态IP地址\n第一步：确认Vmware网络配置\n菜单“编辑”-“虚拟网络编辑器”，这个界面，有很多网络文章说要修改，其实不用。选中列表里的Vmnet8（NAT模式），只需要看一下子网IP 192.168.138.0 及 子网掩码 255.255.255.0 记住就行了。“使用本地DHCP服务将IP地址分配给虚拟机”前面的勾不用去掉。\n然后确认一下虚拟机的网络适配器是否是NAT，安装的时候默认就是这项。如果不是，就在虚拟机关机状态下，编辑虚拟机设置，改为NAT。\n在Vmware里只需要确认上述配置就行了，不用做任何修改！\n第二步：在虚拟机设置静态IP\n本例在安装时已经配置了静态IP，下面确认一下配置，以后要修改的时候就知道去哪里修改。nano /etc/network/interfaces\n第一行source /etc/network/interfaces.d/*说明先执行这个目录下的脚本，文件名无所谓，特殊配置就放在这个目录下。\nauto ens33 这一行是新加的，说明随系统启动ens33网卡\niface ens33 inet static 这里的static说明是静态地址，否则dhcp表示动态分配\naddress 192.168.138.9/24 表示IP地址和掩码，24表示前3个8字节都为1，就是255.255.255.0的意思，同理8则表示255.0.0.0\ngateway 192.168.138.2 网关，Vmware下网关一定是 .2 而不是 .1\ndns-nameservers 192.168.138.2 与网关相同，也是 .2\n从上面的注释来看，dns的设置是从resolvconf来的，nano /etc/resolv.conf\n如果要修改dns的话就在这里改，或者增加新的dns。在Vmware局域网情况下，配置dns与网关一样即可，不需要添加任何其他dns，除非有特殊要求。\n第三步：重启网络服务\n本例中做了修改，则重启网络使配置生效\nservice networking restart\n第二步里如果没有加auto ens33这一行，就会发现网络起不来（大坑）\n从虚机ping www.baidu.com，消息滚动可以Ctrl + C 中断\n从主机ping 192.168.138.9 都OK说明网络配置一切正常。\n1.3.4 安装常用工具\n前提是网络连接没有问题。\n更新数据源：apt update 执行完会提示有多少软件包要更新，如果没有，则不需要执行更新系统的命令。\n更新系统所有软件包：apt upgrade\n**Debian默认没有防火墙！！！**如果要使用的话，可安装ufw，如何使用ufw设置防火墙可以参考：https://zhuanlan.zhihu.com/p/130943659\n因为是最小化安装，很多工具没有，dpkg -l packagename  可以查询软件包是否已安装，查询发现net-tools，perl，wget已经安装了。其他的安装一下：\napt install gcc zip unzip\n安装了上面的net-tools以后，就有ifconfig命令了，试一下\nifconfig\n可以看到自己的静态IP地址\n更新完毕后，可以重新启动一下系统 reboot\n1.3.5 使用vi的问题\n现象：在 Debian 下，初次使用 vi 的时候会有点问题，在编辑模式下使用方向键并不会使光标移动，而是在命令行中出现[A [B [C [D之类的字母，而且编辑错误的话也无法使用退格键，只能用 Delete 键来删除。\n原因：由于 Debian 预安装的是 tiny 版本，会导致我们在使用上产生上述的不便。\n解决方法：安装了 vim 的 full 版本之后，键盘的所有键在 vi 下就很正常了。\napt remove vim-common -y\napt install vim -y\n1.3.6 彩色显示文件夹\n使用ls列出文件夹和文件时，都是同一种颜色，无法区分\n对于某一用户来说，其 ~/.bashrc 里是只针对这个用户的环境变量设置。\n以root用户身份，nano ~/.bashrc\n有提示：如果希望ls有颜色，就将下面的注释去掉\n除了可以让ls有颜色外，还使命令ll表示ls -l，命令l表示ls -lA\n编辑完成，保存退出。然后exit退出系统再登录，就可以看到ls列表有颜色了。灰色表示文件（不同类型文件有不同颜色），深蓝表示目录，浅蓝表示链接目录。\n1.4 用Putty连接虚拟机上传下载文件\n第一步：虚机允许root远程登录\n命令nano /etc/ssh/sshd_config，修改如下，增加了一行PermitRootLogin yes，允许root用户远程登录；然后顺便把PubkeyAuthentication yes前的注释去掉了，允许使用密钥的方式远程登录，后面用得到。重启SSH服务service sshd restart\n第二步：下载安装Putty并连接\n到Putty官网https://putty.org/，选第一个Download PuTTY，下面是第三方项目。\n下载64-bit x86版本，形如putty-64bit-0.77-installer.msi的安装文件。\n安装完成后，有多个程序，首先运行Putty，输入IP地址，点open就可以连接。\n连接后以root身份登录，可以看到显示的主机IP是192.168.138.1，命令exit可以退出登录，断开连接。\n然后运行PSFTP，窗口中输入open 192.168.138.11 进行连接，以root登录，可以看到提示当前工作路径是 /root，命令exit可以退出登录，断开连接。\n以后可以在虚拟机开机状态下，关闭Vmware，选择让虚拟机后台运行，然后用Putty连接进行操作，上传下载文件。\n需要在虚拟机里安装JDK，安装文件为主机 D:\\software\\ jdk-8u341-linux-x64.tar.gz，这个文件是事先从Oracle网站下载来的。打开PSFTP连接，root登录。使用put命令将文件上传到虚拟机 /root 目录下。注意路径分隔符使用 / 而不是Windows风格的 \\，然后ls命令查看虚拟机上是否有这个文件了。exit退出，断开连接。\n1.6 密钥方式连接虚机\n密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。\n第一步：制作密钥对\n在虚机上制作密钥对。首先用root登录，然后执行以下命令：\nssh-keygen  &lt;== 建立密钥对\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/root/.ssh/id_rsa): &lt;== 回车\nCreated directory ‘/root/.ssh’.\nEnter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，或回车\nEnter same passphrase again: &lt;== 再输入一遍密钥锁码，回车\nYour identification has been saved in /root/.ssh/id_rsa. &lt;== 私钥\nYour public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 公钥\nThe key fingerprint is:\n…\nThe key’s randomart image is:\n…\n现在，在 /root 生成了一个 .ssh 的隐藏目录，内含两个密钥文件，id_rsa 为私钥，id_rsa.pub 为公钥。\n密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。本例中没有密钥锁码，方便使用。\n第二步：在虚机上安装公钥\n键入以下命令，在服务器上安装公钥：\ncd .ssh\ncat id_rsa.pub &gt;&gt; authorized_keys\n如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：\nchmod 600 authorized_keys\nchmod 700 ~/.ssh\n第三步：虚机开启密钥登录\n在“1.4用Putty连接虚拟机上传下载文件”中第一步已经开启了密钥登录。\n第三步：用PSFTP下载私钥到主机\n用PSFTP密码登录方式连接虚机，下载id.rsa到本地重命名192.168.138.9.rsa\n第四步：将密钥导入到Putty\n首先打开PuttyGen，点Load按钮，选择文件对话框里的文件类型默认是*.ppk，改为*.*，找到刚才的192.168.138.9.rsa，就导入成功了，提示是旧的pem格式。\n然后点击Save private key，保存为192.168.138.9.ppk，与刚才的文件最好在同一文件夹下，询问是否要个锁码，不理他。\n关闭PuttyGen，打开Putty，左侧选择Session，右边填写Host Name为root@192.168.138.9，这里指定了登录用户为root，如果为其他用户则改为其他用户名。然后下面Saved Sessions空格里填上一个名字deb-192.168.138.9，点右侧Save就保存了。\n然后左侧Connection - SSH - Auth，直接点Auth不用展开，右边Browse找到刚才保存的192.168.138.9.ppk\n回到上一张图的Session，选中deb-192.168.138.9的情况下，点Save，一定要保存，否则下次又要找密钥。然后点下面的Open就连接成功了，不需要输入密码，直接root登录成功。\n今后要连接的时候，打开Putty，选中保存的deb-192.168.138.9，点Load，然后点下面的Open就可以连接上了。\n主机运行Putty组件Pageant，会在Windows右下角出现一个常驻的代理，从中可以快速连接已经保存的session或者进行一些密钥操作。\n1.7 安装JDK8\n前面“1.4 用Putty连接虚拟机上传下载文件”已经把JDK安装文件上传到 /root目录下了。创建目录 /usr/java ：mkdir /usr/java\n进入/root：cd /root\n解压文件到 /usr/java：tar -zxvf jdk-8u341-linux-x64.tar.gz -C /usr/java\ncd /usr/java\n看到已经有了一个文件夹jdk1.8.0_341，创建一个软链接，使访问简便。并且有多个版本的jdk存在时，切换只修改修改default的链接就行了，不需要再修改/etc/profile\nln -s jdk1.8.0_341 default\n在/usr/java/下就生成了文件夹default，实际是jdk1.8.0_341的链接，访问default就和访问jdk1.8.0_341一样。\n修改/etc/profile：nano /etc/profile\n在文件最后添加\nexport JAVA_HOME=/usr/java/default\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport PATH=$PATH:$JAVA_HOME/bin\n注意CLASSPATH=后面是个英文句号，这样设置可以解决很多命令行下运行java程序找不到类的问题。\n保存，退出，更新：source /etc/profile\n执行下面命令验证各变量正确：\necho $JAVA_HOME\necho $CLASSPATH\njava -version\n二、Debian11安装MySQL\n2.1 克隆虚机\n上一章已经创建了一个虚机deb-min，更新了系统，安装了常用工具，设置了密钥连接，安装了JDK8，为此虚机创建一个快照。菜单“虚拟机 - 快照 - 拍摄快照”，输入名字和描述就行了。\n菜单“虚拟机 - 管理 - 克隆”，克隆源选择“现有快照”，找到刚才拍摄的快照。\n克隆类型选择“创建完整克隆”\n输入虚机名称deb-mysql，确认保存位置，完成。\n2.2 设置虚机\n开启新的虚机deb-mysql，以root登录，首先要修改的是静态IP地址。\nnano /etc/network/interfaces\n将静态IP地址改为192.168.138.21就行了，其他的不用动。\nnano /etc/hosts\n将IP地址改为192.168.138.21就行了，其他的不用动。\n重启网络服务service networking restart\n虚机ping www.baidu.com，主机ping 192.168.138.21都OK\n参照“1.6密钥方式连接虚机”，打开Putty，在Session里新建保存一个名称为mysql-192.168.138.21，连接地址为root@192.168.138.21，左侧Connection - SSH - Auth，直接点Auth不用展开，右边Browse找到刚才保存的192.168.138.9.ppk（就是这个旧的密钥，不需要到虚机上创建新的密钥对了，因为是克隆的，所有信息都一样）\nSave，Open 连接成功。\n一般安全起见，新的虚机要创建新的密钥对。本例直接使用了旧的密钥，简便。\n2.3 安装MySQL\n2.3.1 安装MySQL8\n到MySQL官网，下载MySQL APT Repository，操作系统是Debian 11，要安装的MySQL8.0，因此下载到的对应版本是mysql-apt-config_0.8.24-1_all.deb\n下载需要登录。注册一个免费的MySQL或Oracle账号即可，以后用得着。\n用PSFTP将文件上传到虚机 /root 目录下。\n参考https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/官网步骤\n先把这个文件换个地方：mv mysql-apt-config_0.8.24-1_all.deb /opt/\n然后进/opt安装，因为有一次报错说_apt用户进不了/root因为权限不够\n安装APT库：apt install ./mysql-apt-config_0.8.24-1_all.deb\n有错误提示，也不管了 …\n升级软件源apt update\n安装MySQL：apt install mysql-server\n中间设置root密码，输入sql=R00T两次，然后关于加密选项，保持默认回车即可。然后居然就安装完了，没有报错。\n查询mysql的状态systemctl status mysql.service，居然是active\n如果是inactive（active是绿色的）则启动之systemctl start mysql.service\n启动完毕再查询状态systemctl status mysql.service，正常\n用安装过程中设置的密码sql=R00T登录mysql，如下命令\nmysql -u root -p\n进入MySQL后，show databases; 正常。命令quit或exit退出MySQL\nDebian没有防火墙，不用管开启3306端口的事。\n重启虚机reboot，查询mysqld的状态systemctl status mysql.service\n发现是active的，说明MySQL服务是随系统启动而启动的，一切正常。\n到此，MySQL安装完毕，初始化配置root密码完毕。关闭虚机，拍摄快照，启动虚机，以后没事就不再安装MySQL了。\n（1）此虚机将作为数据库服务器长期保持运行，关闭Vmware界面时让其后台运行。今后操作MySQL以远程为主，比如用IDEA里的database navigator\n（2）MySQL有其备份方式，定期备份保障数据安全。另外，此虚机也可定期拍摄快照，如遇系统级故障，可以用快照恢复。\n2.3.2 特殊故障\nMySQL一段时间不操作则服务停掉。有时几天，有时十几天。\n参考解决方法：https://124654439.iteye.com/blog/2174953\n注意该文章的后半部分，否则就白看了。关键点是修改参数要带 global\n以root身份连接登录进mysql\nmysql&gt; show global variables like ‘wait_timeout’;\nmysql&gt; set global interactive_timeout= 31536000;\nmysql&gt; set global wait_timeout=31536000;\n在MySQL8.1的版本有这个问题，此方法可以解决。\n如果没这个问题，则略过。\n2.3.3 建立数据库、用户、表、数据\n数据库服务器建好后，一般远程操作。这里仅展示在服务器上的基本操作。\n本例中建立的库、用户、表、数据是为了配合前面的Spring Boot案例。\n用root登录MySQL，建立一个数据库ssm_db，建立一个用户ssmaster，然后把数据库ssm_db的所有权限赋予ssmaster\nmysql -u root -p\n输入root的密码登录，下面的命令都是MySQL里了（在MySQL命令行，也可以通过Vmware菜单“编辑”-“粘贴”进行文本粘贴，不需要输入。快捷键Ctrl + v也可以用，注意此时光标不要在虚机输入界面）\nmysql&gt; create database ssm_db DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;\nmysql&gt; create user ssmaster@‘%’ identified by ‘1gE=M!ka’;\nmysql&gt; create user ssmaster@localhost identified by ‘1gE=M!ka’;\nmysql&gt; grant all on ssm_db.* to ssmaster@‘%’;\nmysql&gt; grant all on ssm_db.* to ssmaster@localhost;\nmysql&gt; quit;\n库和用户都建好了，然后用ssmaster登录MySQL\nmysql -u ssmaster -p\n输入用户ssmaster的密码，下面的命令都是MySQL里了\nmysql&gt; use ssm_db;\nmysql&gt; CREATE TABLE IF NOT EXISTS tbl_book(id INT UNSIGNED AUTO_INCREMENT,type VARCHAR(100) NOT NULL,name VARCHAR(100) NOT NULL,description VARCHAR(200),PRIMARY KEY (id))DEFAULT CHARSET=utf8;\nmysql&gt; INSERT INTO tbl_book(type,name,description) VALUES (‘novel’,’Learning Spring Boot’,’How to coding with Spring Boot.’);\nmysql&gt; select * from tbl_book;\n可以看到表建好了，并且插入了一条数据。id是自增的，不需要输入。\nmysql&gt; quit;\n2.3.4 远程操作数据库\nIDEA社区版安装Database Navigator插件就可以远程操作数据库了。\n一般工具栏在左侧，点开后，点绿色 + 号新建一个MySQL连接如下。输入Name不一定要与数据库名一致，Description可以留空，Host填写IP地址，确认端口号是3306，Database填上面创建的库ssm_db，下面的用户名密码填上面创建的用户名密码，Driver用内置库。可以先点Test Connection按钮测试一下连接，显示成功。然后点最下面的OK，这个数据库连接就完成了。\n连接建好后，就可以看到ssm_db的整个结构，并可以进行建表，修改数据等操作。\n一般对数据库进行操作，是通过SQL方式。点击Open SQL console按钮打开SQL的控制台，在控制台输入如下，插入一条数据\ninsert into tbl_book(type,name,description) VALUES (‘技术’,’大学物理’,’全国通用大学物理教程’);\n点Execute Statement就可以执行这条SQL语句。执行完毕，就生效了，另外两个按钮Commit和Rollback还亮着，说明这条SQL语句还没有正式提交数据库，可以回滚。点击Commit按钮正式提交，然后Commit和Rollback两个按钮就灰了。\n再输入select * from tbl_book; 执行，就可以看到查询出的数据。\n2.4 MySQL Workbench\nMySQL数据库安装在Linux服务器上，直接在服务器上操作不方便。主流的操作方式是使用客户端进行可视化的远程操作。\nMySQL自己的客户端工具MySQL Workbench是免费的，功能强大。\nhttps://www.mysql.com/products/workbench/去下载，选择Windows 64位操作系统，下载到的msi安装文件形如mysql-workbench-community-8.0.31-winx64.msi\n安装之后，打开的首页按“+”创建一个连接。填上连接的名字，IP地址，确认端口3306，username填root，下面password点开对话框填入root（MySQL的root用户）的密码，然后点test connection，发现拒绝连接。\n拒绝连接的原因，“2.3.1 安装MySQL8”的时候只有一个用户 root@localhost，远程连接来自localhost以外的域会认为不是这个用户，就会被拒绝。创建一个新用户root@%并赋予其全部权限即可。注意root@%与root@localhost密码一样，以免混淆。\n解决方法：以root登录服务器CentOS，以MySQL的root用户登录MySQL\n增加用户 create user ‘root’@’%’ identified by ‘sql=R00T’;\n赋予最高权限 grant all on *.* to ‘root’@’%’;\nquit; 退出MySQL\n再打开MySQL workbench就可以正常连接了。左侧窗口选择下面的标签Schemas就可以看到数据库列表，展开ssm_db就可以看到各个表，选中tbl_book，在右侧就能看到这个表里的数据，可以直接修改表数据，修改完后点Apply按钮，就会弹出一个对应你操作的SQL语句，确认OK，修改就生效了。\nSQL Workbench一般用在项目的中后期，运维期等。可以很方便可视化的增删改查数据，如果用户身份是root或者是对应库的管理员，则可以很方便的对库、表、字段、视图、触发器、函数进行可视化的调整，备份或导入数据库，非常方便。\n附录一、Debian常用命令\n1.1 apt\n列出所有可更新的软件清单命令：sudo apt update\n升级软件包：sudo apt upgrade\n列出可更新的软件包及版本信息：apt list --upgradeable\n升级软件包，升级前先删除需要更新软件包：sudo apt full-upgrade\n安装指定的软件命令：sudo apt install &lt;package_name&gt;\n安装多个软件包：sudo apt install &lt;package_1&gt; &lt;package_2&gt; &lt;package_3&gt;\n更新指定的软件命令：sudo apt update &lt;package_name&gt;\n显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：sudo apt show &lt;package_name&gt;\n删除软件包命令：sudo apt remove &lt;package_name&gt;\n清理不再使用的依赖和库文件：sudo apt autoremove\n移除软件包及配置文件：sudo apt purge &lt;package_name&gt;\n查找软件包命令：sudo apt search \n列出所有已安装的包：apt list --installed\n列出所有已安装的包的版本信息：apt list --all-versions\n1.2 systemctl\n1.2.1 Systemd初体验和Systemctl基础\n1. 首先检查你的系统中是否安装有systemd并确定当前安装的版本\n# systemctl --version\n2. 检查systemd和systemctl的二进制文件和库文件的安装位置\n# whereis systemd\n# whereis systemctl\n3. 检查systemd是否运行\n# ps -eaf | grep [s]ystemd\n注意：systemd是作为父进程（PID=1）运行的。在上面带（-e）参数的ps命令输出中，选择所有进程，（-a）选择除会话前导外的所有进程，并使用（-f）参数输出完整格式列表（即 -eaf）。\n也请注意上例中后随的方括号和例子中剩余部分。方括号表达式是grep的字符类表达式的一部分。\n4. 分析systemd启动进程\n# systemd-analyze\n5. 分析启动时各个进程花费的时间\n# systemd-analyze blame\n6. 分析启动时的关键链\n# systemd-analyze critical-chain\n重要：Systemctl接受服务（.service），挂载点（.mount），套接口（.socket）和设备（.device）作为单元。\n7. 列出所有可用单元\n# systemctl list-unit-files\n8. 列出所有运行中单元\n# systemctl list-units\n9. 列出所有失败单元\n# systemctl --failed\n10. 检查某个单元（如 cron.service）是否启用\n# systemctl is-enabled crond.service\n11. 检查某个单元或服务是否运行\n# systemctl status firewalld.service\n1.2.2 使用Systemctl控制并管理服务\n12. 列出所有服务（包括启用的和禁用的）\n# systemctl list-unit-files --type=service\n13. Linux中如何启动、重启、停止、重载服务以及检查服务（如 httpd.service）状态\n# systemctl start httpd.service\n# systemctl restart httpd.service\n# systemctl stop httpd.service\n# systemctl reload httpd.service\n# systemctl status httpd.service\n注意：当我们使用systemctl的start，restart，stop和reload命令时，我们不会从终端获取到任何输出内容，只有status命令可以打印输出。\n14. 如何激活服务并在启动时启用或禁用服务（即系统启动时自动启动服务）\n# systemctl is-active httpd.service\n# systemctl enable httpd.service\n# systemctl disable httpd.service\n15. 如何屏蔽（让它不能启动）或显示服务（如 httpd.service）\n# systemctl mask httpd.service\n# systemctl unmask httpd.service\n16. 使用systemctl命令杀死服务\n# systemctl kill httpd\n# systemctl status httpd\n1.2.3 使用Systemctl控制并管理挂载点\n17. 列出所有系统挂载点\n# systemctl list-unit-files --type=mount\n18. 挂载、卸载、重新挂载、重载系统挂载点并检查系统中挂载点状态\n# systemctl start tmp.mount\n# systemctl stop tmp.mount\n# systemctl restart tmp.mount\n# systemctl reload tmp.mount\n# systemctl status tmp.mount\n19. 在启动时激活、启用或禁用挂载点（系统启动时自动挂载）\n# systemctl is-active tmp.mount\n# systemctl enable tmp.mount\n# systemctl disable  tmp.mount\n20. 在Linux中屏蔽（让它不能启用）或可见挂载点\n# systemctl mask tmp.mount\n# systemctl unmask tmp.mount\n1.2.4 使用Systemctl控制并管理套接口\n21. 列出所有可用系统套接口\n# systemctl list-unit-files --type=socket\n22. 在Linux中启动、重启、停止、重载套接口并检查其状态\n# systemctl start cups.socket\n# systemctl restart cups.socket\n# systemctl stop cups.socket\n# systemctl reload cups.socket\n# systemctl status cups.socket\n23. 在启动时激活套接口，并启用或禁用它（系统启动时自启动）\n# systemctl is-active cups.socket\n# systemctl enable cups.socket\n# systemctl disable cups.socket\n24. 屏蔽（使它不能启动）或显示套接口\n# systemctl mask cups.socket\n# systemctl unmask cups.socket\n1.2.5 服务的CPU利用率（分配额）\n25. 获取当前某个服务的CPU分配额（如httpd）\n# systemctl show -p CPUShares httpd.service\n注意：各个服务的默认CPU分配份额=1024，你可以增加/减少某个进程的CPU分配份额。\n26. 将某个服务（httpd.service）的CPU分配份额限制为2000 CPUShares/\n# systemctl set-property httpd.service CPUShares=2000\n# systemctl show -p CPUShares httpd.service\n注意：当你为某个服务设置CPUShares，会自动创建一个以服务名命名的目录（如 httpd.service），里面包含了一个名为90-CPUShares.conf的文件，该文件含有CPUShare限制信息，你可以通过以下方式查看该文件：\n27. 检查某个服务的所有配置细节\n# systemctl show httpd\n28. 分析某个服务（httpd）的关键链\n# systemd-analyze critical-chain httpd.service\n29. 获取某个服务（httpd）的依赖性列表\n# systemctl list-dependencies httpd.service\n30. 按等级列出控制组\n# systemd-cgls\n31. 按CPU、内存、输入和输出列出控制组\n# systemd-cgtop\n1.2.6 控制系统运行等级\n32. 启动系统救援模式\n# systemctl rescue\n33. 进入紧急模式\n# systemctl emergency\n34. 列出当前使用的运行等级\n# systemctl get-default\n35. 启动运行等级3，即多用户模式（命令行）\n# systemctl isolate runlevel3.target\n# systemctl isolate multiuser.target\n36. 设置多用户模式或图形模式为默认运行等级\n# systemctl set-default runlevel3.target\n# systemctl set-default runlevel5.target\n37. 重启、停止、挂起、休眠系统或使系统进入混合睡眠\n# systemctl reboot\n# systemctl halt\n# systemctl suspend\n# systemctl hibernate\n# systemctl hybrid-sleep\n对于不知运行等级为何物的人，说明如下。\n\nRunlevel 0 : 关闭系统\nRunlevel 1 : 救援？维护模式\nRunlevel 3 : 多用户，无图形系统\nRunlevel 4 : 多用户，无图形系统\nRunlevel 5 : 多用户，图形化系统\nRunlevel 6 : 关闭并重启机器\n\n","categories":["Linux专题"],"tags":["Linux"]},{"title":"k8s集群搭建教程（使用cri-docker+flannel）","url":"/2024/05/04/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","content":"k8s集群搭建教程（使用cri-docker+flannel）\n1. 准备工作（所有节点）\n1.1 系统环境(我是没配置也部署成功了，可以先部署，如果失败了再回来进行系统环境优化)\n\n系统环境优化配置\n\nCentOs 7.x系统自带的3.10.x内核存在一些bug，导致运行的docker，kubernetes不稳定，获取源：\nrpm -Uvh http://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm\n\n安装内核，装完成后检查 /boot/grub2/grub.cfg中对应内核menuentry中是否包含 initrd16 配置，如果没有，再安装一次！耗时可能会有点久\n\nyum --enablerepo=elrepo-kernel install -y kernel-lt \n#查看系统的全部内核rpm -qa | grep kernel#kernel-3.10.0-1160.el7.x86_64#kernel-lt-5.4.271-1.el7.elrepo.x86_64#kernel-tools-libs-3.10.0-1160.el7.x86_64#kernel-tools-3.10.0-1160.el7.x86_64#设置开机从新内核启动grub2-set-default &#x27;CentoS Linux(5.4.271-1.el7.elrepo.x86_64) 7 (Core)&#x27;reboot#查看正在使用的内核uname -r\n1.2 系统参数设置\n\n所有节点关闭swap和防火墙\n\nsystemctl stop firewalldsystemctl disable firewalld#临时关闭swapoffswapoff -a#永久关闭swapoff（如果想永久关闭，将下面命令的#去掉）#sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab\n\n禁用SELINUX\n\nsetenforce 0sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config\n\n所有节点设置主机名\n\nhostnamectl set-hostname  k8s-masterhostnamectl set-hostname  k8s-node1hostnamectl set-hostname  k8s-node2\n\n所有节点主机名/IP加入hosts解析\n\nvi /etc/hosts加入如下内容：192.168.183.132 k8s-master192.168.183.133 k8s-node1192.168.183.134 k8s-node2\n\n所有节点配置k8s内核\n\ncat &gt; kubernetes.conf &lt;&lt;EOFnet.bridge.bridge-nf-call-iptables=1net.bridge.bridge-nf-call-ip6tables=1net.ipv4.ip_forward=1net.ipv4.tcp_tw_recycle=0vm.swappiness=0 #禁止使用swap空间，只有当系统OOM时才允许使用它vm.overcommit_memory=1 #不检查物理内存是否够用vm.panic_on_oom=0 #开启OOMfs.inotify.max_user_instances=8192fs.inotify.max_user_watches=1048576fs.file-max=52706963fs.nr_open=52706963net.ipv6.conf.all.disable_ipv6=1net.netfilter.nf_conntrack_max=2310720net.ipv4.tcp_keepalive_time = 600net.ipv4.tcp_keepalive_probes = 3net.ipv4.tcp_keepalive_intvl =15net.ipv4.tcp_max_tw_buckets = 36000net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_max_orphans = 327680net.ipv4.tcp_orphan_retries = 3net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_syn_backlog = 16384net.ipv4.ip_conntrack_max = 65536net.ipv4.tcp_max_syn_backlog = 16384net.ipv4.tcp_timestamps = 0net.core.somaxconn = 16384EOFcp kubernetes.conf /etc/sysctl.d/kubernetes.confsysctl -p /etc/sysctl.d/kubernetes.conf\n\nlimit优化\n\nulimit -SHn 65535 cat &lt;&lt;EOF &gt;&gt; /etc/security/limits.confsoft nofile 655360hard nofile 131072soft nproc 655350hard nproc 655350soft memlock unlimitedhard memlock unlimitedEOF\n2. 组件安装（所有节点）\n2.1 Docker安装\n如果你的系统未安装过Docker，直接按照下面步骤操作即可。如果之前安装过，请先自行百度卸载干净。\n\n安装软件包并设置存储库\n\nyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n安装Docker\n\nyum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\n启动Docker\n\nsystemctl start dockersystemctl enable dockerdocker info\n\n创建 /etc/docker目录\n\nmkdir /etc/docker #配置daemoncat &gt; /etc/docker/daemon.json &lt;&lt;EOF&#123;    &quot;exec-opts&quot;:[&quot;native.cgroupdriver=systemd&quot;],    &quot;log-driver&quot;:&quot;json-file&quot;,    &quot;log-opts&quot;:&#123;        &quot;max-size&quot;:&quot;100m&quot;    &#125;&#125;EOF\nmkdir -p /etc/systemd/system/docker.service.d #重启docker服务systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl enable docker\n\n注意事项\n\nkubernetes 1.24+版本之后，docker必须要加装cir-docker\n2.2 安装cri-docker\ngo安装\n\n下载\n\nwget https://golang.google.cn/dl/go1.20.12.linux-amd64.tar.gz\n#安装gorm -rf /usr/local/go &amp;&amp; tar -C /usr/local/ -xzvf go1.20.12.linux-amd64.tar.gz \n\n设置环境变量\n\nvi /etc/profile添加以下内容到profile 文件中（gopath应提前创建好，或者配置完成后别忘了创建）#go settingexport GOROOT=/usr/local/goexport GOPATH=/usr/local/gopathexport PATH=$PATH:$GOROOT/bin#保存退出执行source /etc/profile\n构建cri-dockerd\ngit clone https://github.com/Mirantis/cri-dockerd.git\n编译\ncd cri-dockerdmkdir bingo build -o bin/cri-dockerdmkdir -p /usr/local/bininstall -o root -g root -m 0755 bin/cri-dockerd /usr/local/bin/cri-dockerdcp -a packaging/systemd/* /etc/systemd/systemsed -i -e &#x27;s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,&#x27; /etc/systemd/system/cri-docker.service\nKubernetes使用\n\n编辑：\n\nvi /etc/systemd/system/cri-docker.service\n在ExecStart后面追加，如：\nExecStart=/usr/local/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9\n\n创建cri-docker启动文件，然后拷贝到其他节点\n\nvi /usr/lib/systemd/system/cri-docker.service[Unit]Description=CRI Interface for Docker Application Container EngineDocumentation=https://docs.mirantis.comAfter=network-online.target firewalld.service docker.serviceWants=network-online.targetRequires=cri-docker.socket [Service]Type=notifyExecStart=/usr/bin/cri-dockerd --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9ExecReload=/bin/kill -s HUP $MAINPIDTimeoutSec=0RestartSec=2Restart=always StartLimitBurst=3 StartLimitInterval=60s LimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinity TasksMax=infinityDelegate=yesKillMode=process [Install]WantedBy=multi-user.target\nvi /usr/lib/systemd/system/cri-docker.socket[Unit]Description=CRI Docker Socket for the APIPartOf=cri-docker.service [Socket]ListenStream=%t/cri-dockerd.sockSocketMode=0660SocketUser=rootSocketGroup=docker [Install]WantedBy=sockets.target\nscp /usr/lib/systemd/system/cri-docker.service /usr/lib/systemd/system/cri-docker.socket root@k8s-node1:/usr/lib/systemd/system/ scp /usr/lib/systemd/system/cri-docker.service /usr/lib/systemd/system/cri-docker.socket root@k8s-node2:/usr/lib/systemd/system/\n\n启动cri-docker并设置开机自动启动\n\nsystemctl daemon-reload ; systemctl enable cri-docker --now#查看状态systemctl is-active cri-docker\n2.3 所有节点安装 kubeadm，kubelet 和 kubectl\ncat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOFsetenforce 0yum install -y kubelet kubeadm kubectlsystemctl enable kubelet &amp;&amp; systemctl start kubelet\n\n设置kubelet开机自启\n\nsystemctl enable --now kubelet.service\n3. 搭建k8s集群\n3.1 k8s初始化\n\n在master上初始化k8s\n\nkubeadm init \\--apiserver-advertise-address=192.168.183.132 \\--image-repository=registry.aliyuncs.com/google_containers \\--kubernetes-version=v1.28.2 \\--service-cidr=10.96.0.0/12  \\--pod-network-cidr=10.244.0.0/16 \\--cri-socket=unix:///var/run/cri-dockerd.sock\n\n按照提示创建kubeconfig文件\n\nmkdir -p $HOME/.kubecp -i /etc/kubernetes/admin.conf $HOME/.kube/configchown $(id -u):$(id -g) $HOME/.kube/config\n\n重新初始化\n\nkubeadm reset --cri-socket /var/run/cri-dockerd.sock rm -rf .kube/sudo mkdir ~/.kubesudo cp /etc/kubernetes/admin.conf ~/.kube/cd ~/.kubemv admin.conf configsystemctl restart kubelet\n3.2 node节点的加入\n\n加入节点\n\n在node节点如k8s-node1上执行：\nkubeadm join kubeadm初始化成功后的token --cri-socket /var/run/cri-dockerd.sock例如我的kubeadm初始化成功后的token为：192.168.183.132:6443 --token vib96t.hmkd7hj7ykdigmp1 --discovery-token-ca-cert-hash sha256:c0bb3a82a4642cc4fe253edd0533ad8136b34dc243f274aa3cea27abc46e321f\n\n查看节点状态\n\nkubectl get nodes此时所有节点的状态为NotReady，这是因为还没有安装flannel网络插件\n\n网络插件下载并安装\n\n#如果网络故障也可直接在网站中下载好文件后上传至虚拟机中（自行翻墙）wget https://github.com/flannel-io/flannel/releases/download/v0.24.3/kube-flannel.yml#执行kubectl apply -f kube-flannel.yml#或者（两者的结果是一样的，只是执行工作原理不一样，想深究的可以自行查阅资料）kubectl create -f kube-flannel.yml\n\n再次查看节点状态全部变为 Ready\n\nkubectl get nodes#如果查看节点没有变成ready，先等个几分钟，因为网络传输需要一定的时间。等几分钟后如果还是NotReady，再根据报错原因查找解决方案\n","tags":["kubernetes","go","docker"]},{"title":"k8s集群搭建常见问题汇总","url":"/2024/05/04/kubeadm%E6%90%AD%E5%BB%BAKubernetes%E9%9B%86%E7%BE%A4%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","content":"kubeadm搭建Kubernetes集群问题汇总\n问题一：kubeadm init 报错 [ERROR CRI]: container runtime is not running需要使用的解决方法\n\nkubernetes使用crictl命令管理CRI，查看其配置文件/etc/crictl.yaml。初始情况下没有这个配置文件，这里建议添加这个配置，否则kubeadm init时会报其他错。\n\n#containered做进行时cat &gt; /etc/crictl.yaml &lt;&lt;EOFruntime-endpoint: unix:///var/run/containerd/containerd.sockimage-endpoint: unix:///var/run/containerd/containerd.socktimeout: 0debug: falsepull-image-on-create: falseEOF#cri-docker做进行时cat &gt; /etc/crictl.yaml &lt;&lt;EOFruntime-endpoint: unix:///var/run/cri-dockerd.sockimage-endpoint: unix:///var/run/cri-dockerd.socktimeout: 0debug: falsepull-image-on-create: falseEOF#执行crictl images list命令不报错crictl images list\n\n查看配置文件：/etc/containerd/config.toml\n\n修改 disabled_plugins = [&quot;cri&quot;]为 disabled_plugins = []\n重启containerd\nsystemctl restart containerd\n问题二：ERROR FileContent–proc-sys-net-bridge-bridge-nf-call-iptables\n报错原因：网桥过滤和地址转发功能不可用\n解决方法\ncat &gt; /etc/sysctl.d/kubernetes.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1EOF# 然后执行,生效sysctl --system\n如果执行上述命令报/proc/sys/net/bridge/bridge-nf-call-iptables does not exist错误是因为网桥功能未开启，执行下面的命令即可\nmodprobe br_netfilter\n问题三：kubelet报错failed to run Kubelet: running with swap on is not supported\nswapoff -a\n问题四：kubeadm init时报错一些配置文件已存在\n解决方法：\nkubeadm reset\n问题五：kubeadm init时，kubelet 报错crictl --runtime-endpoint配置不对\n从日志看出时crictl命令运行时有问题。unix:///var/run/containerd/containerd.sock不存在。运行crictl命令，发现同样报错。出现报错的原因是crictl下载镜像时使用的是默认端点[unix:///var/run/dockershim.sock unix:///run/containerd/containerd.sock unix:///run/crio/crio.sock unix:///var/run/cri-dockerd.sock]。这些端点废弃了，需要重新指定containerd.sock。后面的报错就是找不到dockershim.sock。\n解决方法：修改crictl文件\n#containered做进行时cat &gt; /etc/crictl.yaml &lt;&lt;EOFruntime-endpoint: unix:///var/run/containerd/containerd.sockimage-endpoint: unix:///var/run/containerd/containerd.socktimeout: 0debug: falsepull-image-on-create: falseEOF#cri-docker做进行时cat &gt; /etc/crictl.yaml &lt;&lt;EOFruntime-endpoint: unix:///var/run/cri-dockerd.sockimage-endpoint: unix:///var/run/cri-dockerd.socktimeout: 0debug: falsepull-image-on-create: falseEOF#执行crictl images list命令不报错crictl images list\n问题六：报Usage of CRI endpoints without URL scheme is deprecated and can cause kubelet errors in the future.警告\nW0504 10:46:57.238606    6046 initconfiguration.go:120] Usage of CRI endpoints without URL scheme is deprecated and can cause kubelet errors in the future. Automatically prepending scheme “unix” to the “criSocket” with value “/var/run/cri-dockerd.sock”. Please update your configuration!\n如果是contained做进行时就执行：\nsudo crictl config \\--set runtime-endpoint=unix:///var/run/containerd/containerd.sock \\--set image-endpoint=unix:///var/run/containerd/containerd.sock#或者cat &gt; /etc/crictl.yaml &lt;&lt;EOFruntime-endpoint: unix:///var/run/containerd/containerd.sockimage-endpoint: unix:///var/run/containerd/containerd.socktimeout: 0debug: falsepull-image-on-create: falseEOF\n如果时cri-docker做进行时就执行：\nsudo crictl config \\--set runtime-endpoint=unix:///var/run/cri-dockerd.sock \\--set image-endpoint=unix:///var/run/cri-dockerd.sock#或者cat &gt; /etc/crictl.yaml &lt;&lt;EOFruntime-endpoint: unix:///var/run/cri-dockerd.sockimage-endpoint: unix:///var/run/cri-dockerd.socktimeout: 0debug: falsepull-image-on-create: falseEOF\n问题七：报错pause镜像获取失败\n通过log提示执行命令crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock ps -a 发现没有容器在运行。查看containerd的日志，有如下报错：\njournalctl -fu containerd...Oct 11 08:35:16 master.k8s containerd[1903]: time=&quot;2023-10-11T08:35:16.760026536+08:00&quot; level=error msg=&quot;RunPodSandbox for &amp;PodSandboxMetadata&#123;Name:kube-apiserver-node,Uid:a5a7c15a42701ab6c9dca630e6523936,Namespace:kube-system,Attempt:0,&#125; failed, error&quot; error=&quot;failed to get sandbox image \\&quot;registry.k8s.io/pause:3.6\\&quot;: failed to pull image \\&quot;registry.k8s.io/pause:3.6\\&quot;: failed to pull and unpack image \\&quot;registry.k8s.io/pause:3.6\\&quot;: failed to resolve reference \\&quot;registry.k8s.io/pause:3.6\\&quot;: failed to do request: Head \\&quot;https://asia-east1-docker.pkg.dev/v2/k8s-artifacts-prod/images/pause/manifests/3.6\\&quot;: dial tcp 108.177.125.82:443: connect: connection refused&quot;Oct 11 08:35:18 master.k8s containerd[1903]: time=&quot;2023-10-11T08:35:18.606581001+08:00&quot; level=info msg=&quot;trying next host&quot; error=&quot;failed to do request: Head \\&quot;https://asia-east1-docker.pkg.dev/v2/k8s-artifacts-prod/images/pause/manifests/3.6\\&quot;: dial tcp 108.177.125.82:443: connect: connection refused&quot; host=registry.k8s.io...\n报错显示containerd拉去镜像失败。error=&quot;failed to get sandbox image&quot;registry.k8s.io/pause:3.6&quot;\n解决方法：修改containered配置\n\n运行containerd config dump &gt; /etc/containerd/config.toml 命令，将当前配置导出到文件，并修改sandbox_image配置。\n\n## 修改配置文件/etc/containerd/config.toml， 更改sandbox_image配置[plugins]  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]    sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;\n\n重启containerd\n\nsystemctl restart containerd#查看containerd当前配置，验证pause镜像是否生效containerd config dump | grep pause\n","tags":["kubernetes"]},{"title":"个人博客搭建笔记","url":"/2023/12/24/my_blog_build_note/","content":"个人博客搭建笔记\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n一、环境准备\n1. 安装node.js\nnode.js的安装与配置教程-CSDN博客\n2. 安装git\nGit 2.43.0的安装教程-CSDN博客\n二、搭建博客\n\n以管理员的身份运行cmd输入命令下载hexo框架\n\nnpm install -g hexo-cli\n出现下图所示样式表示下载成功，因为我已经下载过了，所以没有什么变化。图中的警告先不用管，不影响使用。警告的大致意思是fsevents不支持windows平台。因为它是适用于苹果系统的，但是我们下载框架的时候是全都下载的，所以会出现这个警告。\n\n在自己想要存放博客的文件夹下新建一个文件，名字自拟。从本文件夹直接进入cmd，或者先进入cmd，cd该文件夹下。输入命令初始化一个博客。\nhexo init\n初始化中断，根据提示可以看到是在安装依赖时出了问题。\n\n原因是因为国内现在无法百分百概率访问Github，因此npm可能会下载失败；也有可能是因为文件权限的问题。总之按照提示再重新操作一遍以管理员的身份运行cmd并进入新建的博客文件夹下，使用hexo init命令后居然成功了。如下图所示，出现 Start blogging with Hexo 字样代表成功。\n\n初始化完成后使用命令就可以访问自己的博客了。\nhexo s\n按住ctrl键鼠标左键点击即可跳转到博客网页。\n\n博客网站如下图所示，默认会新建一篇文章。至此，博客的搭建工作告一段落。\n\n三、将博客部署到Github上\n使用命令安装一键将博客推送至GitHub上的插件\nnpm install hexo-deployer-git --save\n使用管理员的身份运行cmd输入命令后安装成功。\n\n在Github上创建一个个人仓库用于存放博客，首先登录GitHub，在个人仓库中找到新建仓库点击进入。\n\n仓库名为自己的GitHub用户名.github.io，如图所示，一定要这样设置，不然会不起作用。\n\n描述根据自己需要填写，然后点击创建仓库。\n\n创建完成后会自动跳转到你刚才创建的仓库内，在仓库中找到如下图所示位置，点击复制，后面修改博客的配置文件时会用到。\n\n使用vscode或者记事本打开_config.yml找到deploy修改其中的内容为，保存并退出。\ndeploy:  type: &#x27;git&#x27;  repo: &#x27;https://github.com/dettry/dettry.github.io.git&#x27; #为你创建的GitHub个人仓库地址  branch: &#x27;master&#x27;\n进入cmd中cd到博客存放的路径下执行如下命令就可以将博客部署到GitHub上了。\nhexo cleanhexo ghexo d\n记得在推送之前先开启梯子，然后将代理服务器打开。\n首先右键网络选择网络和Internet设置。\n\n找到使用代理服务器，点击编辑将代理服务器打开然后保存。\n\n最后推送成功后在地址栏输入dettry.github.io即可访问自己的博客。\n","tags":["hexo"]},{"title":"hexo使用Hexo-asset-image图片无法正常显示的一些解决方案","url":"/2024/05/09/hexo-asset-image-note/","content":"hexo使用Hexo-asset-image图片无法正常显示的一些解决方案\n1. 问题描述\n在进行个人博客的搭建工作时，\n2. 解决方案\n2.1 修改hexo-asset-image的代码（未测试）\n详细步骤参考下面文章：\n【Hexo】hexo-asset-image在hexo6.3.0下的使用以及与abbrlink插件的修改-CSDN博客\n2.2 换用hexo-renderer-marked-it（测试有效）\n根据hexo官方中的描述如下\n如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。\n文章资源文件夹\n对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。\n_config.ymlpost_asset_folder: true\n当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。\n相对路径引用的标签插件\n通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。\n&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125;\n比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](example.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）\n正确的引用图片方式是使用下列的标签插件而不是 markdown ：\n&#123;% asset_img example.jpg This is an example image %&#125;\n通过这种方式，图片将会同时出现在文章和主页以及归档页中。\n使用 Markdown 嵌入图片\nhexo-renderer-marked 3.1.0 引入了一个新的选项，其允许你无需使用 asset_img 标签插件就可以在 markdown 中嵌入图片（进入链接后往下翻找进入hexo-renderer-marked-it）\n如需启用：\n_config.ymlpost_asset_folder: trueimages:    lazyload: false    prepend_root: true    post_asset: true\n启用后，资源图片将会被自动解析为其对应文章的路径。\n例如： image.jpg 位置为 /2020/01/02/foo/image.jpg ，这表示它是 /2020/01/02/foo/ 文章的一张资源图片， ![](image.jpg) 将会被解析为 &lt;img   src=&quot;/2020/01/02/foo/image.jpg&quot; &gt; 。\n注意事项：如果使用![](image.jpg)这种引用格式的话在markdown编辑器中是无法看到图片的，只能在浏览器中看到可以使用![](your_essay_name/image.jpg)引用格式这样本地和浏览器中均可看到\n!!!特别注意你的文章名称不能是中文，这样会导致你的图片在浏览器中无法显示。博主亲测 :joy:\n2.3 使用图床\n如果使用图床的话，这样post_asset_folder就可以不用启用了也不用安装图片转换插件了。博主目前正在使用的就是图床，网上也有人说由于图床有时可能不稳定会导致浏览器无法访问照片，管他呢先用着再说。\n博主使用的图床工具是PicX，感觉挺好用的不用安装直接在线就可上传图片。网上也有很多别的图床工具例如PicGo等等，配置教程就不一一赘述了，大家可自行百度。\nPicX配置教程如下：\n2.3.1 GitHub OAuth 授权登录\n不推荐，原因是还需要安装picX，麻烦！！！！！！！！！！！！！\n2.3.2 填写GitHub Token登录\n\n创建一个带有 repo 权限的 GitHub Token点击 https://github.com/settings/tokens/new 快速新建 GitHub Token\n\n\n\n\n点击 Generate token 按钮，生成 GitHub Token并保存。\n\n\n图床配置\n\n\n\n填写 GitHub Token 之后，点击 一键配置 PicX 会自动创建 GitHub 仓库，完成仓库、分支和目录之间的配置，并跳转到图片上传页面。\n\n\n\n\n进入页面后可以选择图床配置新建目录来设置新的图片保存路径，也可以直接上传图片。\n\n\n图床设置中除了图片压缩选择图中的选项外，其余保持默认。\n\n\n\n","tags":["hexo"]},{"title":"正则表达式","url":"/2024/05/13/regular_expression_note/","content":"正则表达式\n1. 基础正则表达式速查表\n1.1 字符\n\n\n\n表达式\n描述\n\n\n\n\n[abc]\n字符集。匹配集合中所含的任一字符。\n\n\n[^abc]\n否定字符集。匹配任何不在集合中的字符。\n\n\n[a-z]\n字符范围。匹配指定范围内的任意字符。\n\n\n.\n匹配除换行符以外的任何单个字符。\n\n\n\\\n转义字符。\n\n\n\\w\n匹配任何字母数字，包括下划线（等价于[A-Za-z0-9_]）。\n\n\n\\W\n匹配任何非字母数字（等价于[^A-Za-z0-9_]）。\n\n\n\\d\n数字。匹配任何数字。\n\n\n\\D\n非数字。匹配任何非数字字符。\n\n\n\\s\n空白。匹配任何空白字符，包括空格、制表符等。\n\n\n\n1.2 分组和引用\n\n\n\n表达式\n描述\n\n\n\n\n(expression)\n分组。匹配括号里的整个表达式。\n\n\n(?:expression)\n非捕获分组。匹配括号里的整个字符串但不获取匹配结果，拿不到分组引用。\n\n\n\\num\n对前面所匹配分组的引用。比如(\\d)\\1可以匹配两个相同的数字，(Code)(Sheep)\\1\\2则可以匹配CodeSheepCodeSheep。\n\n\n\n1.3 锚点/边界\n\n\n\n表达式\n描述\n\n\n\n\n^\n匹配字符串或行开头。\n\n\n$\n匹配字符串或行结尾。\n\n\n\\b\n匹配单词边界。比如Sheep\\b可以匹配CodeSheep末尾的Sheep，不能匹配CodeSheepCode中的Sheep\n\n\n\\B\n匹配非单词边界。比如Code\\B可以匹配HelloCodeSheep中的Code，不能匹配HelloCode中的Code。\n\n\n\n1.4 数量表示\n\n\n\n表达式\n描述\n\n\n\n\n?\n匹配前面的表达式0个或1个。即表示可选项。\n\n\n+\n匹配前面的表达式至少1个。\n\n\n*\n匹配前面的表达式0个或多个。\n\n\n|\n或运算符。并集，可以匹配符号前后的表达式。\n\n\n{m}\n匹配前面的表达式m个。\n\n\n{m,}\n匹配前面的表达式最少m个。\n\n\n{m,n}\n匹配前面的表达式最少m个，最多n个。\n\n\n\n1.5 预查断言\n\n\n\n表达式\n描述\n\n\n\n\n(?=)\n正向预查。比如Code(?=Sheep)能匹配CodeSheep中的Code，但不能匹配CodePig中的Code。\n\n\n(?!)\n正向否定预查。比如Code(?!Sheep)不能匹配CodeSheep中的Code，但能匹配CodePig中的Code。\n\n\n(?&lt;=)\n反向预查。比如(?&lt;=Code)Sheep能匹配CodeSheep中的Sheep，但不能匹配ReadSheep中的Sheep。\n\n\n(?&lt;!)\n反向否定预查。比如(?&lt;!Code)Sheep不能匹配CodeSheep中的Sheep，但能匹配ReadSheep中的Sheep。\n\n\n\n1.6 特殊标志\n\n\n\n表达式\n描述\n\n\n\n\n/…/i\n忽略大小写。\n\n\n/…/g\n全局匹配。\n\n\n/…/m\n多行修饰符。用于多行匹配。\n\n\n\n2. 常用正则表达式示例\n2.1 数字校验\n\n\n\n描述\n正则表达式\n备注\n\n\n\n\n数字\n^[0-9]*$\n\n\n\nn位数字\n^\\d{n}$\n\n\n\n至少n位数字\n^\\d{n,}$\n\n\n\nm~n位数字\n^\\d{m,n}$\n\n\n\n整数\n^(-?[1-9]\\d*)$\n非0开头，包括正整数和负整数\n\n\n正整数\n^[1-9]\\d*$\n\n\n\n负整数\n^-[1-9]\\d*$\n\n\n\n非负整数\n^(([1-9]\\d*)|0)$\n\n\n\n非正整数\n^((-[1-9]\\d*)|0)$\n\n\n\n浮点数\n^-?(?:[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*|0.0+|0)$\n包括正浮点数和负浮点数\n\n\n正浮点数\n^(?:[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*)$\n\n\n\n负浮点数\n^-(?:[1-9]\\d*.\\d*|0.\\d*[1-9]\\d*)$\n\n\n\n非正浮点数\n^(?:-(?:[1-9]\\d*.\\d+|0.\\d*[1-9]\\d*)|0.0+|0)$\n包含0\n\n\n非负浮点数\n^(?:[1-9]\\d*.\\d+|0.\\d+|0.0+|0)$\n包含0\n\n\n仅一位小数\n^-?(?:0|[1-9][0-9]*).[0-9]{1}$\n\n\n\n最少一位小数\n^-?(?:0|[1-9][0-9]*).[0-9]{1,}$\n\n\n\n最多两位小数\n^-?(?:0|[1-9][0-9]*).[0-9]{1,2}$\n\n\n\n连续重复的数字\n^(\\d)\\1+$\n例如：111，222\n\n\n\n2.2 字符校验\n\n\n\n描述\n正则表达式\n备注\n\n\n\n\n中文\n^[\\u4E00-\\u9FA5]+$\n\n\n\n全角字符\n^[\\uFF00-\\uFFFF]+$\n\n\n\n半角字符\n^[\\u0000-\\u00FF]+$\n\n\n\n英文字符串（大写）\n^[A-Z]+$\n\n\n\n英文字符串（小写）\n^[a-z]+$\n\n\n\n英文字符串（不区分大小写）\n^[A-Za-z]+$\n\n\n\n中文和数字\n^(?:[\\u4E00-\\u9FA5]{0,}|\\d)+$\n\n\n\n英文和数字\n^[A-Za-z0-9]+$\n\n\n\n数字、英文字母或者下划线组成的字符串\n^\\w+$\n\n\n\n中文、英文、数字包括下划线\n^[\\u4E00-\\u9FA5\\w]+$\n\n\n\n不含字母的字符串\n^[^A-Za-z]*$\n\n\n\n连续重复的字符串\n^(.)\\1+$\n例如：aa，bb\n\n\n长度为n的字符串\n^.{n}$\n\n\n\nASCII\n^[ -~]$\n\n\n\n\n2.3 日期和时间校验\n\n\n\n描述\n正则表达式\n备注\n\n\n\n\n日期\n^\\d{1,4}-(?:1[0-2]|0?[1-9])-(?:0?[1-9]|[1-2]\\d|30|31)$\n弱校验，例如：2022-06-12\n\n\n日期\n^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$\n严格校验，考虑平闰年\n\n\n时间\n^(?:1[0-2]|0?[1-9]):[0-5]\\d:[0-5]\\d$\n12小时制，例如：11:21:31\n\n\n时间\n^(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d$\n24小时制，例如：23:21:31\n\n\n日期+时间\n^(\\d{1,4}-(?:1[0-2]|0?[1-9])-(?:0?[1-9]|[1-2]\\d|30|31))  ((?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d)$\n例如：2000-11-11  23:20:21\n\n\n\n2.4 日常生活相关\n\n\n\n描述\n正则表达式\n备注\n\n\n\n\n中文名\n^[\\u4E00-\\u9FA5·]{2,16}$\n\n\n\n英文名\n^[a-zA-Z][a-zA-Z\\s]{0,20}[a-zA-Z]$\n\n\n\n车牌号\n^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z][A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳]$\n不含新能源\n\n\n车牌号\n^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领]A-HJ-NP-Z$\n包含新能源\n\n\n火车车次\n^[GCDZTSPKXLY1-9]\\d{1,4}$\n例如：G1234\n\n\n手机号\n^(?:(?:+|00)86)?1[3-9]\\d{9}$\n弱匹配\n\n\n手机号\n^(?:(?:+|00)86)?1(?:(?:3[\\d])|(?:4[5-79])|(?:5[0-35-9])|(?:6[5-7])|(?:7[0-8])|(?:8[\\d])|(?:9[189]))\\d{8}$\n严格匹配\n\n\n固话号码\n^(?:(?:\\d{3}-)?\\d{8}|^(?:\\d{4}-)?\\d{7,8})(?:-\\d+)?$\n\n\n\n手机IMEI码\n^\\d{15,17}$\n一般是15位\n\n\n邮编\n^(?:0[1-7]|1[0-356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[0-5]|8[013-6])\\d{4}$\n例如：211100\n\n\n统一社会信用代码\n^[0-9A-HJ-NPQRTUWXY]{2}\\d{6}[0-9A-HJ-NPQRTUWXY]{10}$\n\n\n\n身份证号码(1代)\n^[1-9]\\d{7}(?:0\\d|10|11|12)(?:0[1-9]|[1-2][\\d]|30|31)\\d{3}$\n15位数字\n\n\n身份证号码(2代)\n^[1-9]\\d{5}(?:18|19|20)\\d{2}(?:0[1-9]|10|11|12)(?:0[1-9]|[1-2]\\d|30|31)\\d{3}[0-9Xx]$\n18位数字\n\n\nQQ号\n^[1-9][0-9]{4,}$\n一般是5到10位\n\n\n微信号\n^[a-zA-Z][-_a-zA-Z0-9]{5,19}$\n一般6~20位，字母开头，可包含字母、数字、-、_，不含特殊字符\n\n\n股票代码\n^(s[hz]|S[HZ])(000[\\d]{3}|002[\\d]{3}|300[\\d]{3}|600[\\d]{3}|60[\\d]{4})$\nA股，例如：600519\n\n\n银行卡卡号\n^[1-9]{1}(?:\\d{15}|\\d{18})$\n一般为19位\n\n\n\n2.5 互联网相关\n\n\n\n描述\n正则表达式\n备注\n\n\n\n\n域名\n^[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$\n例如：r2coding.com\n\n\n网址\n^(?:https?://)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$\n例如：https://www.r2coding.com/\n\n\n带端口号的网址(或IP)\n^(?:https?://)?[\\w-]+(?:.[\\w-]+)+:\\d{1,5}/?$\n例如：http://127.0.0.1:8888/\n\n\nURL\n^https?://(?:www.)?[-a-zA-Z0-9@:%.+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\\b(?:[-a-zA-Z0-9()!@:%+.~#?&amp;//=]*)$\n例如：https://www.r2coding.com/#/README?id=1\n\n\n邮箱email\n^[A-Za-z0-9\\u4e00-\\u9fa5]+@[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$\n支持中文，例如：codesheep@cs.com\n\n\n用户名\n^[a-zA-Z0-9_-]{4,20}$\n4到20位\n\n\n弱密码\n^[\\w]{6,16}$\n6~16位，包含大小写字母和数字的组合\n\n\n强密码\n^.(?=.{6,})(?=.\\d)(?=.[A-Z])(?=.[a-z])(?=.[!@.#$%^&amp;?  ]).*$\n至少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符\n\n\n端口号\n^(?:[0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$\n例如：65535\n\n\nIPv4地址\n^(?:(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]).){3}(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])$\n例如：192.168.31.1\n\n\nIPv4地址+端口\n^(?:(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]).){3}(?:\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])(?::(?:[0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?$\n例如：192.168.31.1:8080\n\n\nIPv6地址\n^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$\n例如：CDCD:910A:2222:5498:8475:1111:3900:2020\n\n\nIPv6地址+端口\n^[(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))](?::(?:[0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?$\n例如：[CDCD:910A:2222:5498:8475:1111:3900:2020]:9800\n\n\n子网掩码\n^(?:254|252|248|240|224|192|128).0.0.0|255.(?:254|252|248|240|224|192|128|0).0.0|255.255.(?:254|252|248|240|224|192|128|0).0|255.255.255.(?:255|254|252|248|240|224|192|128|0)$\n例如：255.255.255.0\n\n\nMAC地址\n^(?:(?:[a-f0-9A-F]{2}:){5}|(?:[a-f0-9A-F]{2}-){5})[a-f0-9A-F]{2}$\n\n\n\nVersion版本号\n^\\d+(?:.\\d+){2}$\n例如：12.1.1\n\n\n图片后缀\n.(gif|png|jpg|jpeg|webp|svg|psd|bmp|tif)+\n可按需增删扩展名集合\n\n\n视频后缀\n.(swf|avi|flv|mpg|rm|mov|wav|asf|3gp|mkv|rmvb|mp4)+\n可按需增删扩展名集合\n\n\n图片链接\n(?:https?://)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.+.(gif|png|jpg|jpeg|webp|svg|psd|bmp|tif)\n可按需增删扩展名集合\n\n\n视频链接\n(?:https?://)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.+.(swf|avi|flv|mpg|rm|mov|wav|asf|3gp|mkv|rmvb|mp4)\n可按需增删扩展名集合\n\n\n迅雷链接\nthunderx?://[a-zA-Z\\d]+=\n\n\n\ned2k链接\ned2k://|file|.+|/\n\n\n\n磁力链接\nmagnet:?xt=urn:btih:[0-9a-fA-F]{40,}.*\n\n\n\n\n2.6 其他\n\n\n\n描述\n正则表达式\n备注\n\n\n\n\nMD5格式\n^(?:[a-f\\d]{32}|[A-F\\d]{32})$\n32位MD5，例如：7552E7071B118CBFFEC8C930455B4297\n\n\nBASE64格式\n^\\sdata:(?:[a-z]+/[a-z0-9-+.]+(?:;[a-z-]+=[a-z0-9-]+)?)?(?:;base64)?,([a-z0-9!$&amp;',()+;=-._~:@/?%\\s]?)\\s$\n例如：data:image/jpeg;base64,xxxx==\n\n\nUUID\n^[a-f\\d]{4}(?:[a-f\\d]{4}-){4}[a-f\\d]{12}$\n例如：94f9d45a-71b0-4b3c-b69d-20c4bc9c8fdd\n\n\n16进制\n^[A-Fa-f0-9]+$\n例如：FFFFFF\n\n\n16进制颜色\n^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$\n例如：#FFFFFF\n\n\nSQL语句\n^(?:select|drop|delete|create|update|insert).*$\n\n\n\nJava包名\n^(?:[a-zA-Z_]\\w*)+(?:[.][a-zA-Z_]\\w*)+$\n例如：com.r2coding.controller\n\n\n文件扩展名\n.(?:doc|pdf|txt)\n可按需增删扩展名集合\n\n\nWindows文件路径\n^[a-zA-Z]:(?:\\[\\w\\u4E00-\\u9FA5\\s]+)+[.\\w\\u4E00-\\u9FA5\\s]+$\n例如：C:\\Users\\Administrator\\Desktop\\a.txt\n\n\nWindows文件夹路径\n^[a-zA-Z]:(?:\\[\\w\\u4E00-\\u9FA5\\s]+)+$\n例如：C:\\Users\\Administrator\\Desktop\n\n\nLinux文件路径\n^/(?:[^/]+/)*[^/]+$\n例如：/root/library/a.txt\n\n\nLinux文件夹路径\n^/(?:[^/]+/)*$\n例如：/root/library/\n\n\n\n","categories":["Java开发专题"],"tags":["Java"]},{"title":"区块链环境配置教程","url":"/2024/04/29/%E5%8C%BA%E5%9D%97%E9%93%BE/","content":"区块链环境配置教程\n一、安装CentOS\n本例中采用虚拟化软件VMware Workstation安装CentOS 7.3（最小安装minimal）。实际应用中，单个服务器一般都设定为单一功能，比如Web服务器，数据库服务器，LDAP服务器等，或者多台服务器分布式部署云计算组件如Hadoop等，单个服务器只需要操作系统的基本功能，因此CentOS最小化安装符合需求，如果需要额外的功能，可以在使用过程中增加。云服务提供商（例如阿里云）提供的云服务器操作系统一般是CentOS minimal。\n本例CentOS安装环境如下：\n主机（Host Machine）：CPU 8核，内存16G，操作系统Windows 10专业版64位\n虚拟化软件：VMware Workstation 14 pro\n到 https://www.centos.org/ 下载安装包，本例是CentOS-7-x86_64-DVD-1804.iso\n1.1 安装前VMware设置\n1、在VMware菜单“编辑-首选项”可以设置虚拟机默认放置的目录，应选择有足够空间的硬盘分区。本例中是 D:\\MyVM（根据自己喜好设置虚拟机存放的位置）\n2、创建虚拟机采用“自定义(高级)”配置，虚拟机名称(自己设置)。\n3、选择安装来源时，载入CentOS的ISO后，VMware会自动识别出操作系统类型和版本。也可以选择“稍后安装操作系统”不采用简易安装，而采用手动安装。\n4、为虚机分配处理器1个，内核数量2个，2G/4G（根据自己电脑内存大小）内存。本例中的这个虚机作为实验环境，将安装多种应用，因此配置较高。实验用虚机一般1核2G内存即可，可租用的轻量级云服务器一般是1核1G内存。实际应用虚机则根据需要分配资源，计算单元则对CPU要求较高，内容服务器则对内存要求较高。\n5、使用NAT网络（默认选项），虚机没有与主机同级的IP地址。\n桥接，NAT，仅主机模式，三者的简要区别如下：\n（1）桥接：虚机与主机在网络中地位一样，虚机拥有与主机同级的独立IP地址。\n（2）NAT：虚机共享主机的IP地址访问Internet，同一个主机中的各个虚机在同一网段中，可互相访问。外部无法直接访问虚机，但可通过主机的转接访问虚机。\n（3）仅主机模式：同一主机中的各个虚机可互相访问，虚机无法访问Internet，外部也无法访问虚机。\n6、I/O类型：默认LSI Logic，磁盘类型：默认SCSI，选择磁盘：创建新虚拟磁盘。\n7、分配20G虚拟磁盘空间，存为单独文件（非默认选项）。\n8、指定虚机磁盘文件，保持默认。\n9、开始安装时，可能会提示要更改BIOS设置以支持64位操作系统之类的，按照提示修改主机BIOS设置，再回来安装。\n注意：一般新的电脑无需设置自动支持64位虚拟化，有些电脑需要在BIOS里设置以支持64位虚拟化，有些更旧的电脑完全不支持64位虚拟化，则无法在VMware里安装64位的操作系统。\n\n设置完成如上图，点击“完成”开始安装。\n1.2 安装过程\n注意：安装过程中，鼠标点击虚机界面即可进入虚机操作，组合键ctrl + alt 可使鼠标返回主机。在VMware Workstation窗口的左下角会有提示。\n1、安装过程与在真实裸机上安装一样，初始界面按键“i”选择“Install CentOS”，然后回车进入安装过程。\n2、选择语言：保持默认 English - Englisth (United States)\n3、如下图所示，设置安装选项：\nDate &amp; Time 选到 Asian / Shanghai\nLanguage Support 可以把中文，简体中文(中国)选上\nSoftware Selection 保持Minimal Install不变\nInstallation Destination 需要点开，默认是自动配置磁盘，不需要修改，直接点“Done”按钮返回即可，黄色的感叹号才会消失，此界面右下角“Begin Installation”按钮才会亮起。\nNetwork &amp; Hostname 点进去，如果有显示有线网络ens33之类的，打开ON\nKDUMP可以设置为Disabled，保持默认也可以。\n设置完成后，点击右下角“Begin Installation”按钮开始安装。\n\n4、安装的过程中给root用户设置密码（4geT%not），非必需。如果密码太弱，需点击两次确定才能完成操作。\n新建一个用户admin（密码d00r%Key），勾选“Make this user administrator”，今后的常用登录用户。如果密码太弱，需点击两次确定才能完成操作。\n\n安装完成，点击“Reboot”重新启动。\n5、系统是最小化安装，没有GUI，默认以admin登录，安装完成。\n\n非必需：虚机屏幕有时候不匹配VMware的窗口，需要拉动窗口的滚动条才能看见全部的虚机屏幕内容。从VMware菜单“电源 - 关闭客户机”，然后再开启此虚机，可解决这个问题。\n1.3 忘记密码\n下面是CentOS 7的root密码修改\n开机按esc\n选择CentOS Linux (3.10.0-693…)     按 e 键\n\n 光标移动到 linux 16 开头的行，找到 ro 改为 rw init=sysroot/bin/sh\n\n按 Ctrl+x 执行\n进入后输 chroot /sysroot\n\n输入 passwd\n根据提示输入2次新密码\n\n完成后输入  touch /.autorelabel  更新系统信息\n\nexit\nreboot 重启\n\n重启过程慢，耐心等等\n重启后用新密码登录\n二、基本系统设置\n2.1 安装后设置\n2.1.1 关于用户\n目前系统里有2个用户，root是超级管理员，一般不用此账号登录；admin是常用用户，系统管理员。\n系统提示符为 # 表明用户为root，提示符为$ 表明用户为其他用户。\n每个用户都有自己的主目录，以 ~表示，root用户是 /root，其他用户是 /home/用户名。例如admin输入命令 cd ~ 则会进入其主目录 /home/admin\nadmin需要执行root权限的命令时，可以用 sudo 临时获得权限，也可以用 su 切换身份为root。\n使用sudo时，需要输入admin用户自己的密码，使用 su时，需要输入root用户的密码，使用“sudo su”则可以使用admin自己的密码切换到root用户身份，在root用户没有设置密码时，这个方法很好用。\n1、使用sudo不需要输入密码\n$ sudo visudo -f /etc/sudoers\n如下修改内容，在 %wheel ALL=(ALL) ALL 前加注释符#，去掉 %wheel ALL=(ALL) NOPASSWD:ALL 前的注释符。保存退出就行了。\n这是针对wheel这个组的设置，这个组的成员都不需要输入密码就可以使用sudo，admin是wheel组的成员。\n\n传统修改方法是在 root ALL=(ALL) ALL 下面增加一行 admin ALL=(ALL) NOPASSWD:ALL 但在这里会被 %wheel ALL=(ALL) ALL 覆盖掉。原因是在安装过程中，创建 admin用户时使其成为管理员，便成为了 wheel组的成员。系统只允许wheel组的用户来执行“su”命令登录为root用户，而让其他组的用户即使执行“su”、输入了正确的root密码，也无法登录为root用户。\n用visudo编辑sudoers文件是正确的做法。有些做法是增加文件sudoers的写权限，用vi修改，再去掉其写权限。可能会出现文件权限错乱，如下恢复sudoers文件的正确属性：\n$ sudo chmod 0440 /etc/sudoers\n2.2.2 连接网络，更新系统\n查找配置网络文件\n$ ls /etc/sysconfig/network-scripts/\n看到有形如 ifcfg-ens33 或 ifcfg-eth0 这样的文件，修改\n$ sudo vi /etc/sysconfig/network-scripts/ifcfg-ens33\n把 ONBOOT=no 改成 yes 即可，保存退出。\n重启网络服务，应用设置，就可以联网了。安装时选择的是NAT方式，因此是使用主机的IP地址连接到Internet。\n$ sudo systemctl restart network.service\n更新系统\n$ sudo yum update\n首先会查询要更新哪些内容，询问是否OK，确认后开始更新。\n安装必备系统组件perl，gcc，kernel-devel，wget，yum-utils，net-tools\n$ sudo yum -y install perl gcc kernel-devel wget$ sudo yum -y install yum-utils$ sudo yum -y install net-toolsyum install -y install unzip zip\n更新完毕后，可以重新启动一下系统\n$ sudo systemctl reboot\n2.2 网络设置\n安装net-tools包，以便后续使用ifconfig命令\n$ sudo yum -y install net-tools\n三、区块链的环境搭建\n搭建Hyperledger fabric环境\n搭建过程\n3.1 Go安装。（官网地址：https://golang.google.cn/dl/ ）\n\n下载安装包\n\n箭头所指地址+自己系统所对应的版本。使用wget命令。\n\n以我自己安装的为例，图中椭圆框中即为我所安装版本。\n所以下载命令为：\nwget https://golang.google.cn/dl/go1.18.5.linux-amd64.tar.gz\n\n解压安装包到指定路径\n\n将下载的压缩包通过下面命令进行解压，一定注意大小写（否则可能导致安装失败）\ntar -xzvf go1.18.5.linux-amd64.tar.gz -C /usr/local/\n\n设置环境变量\n\n使用vi /etc/profile 编辑profile文件。\n添加以下内容到profile 文件中（gopath应提前创建好，或者配置完成后别忘了创建）\n#go settingexport GOROOT=/usr/local/goexport GOPATH=/usr/local/gopathexport PATH=$PATH:$GOROOT/bin\n保存并退出。\nsource /etc/profile 使文件立即生效。\n在gopath路径下使用mkdir创建三个文件，即mkdir src bin pkg。\n其中bin存放编译后的可执行文件；pkg存放编译后的包文件；src存放项目源文件。\n查看是否安装成功\ngo version\n编辑hello.go文件测试.\nvi /usr/local/gopath/src/hello.go\n在hello.go中编写如下代码：\npackage main import &quot;fmt&quot;func main() &#123;`    `fmt.Println(&quot;Hello world!&quot;)&#125;\n保存并退出。\ngo run hello.go\n显示Hello world!正确执行。截止到此，安装GO语言环境完成。\n3.2 docker安装\n第一种方式：curl -fsSL https://get.docker.com/ | sh 比较快捷，但是可能会因为无法访问国外的镜像而出错。如果不能安装，就是用第二种方式。\n第二种方式（推荐）：\n如果以前安装过docker，请先卸载或删除所有依赖关系。如果没装过跳过此过程。\nyum list installed | grep docker；查看所有安装的docker程序\nyum -y remove+要删除程序的完整名称（如果安装的比较多，这个过程可能有点麻烦）\nrm -rf /var/lib/docker：删除镜像容器。\n输入Docker version出现如下图所示字样，表明已卸载干净。\n\n然后开始安装docker\nyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #安装阿里镜像源yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin #（默认安装的是最新版的）\n查看版本信息\n\nsystemctl start docker #启动dockersystemctl enable docker #将docker设置为开机自启，以便后续操作不会出错。\n安装docker-compose\n1.下载docker-compose\n命令：\ncurl -SL https://github.com/docker/compose/releases/download/v2.11.2/docker-compose-linux-x86\\_64 -o /usr/local/bin/docker-compose\n也可以下载别的版本，只需将命令行中v2.11.2换成自己想装的版本即可。\n2. 给docker-compose文件添加可执行权限\n命令：\nchmod +x /usr/local/bin/docker-compose\n3. 添加软连接\nln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n4.查看版本\nDocker-compose version\n3.3 nodejs安装\n去这个网站https://nodejs.org/dist/找到自己想安装的版本。\n复制整个网址，使用以下命令下载，例如我下载的：\nWget https://nodejs.org/dist/v16.14.1/node-v16.14.1-linux-x64.tar.gz\n2.解压\ntar -xzvf node-v16.14.1-linux-x64.tar.gz -C /usr/local/cd /usr/localmv node-v10.19.0-linux-x64/ nodejs\n3.vi /etc/profile 增加环境变量\nexport NODE\\_HOME=/usr/local/nodejsexport PATH=$NODE\\_HOME/bin:$PATH\n保存并退出\nsource /etc/profile 使文件立即生效。\n4. 查看版本\nnode -vnpm -v\n5.设置淘宝镜像源\nnpm config set registry https://registry.npm.taobao.org\n6.which node、 whereis node   查看有无 node、npm等命令\n\n7. 安装全局 pm2\nnpm install -g pm2\n8. 查看 有无 pm2命令 ， pm2 版本\n\n下载源代码\n因为要用到git，所以需要先安装git。\nyum install git\n下载相关镜像文件。\n在想要安装fabric的目录下运行以下命令来下载fabric （时间可能会有点久）\ngit clone https://github.com/hyperledger/fabric.git\n（git clone克隆时出现fatal: unable to access ‘https://github.com/\\*\\*‘: TCP connection resset by peer）\n解决方法：\n##发生这种情况是git设置了代理，取消代理即可\n[root@hya ~]# git config --global --unset http.proxy[root@hya ~]# git config --global --unset https.proxy\n下载完成后会得到一个fabric文件夹，进入fabric/scripts目录可以看到一个bootstrap.sh脚本（注意刚开始是没有fabric-samples这个文件夹的，是执行脚本后生成的）\n\n直接执行bootstrap.sh脚本，就会自动进行fabric相关镜像的下载 （时间有点久，如果出现长时间停顿，可能需要重启虚拟机后重新执行脚本）\n当相关镜像全部下载完成后，会自动罗列出下载的内容\n\n构建网络\nFabric 1.x.x版本的应该是进入fabric/scripts/fabric-samples/first-network/\nFabric2.x.x版本的进入fabric/scripts/fabric-samples/test-network/\n执行以下命令，开启测试网络：\n./network.sh down./network.sh up\n创建信道\n./network.sh createChannel\n下载go依赖\nexport GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct\n查看是否切换成功：\ngo env\n进入链码所在路径：\ncd /usr/local/go/fabric/scripts/fabric-samples/asset-transfer-basic/chaincode-go\n下载依赖：\ngo mod vendor\n四、在通道上启动链码chaincode（智能合约）\n切换回 /fabric-samples/test-network 目录：\n./network.sh deployCC -ccn basic -ccp …/asset-transfer-basic/chaincode-go -ccl go\n如果出现下图所示情况：\n\n解决方案\n下载并安装EPEL\nwget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmrpm -ivh epel-release-latest-7.noarch.rpm\n# 检查是否已添加至源列表\nyum repolist\n安装jq\nyum install jq\n五、与网络交互\n首先确保自己位于test-network目录下。\n进入CLI容器，进行invoke交互，需要几行命令设置CLI的路径：\nexport PATH=$&#123;PWD&#125;/../bin:$PATHexport FABRIC\\_CFG\\_PATH=$PWD/../config/\n先设置为org1的环境变量进行交互：\nexport CORE\\_PEER\\_TLS\\_ENABLED=trueexport CORE\\_PEER\\_LOCALMSPID=&quot;Org1MSP&quot;export CORE\\_PEER\\_TLS\\_ROOTCERT\\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtexport CORE\\_PEER\\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/mspexport CORE\\_PEER\\_ADDRESS=localhost:7051\n用下面的命令初始化账本：\npeer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot; -c &#x27;&#123;&quot;function&quot;:&quot;InitLedger&quot;,&quot;Args&quot;:[]&#125;&#x27;\n使用下面的命令查找账本：\npeer chaincode query -C mychannel -n basic -c &#x27;&#123;&quot;Args&quot;:[&quot;GetAllAssets&quot;]&#125;&#x27;\n通过命令改变一笔资产的所有者：\npeer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot; -c &#x27;&#123;&quot;function&quot;:&quot;TransferAsset&quot;,&quot;Args&quot;:[&quot;asset6&quot;,&quot;Christopher&quot;]&#125;&#x27;\n六、关闭测试网络\n./network.sh down\n","categories":["Linux专题"],"tags":["区块链"]}]
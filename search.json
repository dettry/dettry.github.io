[{"title":"Java基础","url":"/2024/03/16/Java%E8%AF%AD%E8%A8%80/","content":"Java语言1. 语言基础1.1 基础语法\n数据类型\n\n数据类型分为两类：基本数据类型、引用数据类型。\nJava中的基本数据类型只有**四类八种**整数型：byte、short、int、longshort占两字节int 占用四个字节long 占用八个字节\n\n\n浮点型\n\n浮点型有两种：float、doublefloat占用四位，double占用八位\n\n\n\n\n字符型\n\n字符型为char，char类型是一个单一的16位Unicode字符。\n\n\n\n\n布尔型\n\n The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its &quot;size&quot; isn&#x27;t something that&#x27;s precisely defined. 翻译：布尔数据类型只有两种可能的值：true和false。使用这个数据类型用于追踪true/false状况的简单标识。这个数据类型表示1bit的信息，但是它的”大小“没有被精确定义。\n\n\n\n引用数据类型\n\n只要不是基本数据类型就是引用数据类型。\n\n\n\n\n自动类型转换（隐式）\n\n转换规则： 数据范围必须是**从小到大**，即由小的转换成大的，自动转换。\n\n\n强制类型转换（显式）\n\n注意事项：1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。 2. byte/short/char这三种类型都可以发生数学运算，例如加法“+”。3. byte/short/char这三种类型在运算的时候都会首先提升成为int类型，然后再计算。例：byte+byte-&gt;int+int-&gt;int4. boolean类型不能发生数据类型转换\n\n\n\n\n运算符的优先级\n\n单目（一元）&gt;算术运算符&gt;移位&gt;关系&gt;位&gt;条件(三元)&gt;赋值\n\n\n\n\n基础语法\n\n1. 大小写敏感： Java是大小写敏感的语言，例如Hello和hello是不同的，这其实就是Java的字符串表示方式。2. 类名：类名使用 UpperCamelCase 风格，但以下情形例外： DO / BO / DTO / VO / AO /PO / UID 等。正例： ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion反例： forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion3. 包名：包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。正例： 应用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils（此规则参考 spring 的框架结构）4. 方法名、变量名、参数名：都统一使用 lowerCamelCase 风格正例： localValue / getHttpMessage() / inputUserId\n\n\n方法\n构造方法\n\n作用：用来创建对象的注意事项：1. 构造方法的名称必须和所在类的名称完全一样，就连大小写也要一样2. 构造方法不要写返回值类型，连void都不写3. 构造方法不能return一个具体的返回值4. 如果没有编写任何构造方法，那么编译器会默认分配一个构造方法5. 一旦编写了一个构造方法，那么编译器就不会再分配任何构造方法\n\n\n\n\n静态方法\n\n静态方法又叫类方法。\n\n\n\n\n非静态方法（成员方法）\n\n方法之间的调用注意事项：1. 同类型的方法之间可以直接调用2. 静态方法调用非静态方法需要先new一个对象，然后通过对象进行调用。3. 非静态方法可以直接调用静态方法。\n\n\n方法重载\n\n多个方法的名称相同，但是参数列表不一样。方法重载与下列因素相关：1. 参数个数不同2. 参数类型不同3. 多参数类型顺序不同方法重载与下列因素无关：1. 与参数名称无关2. 与方法的返回值类型无关3. \n\n\n参数传递机制\n\nJava的参数传递机制都是：值传递\n\n\n\n\n数组\n\nJava的内存划分成为5个部分：1. 栈内存（stack）：存放的都是方法中的局部变量。  方法的运行一定要在栈中运行。         局部变量： 方法的参数、方法&#123;&#125;内部的变量2. 堆内存（heap）: 凡是new出来的东西都在堆当中。        堆内存里面的东西都有一个地址值：16进制        堆内存中的数据都有默认值。规则：                 整数         默认0                 浮点数       默认0.0                 字符         默认&#x27;\\u0000&#x27;                 布尔         默认false                 引用类型      默认null3. 方法区（）: 存储.class相关信息，包含方法的信息。4. 本地方法栈（）： 与操作系统相关5. 寄存器（）： 与cpu相关\n\n\n\n1.2 面向对象\n特点\n\n面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成指挥者。\n\n面向对象语言包含三大基本特征：\n\n封装\n就是将一些细节信息隐藏起来，对外界不可见。\n\n方法就是一种封装\nprivate关键字也是一种封装\n\n一旦使用private进行修饰，那么本类当中仍然可以随意访问，但是超出了本类范围之外就不能再直接访问了。\n可以使用getter&#x2F;setter方法间接访问private成员变量。\n\n继承\n\n\n​        继承是多态的前提，如果没有继承，就没有多态。\n​        继承主要解决的问题就是：共性抽取\n   **变量重名的解决方法**\n\n​        \t 局部变量：                    直接写成员变量名\n​        \t 本类的成员变量：          this.成员变量名\n​          \t父类的成员变量：          super.成员变量名\n  **重写（override）**    \n\n​        \t 概念：在继承关系中，方法的名称一样，参数列表一样。\n​        \t 方法重写（override）：方法名称一样，参数列表也一样。（覆盖重写）\n​        \t 方法重载（overload）：方法名称一样，参数列表不一样。\n   **覆盖重写的注意事项：**\n  \n            1. 必须保证父子类之间的方法名称相同，参数列表也相同。\n            2. 子类方法的权限必须大于等于父类方法的权限修饰符。\n\n​         public&gt;protected&gt;(default)&gt;private\n​         备注：（default）不是关键字default，而是什么修饰符也不用。\n​\t继承关系中，父子类构造方法的访问特点：\n1. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造\n\n​\t\t注意事项：\n​\t\t\t子类必须调用父类构造方法，不写则默认super（），写了则用写的指定的super调用，super只能有一个，还必须是第一个。\n​\t\tJava继承的三大特点\t\n\nJava语言是单继承的，即一个类的直接父类只能有唯一一个。\nJava语言可以多级继承。\n一个子类只能有一个父类，但是一个父类可以有多个子类。\n\n 如果父类当中的方法不确定如何进行{}方法体实现，那么这就应该是一个抽象方法。\n抽象类：抽象方法所在的类必须是抽象类才行。在class之前写上abstract即可。\npublic abstract class Animal&#123;    //这是一个抽象方法，代表吃东西，但是具体吃什么不确定。    public abstract void eat();&#125;\n\n如何使用抽象类和抽象方法\n\n不能直接创建new抽象类对象\n\n必须用一个子类来继承抽象父类。\n\n子类必须覆盖重写抽象父类当中的所有抽象方法。\n覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号\n\n创建子类对象进行使用。\n\npublic  class Cat extends Animal&#123;    @Override    public void eat()&#123;        &#125;&#125;\n\n\n多态\n\n一个对象拥有多种形态，这个就叫对象的多态性。\n代码当中体现多态性，其实就是一句话，父类引用指向子类对象。\n格式：\n父类名称 对象名 &#x3D; new 子类名称（）；\n或者\n接口名称 对象名 &#x3D; new  实现类名称（）；\n访问成员变量和方法的规则：\n访问成员方法：等号右边new的谁，优先用谁，没有则向上找。\n直接通过对象名称访问成员变量：等号左边是谁，优先用谁，没有则向上找。\n间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。\n对象的转型\n\n对象的向上转型，其实就是多态写法：\n\n格式：父类名称 对象名 &#x3D; new 子类名称（）；\n\n对象的向下转型，其实是一个【还原】的动作\n\n格式：子类名称 对象名 &#x3D; （子类名称） 父类对象\n注意事项：\n\n必须保证对象本来创建的时候就是A,才能向下转型成为A。\n如果创建的对象本来不是A，非要向下转型为A就会报错。\n\n 四种权限修饰符\n内部类\n\n成员内部类\n局部内部类（包含匿名内部类）\n\n成员内部类的定义格式：\n修饰符 class 外部类名称&#123;      修饰符 class 内部类名称&#123;            &#125;&#125;注意：内用外，随意访问； 外用内，需要内部类对象。\n\n局部内部类的定义格式：\n修饰符 class 外部类名称&#123;      修饰符 返回值类型 方法名称（参数列表）&#123;              class 局部内部类名称&#123;                   &#125;      &#125;    &#125;\n\n匿名内部类的定义格式：\n接口名称 对象名称 =  new 接口名称（）&#123; 覆盖重写所有抽象方法&#125;；注意事项：    1. 匿名内部类在创建对象的时候只能使用唯一一次    \n\n\n\n\n类和对象\n\n什么是类\n\n类：是一组相关属性和行为的集合。\n\n现实中，描述一类事物：\n\n属性：就是该事物的特征信息。（是什么）（成员变量）\n\n行为：就是该事物能够做什么。（成员方法）成员方法不要写static关键字。\n\n\n什么是对象\n\n对象：是一类事物的具体体香。对象是类的一个实例。\n\n类与对象的关系\n\n类是对一类事物的描述，是抽象的。\n对象是一类事物的实例，是具体的。\n类是对象的模板，对象是类的实体。\n\n成员变量和局部变量的区别\n1. 定义的位置不一样局部变量：在方法的内部成员变量：在方法的外部，直接写在类当中。2. 作用范围不一样局部变量：只有方法当中才可以使用成员变量：整个类全可以通用3. 默认值不一样局部变量：没有默认值，如果要想使用，必须手动赋值成员变量：如果没有赋值，会有默认值，规则和数组一样。4. 内存的位置不一样局部变量：位于栈内存成员变量：位于堆内存5. 生命周期不一样局部变量：随着方法进栈而生，随着方法出栈而亡成员变量：随着对象创建而生，随着对象被垃圾回收而亡。\n\n\n对象数组\n\n数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变。\n\n字符串\n\n1. 字符串的内容不可变2. 字符串可以共享使用3. 字符串效果上相当于char[]字符数组，但是底层原理是byte[]字节数组在堆内存中有一个字符串常量池。常用方法：equalslength()concat:连接字符串charAt:indexOf:\n\nStringBuilder类：字符串缓冲区，可以提高字符串的效率\n常用方法：\nappend\ntoString\n\n静态关键字static\n\n一旦用了static关键字，那么这样的内容不再属于对象自己，\n而是属于类的，所以凡是本类的对象，都共享同一份。\n一旦使用static修饰成员方法，那么就成为了静态方法，静态方法不属于对象，而是属于类的。如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。无论是成员变量还是方法，如果有了static，都推荐使用类名称进行调用。静态变量：类名称.静态变量静态方法：类名称.静态方法（）注意事项：1. 静态方法当中不能使用this\n\n静态代码块\n特点：当第一次用到本类时，静态代码块执行唯一的一次。\n静态内容总是优先于非静态，所以静态代码块比构造方法先执行。\n静态代码块的用途：\n用来一次性的对静态成员变量进行赋值。\nArrays工具类\ntoString(数组)：将参数数组变成字符串（按照默认格式：[元素1，元素2,………]）\n1.3 接口接口就是多个类的公共规范\n接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。\n从Java 8开始，接口 里允许定义默认方法。\n备注：接口当中的默认方法可以解决接口升级的问题。\n什么是接口升级？\n就是已经投入使用的接口，想在其中添加新的方法，这时如果直接添加，会导致所有实现该接口的类报错，但是使用default默认方法可以解决此问题，并且该方法也可以被其他接口实现类覆盖重写。\n格式：\npublic default 返回值类型 方法名称（参数列表）&#123;方法体&#125;\n\n从Java 9 开始，接口中允许定义私有方法。\n\n普通私有方法，解决多个默认方法之间的重复代码问题\n\n格式：\nprivate 返回值类型 方法名称（参数列表）&#123;&#125;\n\n\n静态私有方法：解决多个静态方法之间重复代码问题\n\n格式：\nprivate static 返回值类型 方法名称（参数列表）&#123;方法体&#125;\n\n接口与接口之间是多继承的。\n\n日期时间类\n\ndate\n\nDateFormat类\n\n日期时间格式化类\n\n包装类\n\n基本类型             对应的包装类byte                  Byteshort                 Shortint                   Integerlong                  Longfloat                 Floatdouble                Doublechar                  Characterboolean               Boolean\n\n装箱与拆箱\n装箱：从基本类型转换成对应的包装类对象\n拆箱：从包装类对象转换为对应的基本类型\nInteger i= Integer.valueOf(4)//装箱int num = i.intValue();//拆箱\n\n\n\n1.4 容器\ncollection集合\n\n集合：集合是Java中提供的一种容器，可以用来存储多个数据。\n集合和数组既然都是容器，它们有啥区别？\n\n数组的长度是固定的，集合的长度是可变的\n数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象，而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。\n\n常用共性方法\npublic boolean add(E e): 添加对象public void clear(): 清空集合public boolean remove(E e): 把给定对象从当前集合删除public boolean contains(E e): 判断当前集合中是否包含给定的对象public boolean isEmpty():public int size(): 返回集合中的元素个数public Object[] toArray(): 把集合中的元素，存储到数组中\n\nList\n\n有序的集合（存储和取出元素顺序相同）\n允许存储重复的元素\n有索引，可以使用普通的for循环遍历\n\n\nArrayList（查询快，增删慢）\n\nArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();\n\n常用方法：\nadd,get,remove,size\n\nLinkedList（查询慢，增删快）\n\nLinkedList&lt;E&gt; linked = new LinkerdList&lt;&gt;();\n\n\n\nSet\n\n不允许存储重复的元素\n没有索引\n\n\nHashSet\n\nHashSet&lt;E&gt; set = new HashSet&lt;&gt;();\n\n\n是一个无序集合\n底层是一个哈希表结构\n\n哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑i地址，是模拟出来的地址，不是数据实际存储的物理地址）\nint hashCode():获取对象的哈希码值\n\n哈希表（查询快）\n哈希表的结构，jdk1.8之后：\n\n哈希表&#x3D;数组+链表；\n哈希表&#x3D;数组+红黑树；\n\n\nLInkedHashSet\n\nLInkedHashSet特点：\n底层是一个哈希表+链表，多了一条链表（记录元素的存储顺序），保证元素有序。\nHashSet存储自定义类型元素\n给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。\n可变参数\n格式\n修饰符 返回值类型 方法名（数据类型...变量名）&#123;&#125;实例    public static int add(int... arr) &#123;        int sum = 0;        for (int i : arr) &#123;            sum += i;        &#125;        return sum;    &#125;注意事项    1. 一个方法的参数列表只能有一个可变参数    2. 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾。可变参数的特殊（终极）写法    实例     public static void method(Object...obj)&#123;        &#125;\n\n\n\n\n\nMap\n特点\n\nmap集合是一个双列集合，一个元素包含两个值（key:value）\nmap集合中的元素，key和value的数据类型可以相同，也可以不同\nmap中key是不允许重复的，value可以重复\nmap中的key和value一一对应\n\n\nHashMap（初始长度16）\n\n特点：\n\nHashMap集合底层是哈希表：查询速度特别快\nhashMap是一个无序集合，存储和取出元素的顺序可能不一致\n\n\nLinkedHashMap\n\n特点：\n\n底层是哈希表+链表（保证迭代的顺序）\n是一个有序的集合，存储和取出元素的顺序是一致的\n\n\nTreeMap\n\n\n\n\n\nCollections工具类\n常用方法\npublic static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements) ：往集合中添加一些元素public static void shuffle(List&lt;?&gt; list) ：打乱集合顺序public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)：将集合按照默认规则排序public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)：将集合中元素按照指定规则排序\n\n\n\n1.4.1 Iterator迭代器迭代：Collection集合元素的通用获取方式。\n迭代器的使用案例\npublic static void main(String[] args) &#123;       Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();       coll.add(&quot;姚明&quot;);       coll.add(&quot;科比&quot;);       coll.add(&quot;詹姆斯&quot;);       coll.add(&quot;库里&quot;);       //获取一个迭代器对象       Iterator&lt;String&gt; iterator = coll.iterator();       while (iterator.hasNext())&#123;           String s = iterator.next();           System.out.println(s);       &#125;&#125;\n\n\n\n1.5 异常异常：指的是程序在执行过程中，出现非正常的情况，最终导致JVM非正常停止。\nJava处理异常的方式是中断处理。\n异常产生的过程解析\n1.5.1 异常的处理Java异常处理的五个关键字：try、catch、finally、throw、throws\n\n抛出异常throw\n\nthrow作用：\n可以使用throw关键字在指定的方法中抛出指定的异常\n使用格式：\nthrow new xxxException（“异常产生的原因”）;\n注意：\n\nthrow关键字必须写在方法的内部\nthrow后面new的对象必须是Exception或者Exception的子类对象\nthrow抛出指定的异常对象，我们必须处理这个异常对象，要么用throws，要么try…..catch\n\n以后（工作中）我们首先必须对方法传递过来的参数进行合法性校验如果参数不合法，那么我们就必须使用抛出异常的方式，告知方法的调用者，传递的参数有问题。\n\n\n声明异常throws（异常处理的第一种方式）\n\n作用：\n当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象\n可以使用throws处理异常对象，把异常声明抛出给方法的调用者处理（自己不处理，谁调用我让谁处理），最终交给jvm处理–&gt;中断异常\n使用格式：在方法声明时使用\n修饰符 返回值类型 方法名（参数列表） throws xxxException,.....&#123;\tthrow new xxxException(&quot;产生原因&quot;);&#125;注意    1. throws 必须写在方法声明处    2. throws 后边声明的异常必须是Exception或者其子类    3. 方法内部如果抛出多个异常，那么throws后边也必须声明多个异常        如果多个异常之间有子父类关系，直接声明父类异常就行    4. 调用了一个声明抛出异常的方法，我们就必须处理声明的异常        要么继续使用 throws 声明抛出，交给方法的调用者处理，最终交给 JVM        要么 try....catch 自己处理。\n\n\n捕获异常try…..catch（异常处理的第二种方式）\n\n格式：\ntry&#123;    &#125;catch(xxxException e)&#123; //try中抛出什么异常，catch就定义什么异常对象，用来接收这个异常。    一般在工作中，会把异常的信息记录在一个日志中。&#125;注意    1. try 可能会抛出多个异常，那么可以使用多个 catch 来处理    2. 如果 try 中产生了异常，就会执行 catch 中的异常处理逻辑，执行完后，继续执行 try...catch 后的代码。    3. 如果 try 中没有异常，就不执行 catch ，执行完 try 后，继续执行 try...catch 后的代码。\n\n\n\n1.6 泛型泛型是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型。\n泛型的数据类型在创建对象的时候确定\n创建集合对象，使用泛型\n好处：\n\n避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型\n把运行期异常（代码运行之后抛出的异常）提升到了编译期\n\n弊端：\n\n泛型是什么类型，只能存储什么类型的数据\n\n含有泛型的方法\n定义格式\n 修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表（使用泛型）)&#123;        方法体;    &#125;实例 public &lt;H&gt; void genericMethod(H h)&#123;        System.out.println(h);    &#125;\n\n含有泛型的接口\n定义格式\n第一种使用方式，定义接口的实现类，实现接口并指定接口的泛型实例    public interface Iterator&lt;E&gt; &#123;\t\t\tE next();  &#125;\tpublic final class Scanner implements Iterator&lt;String&gt;&#123;\t&#125;第二种使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走   public interface List&lt;E&gt;&#123;        boolean add(E e);      &#125;   public class ArrayList&lt;E&gt; implements List&lt;E&gt;&#123;       public boolean add(E e) &#123;       &#125;   &#125;\n\n泛型通配符\n​\t？：代表任意的数据类型\n使用方式：\n​\t不能创建对象使用\n​\t  只能作为方法的参数使用\n高级使用-受限泛型（要求只要看源码能看懂就行）\n作用：限定数据的使用类型。\n泛型的上限限定：？extends E 代表使用的泛型只能是E类型的子类&#x2F;本身\n泛型的下限限定：？super E 代表使用的泛型只能是E类型的父类&#x2F;本身\n\n数据结构\n\n红黑树\n特点：\n\n趋近于平衡树，查询的速度非常快，查询叶子节点最大次数和最小次数不能超过2倍\n\n约束：\n\n节点可以是红色或者黑色\n根节点是黑色\n叶子节点（空节点）是黑色\n每个红色的节点的子节点都是黑色\n任何一个节点到其每一个叶子节点所有路径上的黑色节点数相等\n\n1.7 反射作用\n\n基本作用：可以得到一个类的全部成分然后操作\n可以破坏封装性\n最重要的用途是：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。\n\n1.8 注解就是Java的特殊标记，作用是：让其他程序根据注解信息来决定怎么执行该程序\n特殊属性名：value\n如果注解只有一个value属性，使用注解时，value名称可以不写。\n元注解\n修饰注解的注解\n常见的元注解\n1. @Target    作用：声明被修饰的注解只能在哪些位置使用    @@Target(ElementType.TYPE)    1. TYPE,类，接口    2. FIELD， 成员变量    3. METHOD，成员方法    .....      2. @Retention    作用：声明注解的保留周期    @Retention(RetentionPolicy.RUNTIME)    1. SOURCE    只作用在源码阶段，字节码文件中不存在    3.RUNTIME（开发常用）    一直保留到运行阶段\n\n注解的解析\n要解析谁上面的注解，就先拿到谁\n1.9 I&#x2F;O重点：记住三个单词\n​          file： 文件\n​          directory：文件夹&#x2F;目录\n​          path： 路径\n递归：指在当前方法内部调用自己的这种现象\n递归的分类：\n\n直接递归\n\n​        方法自身调用自身\n\n间接递归\n\n​\t\tA方法调用B方法，B方法调用C方法，C方法调用A方法。\nJava中的I&#x2F;O操作主要是指使用Java.io包下的内容，进行输入、输出操作。\n\n字节流（InputStream&#x2F;OutputStream）\n\nFileInputStream     文件字节输入流    作用：把硬盘文件中的数据，读取到内存中使用FileOutputStream    文件字节输出流    作用：把内存中的数据写入到硬盘的文件中\n\n使用字节流读取中文文件容易产生乱码\n一个中文\n​\t\tGBK： 占用两个字节\n     UTF-8：占用三个字节\n\n\n字符流（reader&#x2F;writer）\n\n作用：读取字符信息，一次读取一个字符\njdk7的新特性\n在try后边可以增加一个()，在括号中可以定义流对象\n那么这个流对象的作用域就在try中有效\ntry中的代码执行完毕会自动把流对象释放，不用写finally\n格式\ntry(定义流对象；定义流对象...)&#123;    可能会产生异常的代码&#125;catch(异常类变量 变量名)&#123;    异常的处理逻辑&#125;实例public class ThreadPoll &#123;    public static void main(String[] args) &#123;        try(//创建一个字符输出流对象，构造方法绑定需要写入的目的地            FileWriter fw = new FileWriter(&quot;test.txt&quot;,true);) &#123;//            //创建一个字符输入流对象，构造方法绑定需要读取的数据源//            FileReader fr = new FileReader(&quot;test.txt&quot;);            for (int i = 0; i &lt; 10; i++) &#123;                fw.append(&quot;helloword&quot;+i+&quot;\\r\\n&quot;);            &#125;        &#125;catch (Exception e)&#123; \t\t\te.printStackTrace();        &#125;    &#125;&#125;\n\n\n缓冲流\n\n作用：提高文件读写的效率\n字节缓冲流（BufferedInputStream &amp; BufferedOutputStream）\n字符缓冲流（BufferedReader &amp; BufferWriter）\n\n转换流(OutputStreamWriter &amp; InputStreamReader)\n\n作用：能够转换编码\n\n序列化流(ObjectOutputStream &amp; ObjectInputStream )\n\n作用：能够持久化存储对象\nSerializable 接口也叫标记型接口    要进行序列化和反序列化的类必须实现 Serializable 接口，就会给类添加一个标记    当我们进行序列化和反序列化的时候，就会检测是否有这个标记    有：就可以序列化和反系列化    没有：就会抛出 NotSerializableException 异常 transient关键字：瞬态关键字    被 transient 修饰的成员变量，不能被序列化问题：    每次修改类的定义，都会给class文件生成一个新的序列号，这样在进行序列化与反序列化时就会报invalidClassException异常解决方法：    无论是否对类的定义进行修改，都不重新生成新的序列号    可以手动给类添加一个序列号  格式：    private static final long serialVersionUID = 6161825669842708241L;等号后面的常量可以为任意值，不可改变。\n\n序列化集合\n当我们想在文件中保存多个对象的时候，可以把多个对象存储到一个集合中，然后对集合进行序列化和反序列化。\n2. JVM2.1 类加载机制2.2 字节码执行机制2.3 jvm内存模型2.4 gc垃圾回收机制2.5 jvm性能监控和故障定位2.6 jvm调优3. 并发&#x2F;多线程3.1 并发编程3.2 多线程创建线程的步骤：\n\n声明Thread类的子类\n重写Thread类的run方法\n\n实例public class MyThread extends Thread&#123;    @Override    public void run() &#123;        //设置线程任务    &#125;&#125;创建线程的第二种方式    1. 创建一个runnable接口的实现类    2. 在实现类中重写runnable接口的run方法，设置线程任务 实例public class MyRunnableThreadImpl implements Runnable&#123;    @Override    public void run() &#123;        //设置线程任务        for (int i = 0; i &lt; 20; i++) &#123;            System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+i);        &#125;    &#125;&#125;public class RunnableThreaTest &#123;    public static void main(String[] args) &#123;        //多态写法        //Runnable runnable= new MyRunnableThreadImpl();        MyRunnableThreadImpl runnable= new MyRunnableThreadImpl();        Thread t = new Thread(runnable);        t.start();        for (int i = 0; i &lt; 20; i++) &#123;            System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+i);        &#125;    &#125;&#125;使用runnable接口创建多线程的好处：    1. 避免了单继承的局限性    2. 增强了程序的扩展性，降低了程序的耦合性（解耦）\n\nThread类中的常用方法\npublic final String getName()：获取；当前线程名public synchronized void start() ：此线程开始执行，Java虚拟机调用此线程的run方法public static void sleep(long millis, int nanos):使当前线程暂停指定多长时间public void run()：线程要执行的任务都在此处编写public static native Thread currentThread()：返回当前正在执行的线程对象的引用        \n\n并发与并行\n并发：指两个或多个事件在同一时间段内发生\n并行：指两个或多个事件在同一时刻发生（同时发生）\n线程与进程\n进程： 是指一个内存中运行的应用程序\n线程： 是指进程中的一个执行单元，负责当前进程中程序的执行，一个进程至少有一个线程。一个进程中是可以有多个线程的，这个应用程序称为多线程程序。\n线程调度\n分时调度： 所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。\n抢占式调度： 优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java使用的为抢占式调度。\n3.2.1 线程安全 解决线程安全问题\n\n同步代码块: synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。\n\n使用synchronized关键字容易产生死锁（如何解决，在后续内容中写）\n格式：\nsynchronized（同步锁（锁对象））&#123;    //需要同步操作的代码即：可能出现线程安全问题的代码（访问了共享数据的代码）&#125;同步锁（锁对象）注意事项：    1. 同步代码块中的锁对象，可以使用任意的对象    2. 必须保证多个线程使用的锁对象是同一个    3. 锁对象作用：             把同步代码块锁住，只让一个线程在同步代码块中执行实例public class MyRunnableThreadImpl implements Runnable&#123;    private Integer ticket = 100;    Object obj = new Object();    @Override    public void run() &#123;        //同步锁        synchronized (obj)&#123;            while (true)&#123;                if (ticket&gt;0)&#123;                    try &#123;                        Thread.sleep(10);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+ticket);                    ticket--;                &#125;            &#125;        &#125;    &#125;&#125;\n\n\n同步方法\n\n格式：\n修饰符 synchronized 返回值类型 参数名（参数列表）&#123;    //需要同步操作的代码即：可能出现线程安全问题的代码（访问了共享数据的代码）&#125;实例public class MyRunnableThreadImpl implements Runnable&#123;    private Integer ticket = 100;    @Override    public void run() &#123;            while (true)&#123;                payTicket();            &#125;        //同步方法        public synchronized void payTicket()&#123;        if (ticket&gt;0)&#123;            try &#123;                Thread.sleep(10);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+ticket);            ticket--;        &#125;    &#125;&#125;**静态同步方法**锁对象是谁？不能是thisthis是创建对象之后产生的，静态方法优先于对象静态方法的锁对象是本类的class属性--&gt;class文件对象(反射)\n\n\nLock锁\n\nLock接口中的方法：\n  void lock() 获取锁\n   void unlock() 释放锁\n实例public class RunnableImpl implements Runnable&#123;    private Integer ticket = 100;   Lock l = new ReentrantLock();    @Override    public void run() &#123;        while (true) &#123;            l.lock();            if (ticket &gt; 0) &#123;                try &#123;                    Thread.sleep(10);                    System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + ticket);                    ticket--;                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;finally &#123;                    l.unlock();                &#125;            &#125;        &#125;    &#125;&#125;\n\n\n\n3.3 线程池  线程池： 其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作。\n3.4 锁3.5 并发容器3.6 原子类3.7 juc并发工具类4. 网络编程软件结构：c&#x2F;s，b&#x2F;s\n4.1 网络通信网络通信协议的分类\n\nUDP：用户数据报协议\n\n特点：消耗资源小，通信效率高\n通常用于音频、视频和普通数据的传输例如视频会议都使用udp协议，即使丢一两个数据包，也不会对接受结果产生太大影响。\n\nTCP：传输控制协议\n\n是面向连接的通信协议。在TCP连接中必须要明确客户端与服务器端，每次连接的创建都需要经过“三次握手”。\n特点：传输安全\n网络编程的三要素\n\n协议\nIP地址\n\n\nIPv4：32位的二进制数，通常被分为4个字节，表示a.b.c.d的形式，每个字节的范围都是0~255.\nIPv6：\n\n\n端口号\n\n4.2 函数式接口函数式接口：只有一个抽象方法的接口，称之为函数式接口\n当然接口中可以包含其他的方法（默认，静态，私有）\n Lambda表达式\n函数式编程思想：\n​\t只要能获取到结果，谁去做，怎么做的都不重要，重视的是结果，不重视过程。\n使用前提\n\n使用Lambda必须具有接口，且要求接口中有且只有一个抽象方法。\n使用Lambda必须具有上下文推断\n\n有些场景的代码执行后结果不一定被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，正好可以作为解决方案，提升性能。\n常用函数式接口\n\nSupplier接口\n\nSupplier:被称为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据public class Demo01Test &#123;    /**     * 定义一个方法，用于获取int类型数组中元素的最大值，     * 方法的参数传递Supplier接口，泛型使用Integer     * @param sup     * @return     */    public static int getMax(Supplier&lt;Integer&gt; sup)&#123;        return sup.get();    &#125;    public static void main(String[] args) &#123;        int[] arr = &#123;100,0,-50,88,99&#125;;       int max= getMax(()-&gt;&#123;           int temp= arr[0];           for (int i = 1; i &lt; arr.length; i++) &#123;               if (temp&lt;arr[i])&#123;                   temp=arr[i];               &#125;           &#125;           return temp;        &#125;);        System.out.println(max);    &#125;&#125;\n\n\nConsumer接口\n\nConsumer:消费型接口，泛型执行什么类型，就可以使用accept方法使用什么类型的数据至于怎么消费（使用），需要自定义（输出，计算）默认方法：andThen作用：将两个Consumer接口连接到一起，然后再对数据进行消费（使用）public class DemoConsumer &#123;    public static void printMessage(String[] arr, Consumer&lt;String&gt; con1,Consumer&lt;String&gt; con2)&#123;        for (String s : arr) &#123;            con1.andThen(con2).accept(s);        &#125;    &#125;    public static void main(String[] args) &#123;        String[] arr =  &#123;&quot;迪丽热巴，女&quot;,&quot;古力娜扎，女&quot;,&quot;沈腾，男&quot;&#125;;        printMessage(arr,                (s)-&gt;&#123;                    System.out.print(&quot;姓名：&quot;+s.split(&quot;，&quot;)[0]+&quot;\\t&quot;);                &#125;,                (s)-&gt;&#123;                    System.out.println(&quot;性别：&quot;+s.split(&quot;，&quot;)[1]+&quot;。&quot;);                &#125;);    &#125;&#125;  \n\n\nPredicate接口\n\n对某种类型的数据进行判断，从而得到一个Boolean值结果。public class DemoPredicate &#123;    /**     * 定义一个方法，方法的参数传递一个字符串     * 传递两个Predicate接口     * 一个用于判断字符串的长度大于5     * 一个用于判断字符串中是否包含a     * 两个条件必须同时满足     * @param pre1     * @return     */    public static boolean checkString(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)&#123;          // return pre1.test(s) &amp;&amp; pre2.test(s);        //return pre1.test(s) || pre2.test(s);//        return pre1.or(pre2).test(s);          return pre1.and(pre2).test(s);    &#125;    public static void main(String[] args) &#123;        String test = &quot;Hello world!!&quot;;       boolean b= checkString(test,                (s)-&gt;&#123;            return s.length()&gt;5;                &#125;,                (s)-&gt;&#123;            return s.contains(&quot;H&quot;);                &#125;);        System.out.println(b);    &#125;&#125;\n\n4.3 Stream流IO流和Stream流是两个概念，IO流是用于数据的读写，而Stream流可以用来对集合和数组进行简化操作。\n","tags":["java"]},{"title":"Linux笔记","url":"/2023/05/05/Linux%E7%AC%94%E8%AE%B0/","content":"Linux笔记1. 目录结构\n2. 常用命令2.1 ls对应英文：list  \n作用： 查看当前目录下的内容\nll 对应 ls -l \n作用： 查看当前目录下的所有内容和每个文件的详细信息。\n2.2 pwd对应英文：print work directory \n作用： 查看当前所在目录\n2.3 touchtouch [文件名] \n作用：如果文件不存在，新建文件\n2.4 cd~表示当前用户的home目录\n.表示当前所在目录\n..表示当前目录位置的上级目录\n2.5 catcat [-n] fileName\n-n: 由1开始对所有输出的行数编号\ncat &#x2F;etc&#x2F;profile   查看&#x2F;etc目录下的profile文件内容\n2.6 rmdir作用：删除空目录\n语法：rmdir [-p] dirName\n-p: 当子目录被删除后使父目录为空目录的话，则一并删除\nrm\n作用：删除文件或者目录\n语法：rm [-rf] name\n-r:将目录及目录中的所有文件（目录）逐一删除，即递归删除\n-f: 无需确认直接删除\n2.7 tar作用：对文件进行打包、解包、压缩、解压\n语法：tar [-zcxvf] fileName [files]\n包文件后缀为.tar表示只是完成了打包，并没有压缩\n包文件后缀为.tar.gz表示打包的同时还进行了压缩\n说明：\n-z: z代表gzip，通过gzip命令处理文件，gzip可以对文件压缩或者解压\n-c: c代表的是create，即创建新的包文件\n-x: x代表的是extract，实现从包文件中还原文件\n-v: v代表的是verbose,显示命令的执行过程\n-f: f代表的是file ,用于指定包文件的名称\n","tags":["linux"]},{"title":"k8s集群搭建教程（使用cri-docker+flannel）","url":"/2024/05/04/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/","content":"k8s集群搭建教程（使用cri-docker+flannel）1. 准备工作（所有节点）1.1 系统环境(我是没配置也部署成功了，可以先部署，如果失败了再回来进行系统环境优化)\n系统环境优化配置\n\nCentOs 7.x系统自带的3.10.x内核存在一些bug，导致运行的docker，kubernetes不稳定，获取源：\nrpm -Uvh http://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm\n\n\n安装内核，装完成后检查 &#x2F;boot&#x2F;grub2&#x2F;grub.cfg中对应内核menuentry中是否包含 initrd16 配置，如果没有，再安装一次！耗时可能会有点久\n\nyum --enablerepo=elrepo-kernel install -y kernel-lt \n\n#查看系统的全部内核rpm -qa | grep kernel#kernel-3.10.0-1160.el7.x86_64#kernel-lt-5.4.271-1.el7.elrepo.x86_64#kernel-tools-libs-3.10.0-1160.el7.x86_64#kernel-tools-3.10.0-1160.el7.x86_64#设置开机从新内核启动grub2-set-default &#x27;CentoS Linux(5.4.271-1.el7.elrepo.x86_64) 7 (Core)&#x27;reboot#查看正在使用的内核uname -r\n\n1.2 系统参数设置\n所有节点关闭swap和防火墙\n\nsystemctl stop firewalldsystemctl disable firewalld#临时关闭swapoffswapoff -a#永久关闭swapoff（如果想永久关闭，将下面命令的#去掉）#sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab\n\n\n禁用SELINUX\n\nsetenforce 0sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config\n\n\n所有节点设置主机名\n\nhostnamectl set-hostname  k8s-masterhostnamectl set-hostname  k8s-node1hostnamectl set-hostname  k8s-node2\n\n\n所有节点主机名&#x2F;IP加入hosts解析\n\nvi /etc/hosts加入如下内容：192.168.183.132 k8s-master192.168.183.133 k8s-node1192.168.183.134 k8s-node2\n\n\n所有节点配置k8s内核\n\ncat &gt; kubernetes.conf &lt;&lt;EOFnet.bridge.bridge-nf-call-iptables=1net.bridge.bridge-nf-call-ip6tables=1net.ipv4.ip_forward=1net.ipv4.tcp_tw_recycle=0vm.swappiness=0 #禁止使用swap空间，只有当系统OOM时才允许使用它vm.overcommit_memory=1 #不检查物理内存是否够用vm.panic_on_oom=0 #开启OOMfs.inotify.max_user_instances=8192fs.inotify.max_user_watches=1048576fs.file-max=52706963fs.nr_open=52706963net.ipv6.conf.all.disable_ipv6=1net.netfilter.nf_conntrack_max=2310720net.ipv4.tcp_keepalive_time = 600net.ipv4.tcp_keepalive_probes = 3net.ipv4.tcp_keepalive_intvl =15net.ipv4.tcp_max_tw_buckets = 36000net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_max_orphans = 327680net.ipv4.tcp_orphan_retries = 3net.ipv4.tcp_syncookies = 1net.ipv4.tcp_max_syn_backlog = 16384net.ipv4.ip_conntrack_max = 65536net.ipv4.tcp_max_syn_backlog = 16384net.ipv4.tcp_timestamps = 0net.core.somaxconn = 16384EOFcp kubernetes.conf /etc/sysctl.d/kubernetes.confsysctl -p /etc/sysctl.d/kubernetes.conf\n\n\nlimit优化\n\nulimit -SHn 65535 cat &lt;&lt;EOF &gt;&gt; /etc/security/limits.confsoft nofile 655360hard nofile 131072soft nproc 655350hard nproc 655350soft memlock unlimitedhard memlock unlimitedEOF\n\n\n\n\n\n2. 组件安装（所有节点）2.1 Docker安装如果你的系统未安装过Docker，直接按照下面步骤操作即可。如果之前安装过，请先自行百度卸载干净。\n\n安装软件包并设置存储库\n\nyum install -y yum-utils device-mapper-persistent-data lvm2yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n\n\n安装Docker\n\nyum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\n\n启动Docker\n\nsystemctl start dockersystemctl enable dockerdocker info\n\n\n创建 &#x2F;etc&#x2F;docker目录\n\nmkdir /etc/docker #配置daemoncat &gt; /etc/docker/daemon.json &lt;&lt;EOF&#123;    &quot;exec-opts&quot;:[&quot;native.cgroupdriver=systemd&quot;],    &quot;log-driver&quot;:&quot;json-file&quot;,    &quot;log-opts&quot;:&#123;        &quot;max-size&quot;:&quot;100m&quot;    &#125;&#125;EOF\n\nmkdir -p /etc/systemd/system/docker.service.d #重启docker服务systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl enable docker\n\n\n注意事项\n\nkubernetes 1.24+版本之后，docker必须要加装cir-docker\n\n2.2 安装cri-dockergo安装\n\n下载\n\nwget https://golang.google.cn/dl/go1.20.12.linux-amd64.tar.gz\n\n#安装gorm -rf /usr/local/go &amp;&amp; tar -C /usr/local/ -xzvf go1.20.12.linux-amd64.tar.gz \n\n\n设置环境变量\n\nvi /etc/profile添加以下内容到profile 文件中（gopath应提前创建好，或者配置完成后别忘了创建）#go settingexport GOROOT=/usr/local/goexport GOPATH=/usr/local/gopathexport PATH=$PATH:$GOROOT/bin#保存退出执行source /etc/profile\n\n构建cri-dockerd\ngit clone https://github.com/Mirantis/cri-dockerd.git\n\n编译\ncd cri-dockerdmkdir bingo build -o bin/cri-dockerdmkdir -p /usr/local/bininstall -o root -g root -m 0755 bin/cri-dockerd /usr/local/bin/cri-dockerdcp -a packaging/systemd/* /etc/systemd/systemsed -i -e &#x27;s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,&#x27; /etc/systemd/system/cri-docker.service\n\nKubernetes使用\n\n编辑：\n\nvi /etc/systemd/system/cri-docker.service\n\n在ExecStart后面追加，如：\nExecStart=/usr/local/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9\n\n\n创建cri-docker启动文件，然后拷贝到其他节点\n\nvi /usr/lib/systemd/system/cri-docker.service[Unit]Description=CRI Interface for Docker Application Container EngineDocumentation=https://docs.mirantis.comAfter=network-online.target firewalld.service docker.serviceWants=network-online.targetRequires=cri-docker.socket [Service]Type=notifyExecStart=/usr/bin/cri-dockerd --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9ExecReload=/bin/kill -s HUP $MAINPIDTimeoutSec=0RestartSec=2Restart=always StartLimitBurst=3 StartLimitInterval=60s LimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinity TasksMax=infinityDelegate=yesKillMode=process [Install]WantedBy=multi-user.target\n\nvi /usr/lib/systemd/system/cri-docker.socket[Unit]Description=CRI Docker Socket for the APIPartOf=cri-docker.service [Socket]ListenStream=%t/cri-dockerd.sockSocketMode=0660SocketUser=rootSocketGroup=docker [Install]WantedBy=sockets.target\n\nscp /usr/lib/systemd/system/cri-docker.service /usr/lib/systemd/system/cri-docker.socket root@k8s-node1:/usr/lib/systemd/system/ scp /usr/lib/systemd/system/cri-docker.service /usr/lib/systemd/system/cri-docker.socket root@k8s-node2:/usr/lib/systemd/system/\n\n\n启动cri-docker并设置开机自动启动\n\nsystemctl daemon-reload ; systemctl enable cri-docker --now#查看状态systemctl is-active cri-docker\n\n\n\n2.3 所有节点安装 kubeadm，kubelet 和 kubectlcat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF[kubernetes]name=Kubernetesbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOFsetenforce 0yum install -y kubelet kubeadm kubectlsystemctl enable kubelet &amp;&amp; systemctl start kubelet\n\n\n设置kubelet开机自启\n\nsystemctl enable --now kubelet.service\n\n\n\n3. 搭建k8s集群3.1 k8s初始化\n在master上初始化k8s\n\nkubeadm init \\--apiserver-advertise-address=192.168.183.132 \\--image-repository=registry.aliyuncs.com/google_containers \\--kubernetes-version=v1.28.2 \\--service-cidr=10.96.0.0/12  \\--pod-network-cidr=10.244.0.0/16 \\--cri-socket=unix:///var/run/cri-dockerd.sock\n\n\n按照提示创建kubeconfig文件\n\nmkdir -p $HOME/.kubecp -i /etc/kubernetes/admin.conf $HOME/.kube/configchown $(id -u):$(id -g) $HOME/.kube/config\n\n\n重新初始化\n\nkubeadm reset --cri-socket /var/run/cri-dockerd.sock rm -rf .kube/sudo mkdir ~/.kubesudo cp /etc/kubernetes/admin.conf ~/.kube/cd ~/.kubemv admin.conf configsystemctl restart kubelet\n\n\n\n3.2 node节点的加入\n加入节点\n\n在node节点如k8s-node1上执行：\nkubeadm join kubeadm初始化成功后的token --cri-socket /var/run/cri-dockerd.sock例如我的kubeadm初始化成功后的token为：192.168.183.132:6443 --token vib96t.hmkd7hj7ykdigmp1 --discovery-token-ca-cert-hash sha256:c0bb3a82a4642cc4fe253edd0533ad8136b34dc243f274aa3cea27abc46e321f\n\n\n查看节点状态\n\nkubectl get nodes此时所有节点的状态为NotReady，这是因为还没有安装flannel网络插件\n\n\n网络插件下载并安装\n\n#如果网络故障也可直接在网站中下载好文件后上传至虚拟机中（自行翻墙）wget https://github.com/flannel-io/flannel/releases/download/v0.24.3/kube-flannel.yml#执行kubectl apply -f kube-flannel.yml#或者（两者的结果是一样的，只是执行工作原理不一样，想深究的可以自行查阅资料）kubectl create -f kube-flannel.yml\n\n\n再次查看节点状态全部变为 Ready\n\nkubectl get nodes#如果查看节点没有变成ready，先等个几分钟，因为网络传输需要一定的时间。等几分钟后如果还是NotReady，再根据报错原因查找解决方案\n\n","tags":["kubernetes"]},{"title":"Java笔记","url":"/2023/05/05/Java%E7%AC%94%E8%AE%B0/","content":"Java笔记基础篇\njava语言概述整体概述\njava语言的特点特点一：面向对象\n两概三特：类、对象；封装、继承、多态；\n特点二：健壮性\n去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等）\n特点三：跨平台性\n原理：先安装一个JVM虚拟机，然后由JVM负责JAVA程序在该系统上运行。\nJava核心机制\n   Java虚拟机：对于不同的平台有不同的虚拟机；\n   垃圾回收机制：\n注释单行和多行注释与c语言注释相同\n文档注释：JAVA所特有\n格式：&#x2F;**  *&#x2F;\n作用：注释的内容可以被jdk提供的工具javadoc所解析，生成网页形式的程序说明文档。\njava API文档英文版：版本8\n中文版：版本6\nJava基本语法保留字goto、const，java没有赋予其特殊含义，但在命名时尽量避开。\n标识符凡是可以自己起的名字都叫标识符。e.g：变量名、类名等等\n命名规范\n包名：多个单词组成时所有字母都小写\n类名、接口名：多单词组成时，所有单词首字母大写\n变量名、方法名：多单词组成时，第一个单词首字母小写，从第二个单词开始首字母大写。\n常量名：所有字母都大写，多单词时，每个单词用下划线连接。\n变量的类型\n变量运算规则的两种特殊情况定义long型变量：long len&#x3D;78899786676l&#x2F;L;\n定义float型变量：float len&#x3D;12.3f&#x2F;F;\n但现实经常使用double型变量，精度更高。\n整型常量默认类型：int\n浮点型常量默认类型：double\n算数运算符+、-、*、&#x2F;、++、–、%\n赋值运算符&#x3D;\n扩展运算符:+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;+、%&#x3D;\n比较运算符基本与c语言一样。\ninstanceof:检查是否是类的对象。\n进阶篇SpringBoot开发以后所用技术：mybatis+druid+远程服务器，别使用lombok进行开发。\n基础篇1. parent将以前spring开发时所需要配置的pom 文件进行整合，方便管理。\n\n  小结\n\n开发springBoot程序要继承spring-boot-starter-parent\n\nspring-boot-starter-parent中定义了若干个依赖管理（不是具体的坐标，只是把你要用的版本管理好，而没提供具体的坐标）\n\n继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突（做版本的统一化管理)\n\n继承parent的形式也可以采用引入依赖的形式实现效果\n\n\n2. starterstarter\n​\t\t1. SpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标 ，以达到减少依赖配置的目的\nparent\n    1. 所有SpringBoot项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的\n    1. spring-boot-starter-parent各版本间存在着诸多坐标版本不同\n\n实际开发\n\n使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供，除非SpringBoot未提供对应版本V\n\n如发生坐标错误，再指定Version（要小心版本冲突)\n\n\n小结\n\n开发springBoot程序需要导入坐标时通常导入对应的starter\n每个不同的starter根据功能不同，通常包含多个依赖坐标\n使用starter可以实现快速配置的效果，达到简化配置的目的\n\n3. 引导类下图即为引导类\n\n无论是做spring程序还是做springmvc的程序，最后都会运行出来一个spring容器的对象。所有对象都以bean的形式交给spring容器管理。\nSpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目\nSpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean\n得到bean的方式有四种：\n\n以类型的形式（即class）\n\n\n4. 辅助功能\n\n内置服务器：\ntomcat(默认)\njetty\nundertow\n\n小结\n\n内嵌Tomcat服务器是SpringBoot辅助功能之一\n内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理\n变更内嵌服务器思想是去除现有服务器，添加全新的服务器\n\n5. Rest风格开发入门案例1.以前的开发\n\n2. 接受参数的三种方式\n3.现在的开发\n6. boot配置6.1 准备工作模板的制作\n\n在工作空间中复制对应工程，并修改工程名称\n删除与Idea相关配置文件，仅保留src目录与pom. xml文件\n修改pom.xml文件中的artifactId与新工程&#x2F;模块名相同\n删除name标签（可选)\n保留备份工程供后期使用\n\n6.2 属性配置\n\nSpringBoot提供了3种配置文件的格式properties (传统格式&#x2F;默认格式)yml（主流格式)yaml\n\n配置文件间的加载优先级properties (最高)\nyml（常用）\nyaml(最低)\n\n不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留\n\n\nyaml或者yml自动提示功能消失解决方案\n\nyaml书写格式：注意属性名冒号后面与数据之间有一个空格\n\n读取数据\n\n7. 整合第三方技术\n整合junit小结\n\n导入测试对应的starter(如果是自己手工创建的话)\n\n测试类使用@SpringBootTest修饰\n\n使用自动装配的形式添加要测试的对象\n\n测试类如果存在于引导类所在包或子包中无需指定引导类\n\n测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类\n\n\n\n整合mybatis小结\n\n勾选MyBatis技术，也就是导入MyBatis对应的starter\n\n数据库连接相关信息转换成配置\n\n数据库sQL映射需要添加@Mapper被容器识别到\n  springboot的版本过低导致的问题处理\n\n\n\n\n\n​\t\t\t2.1 MySQL 8.X驱动强制要求设置时区\n​\t\t\t\t修改url，添加serverTimezone设定\n​\t\t\t\t修改MySQL数据库配置（略)\n​\t\t\t2.2 驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver\n\nboot整合东西分为三个部分:\n\n导入对应的start\n做相应的配置\n直接使用对应的技术进行开发\n\n\n\n整合mybatis-plus小结 \n\n\n\n\n整合Druid(即数据源)\n\n​      \n\n\n\n","tags":["java"]},{"title":"k8s集群搭建常见问题汇总","url":"/2024/05/04/kubeadm%E6%90%AD%E5%BB%BAKubernetes%E9%9B%86%E7%BE%A4%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","content":"kubeadm搭建Kubernetes集群问题汇总问题一：kubeadm init 报错 [ERROR CRI]: container runtime is not running需要使用的解决方法\nkubernetes使用crictl命令管理CRI，查看其配置文件/etc/crictl.yaml。初始情况下没有这个配置文件，这里建议添加这个配置，否则kubeadm init时会报其他错。\n\n#containered做进行时cat &gt; /etc/crictl.yaml &lt;&lt;EOFruntime-endpoint: unix:///var/run/containerd/containerd.sockimage-endpoint: unix:///var/run/containerd/containerd.socktimeout: 0debug: falsepull-image-on-create: falseEOF#cri-docker做进行时cat &gt; /etc/crictl.yaml &lt;&lt;EOFruntime-endpoint: unix:///var/run/cri-dockerd.sockimage-endpoint: unix:///var/run/cri-dockerd.socktimeout: 0debug: falsepull-image-on-create: falseEOF#执行crictl images list命令不报错crictl images list\n\n\n查看配置文件：&#x2F;etc&#x2F;containerd&#x2F;config.toml\n\n修改 disabled_plugins = [&quot;cri&quot;]为 disabled_plugins = []\n\n重启containerd\nsystemctl restart containerd\n\n问题二：ERROR FileContent–proc-sys-net-bridge-bridge-nf-call-iptables报错原因：网桥过滤和地址转发功能不可用\n解决方法\ncat &gt; /etc/sysctl.d/kubernetes.conf &lt;&lt; EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1EOF# 然后执行,生效sysctl --system\n\n如果执行上述命令报&#x2F;proc&#x2F;sys&#x2F;net&#x2F;bridge&#x2F;bridge-nf-call-iptables does not exist错误是因为网桥功能未开启，执行下面的命令即可\nmodprobe br_netfilter\n\n问题三：kubelet报错failed to run Kubelet: running with swap on is not supportedswapoff -a\n\n问题四：kubeadm init时报错一些配置文件已存在解决方法：\nkubeadm reset\n\n问题五：kubeadm init时，kubelet 报错crictl –runtime-endpoint配置不对从日志看出时crictl命令运行时有问题。unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;containerd&#x2F;containerd.sock不存在。运行crictl命令，发现同样报错。出现报错的原因是crictl下载镜像时使用的是默认端点[unix:///var/run/dockershim.sock unix:///run/containerd/containerd.sock unix:///run/crio/crio.sock unix:///var/run/cri-dockerd.sock]。这些端点废弃了，需要重新指定containerd.sock。后面的报错就是找不到dockershim.sock。\n解决方法：修改crictl文件\n#containered做进行时cat &gt; /etc/crictl.yaml &lt;&lt;EOFruntime-endpoint: unix:///var/run/containerd/containerd.sockimage-endpoint: unix:///var/run/containerd/containerd.socktimeout: 0debug: falsepull-image-on-create: falseEOF#cri-docker做进行时cat &gt; /etc/crictl.yaml &lt;&lt;EOFruntime-endpoint: unix:///var/run/cri-dockerd.sockimage-endpoint: unix:///var/run/cri-dockerd.socktimeout: 0debug: falsepull-image-on-create: falseEOF#执行crictl images list命令不报错crictl images list\n\n\n\n问题六：报Usage of CRI endpoints without URL scheme is deprecated and can cause kubelet errors in the future.警告W0504 10:46:57.238606    6046 initconfiguration.go:120] Usage of CRI endpoints without URL scheme is deprecated and can cause kubelet errors in the future. Automatically prepending scheme “unix” to the “criSocket” with value “&#x2F;var&#x2F;run&#x2F;cri-dockerd.sock”. Please update your configuration!  \n如果是contained做进行时就执行：\nsudo crictl config \\--set runtime-endpoint=unix:///var/run/containerd/containerd.sock \\--set image-endpoint=unix:///var/run/containerd/containerd.sock#或者cat &gt; /etc/crictl.yaml &lt;&lt;EOFruntime-endpoint: unix:///var/run/containerd/containerd.sockimage-endpoint: unix:///var/run/containerd/containerd.socktimeout: 0debug: falsepull-image-on-create: falseEOF\n\n如果时cri-docker做进行时就执行：\nsudo crictl config \\--set runtime-endpoint=unix:///var/run/cri-dockerd.sock \\--set image-endpoint=unix:///var/run/cri-dockerd.sock#或者cat &gt; /etc/crictl.yaml &lt;&lt;EOFruntime-endpoint: unix:///var/run/cri-dockerd.sockimage-endpoint: unix:///var/run/cri-dockerd.socktimeout: 0debug: falsepull-image-on-create: falseEOF\n\n问题七：报错pause镜像获取失败通过log提示执行命令crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock ps -a 发现没有容器在运行。查看containerd的日志，有如下报错：\njournalctl -fu containerd...Oct 11 08:35:16 master.k8s containerd[1903]: time=&quot;2023-10-11T08:35:16.760026536+08:00&quot; level=error msg=&quot;RunPodSandbox for &amp;PodSandboxMetadata&#123;Name:kube-apiserver-node,Uid:a5a7c15a42701ab6c9dca630e6523936,Namespace:kube-system,Attempt:0,&#125; failed, error&quot; error=&quot;failed to get sandbox image \\&quot;registry.k8s.io/pause:3.6\\&quot;: failed to pull image \\&quot;registry.k8s.io/pause:3.6\\&quot;: failed to pull and unpack image \\&quot;registry.k8s.io/pause:3.6\\&quot;: failed to resolve reference \\&quot;registry.k8s.io/pause:3.6\\&quot;: failed to do request: Head \\&quot;https://asia-east1-docker.pkg.dev/v2/k8s-artifacts-prod/images/pause/manifests/3.6\\&quot;: dial tcp 108.177.125.82:443: connect: connection refused&quot;Oct 11 08:35:18 master.k8s containerd[1903]: time=&quot;2023-10-11T08:35:18.606581001+08:00&quot; level=info msg=&quot;trying next host&quot; error=&quot;failed to do request: Head \\&quot;https://asia-east1-docker.pkg.dev/v2/k8s-artifacts-prod/images/pause/manifests/3.6\\&quot;: dial tcp 108.177.125.82:443: connect: connection refused&quot; host=registry.k8s.io...\n\n报错显示containerd拉去镜像失败。error&#x3D;”failed to get sandbox image&quot;registry.k8s.io&#x2F;pause:3.6&quot;\n解决方法：修改containered配置\n\n运行containerd config dump &gt; &#x2F;etc&#x2F;containerd&#x2F;config.toml 命令，将当前配置导出到文件，并修改sandbox_image配置。\n\n## 修改配置文件/etc/containerd/config.toml， 更改sandbox_image配置[plugins]  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]    sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;\n\n\n重启containerd\n\nsystemctl restart containerd#查看containerd当前配置，验证pause镜像是否生效containerd config dump | grep pause\n\n","tags":["kubernetes"]},{"title":"个人博客搭建笔记","url":"/2023/12/24/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/","content":"个人博客搭建笔记Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。\n\n一、环境准备1. 安装node.jsnode.js的安装与配置教程-CSDN博客\n2. 安装gitGit 2.43.0的安装教程-CSDN博客\n二、搭建博客\n以管理员的身份运行cmd输入命令下载hexo框架\n\nnpm install -g hexo-cli\n\n出现下图所示样式表示下载成功，因为我已经下载过了，所以没有什么变化。图中的警告先不用管，不影响使用。警告的大致意思是fsevents不支持windows平台。因为它是适用于苹果系统的，但是我们下载框架的时候是全都下载的，所以会出现这个警告。\n\n在自己想要存放博客的文件夹下新建一个文件，名字自拟。从本文件夹直接进入cmd，或者先进入cmd，cd该文件夹下。输入命令初始化一个博客。\nhexo init\n\n初始化中断，根据提示可以看到是在安装依赖时出了问题。\n\n原因是因为国内现在无法百分百概率访问Github，因此npm可能会下载失败；也有可能是因为文件权限的问题。总之按照提示再重新操作一遍以管理员的身份运行cmd并进入新建的博客文件夹下，使用hexo init命令后居然成功了。如下图所示，出现 Start blogging with Hexo 字样代表成功。\n\n初始化完成后使用命令就可以访问自己的博客了。\nhexo s\n\n按住ctrl键鼠标左键点击即可跳转到博客网页。\n\n博客网站如下图所示，默认会新建一篇文章。至此，博客的搭建工作告一段落。\n\n\n三、将博客部署到Github上使用命令安装一键将博客推送至GitHub上的插件\nnpm install hexo-deployer-git --save\n\n使用管理员的身份运行cmd输入命令后安装成功。\n\n在Github上创建一个个人仓库用于存放博客，首先登录GitHub，在个人仓库中找到新建仓库点击进入。\n\n仓库名为自己的GitHub用户名.github.io，如图所示，一定要这样设置，不然会不起作用。\n\n描述根据自己需要填写，然后点击创建仓库。\n\n创建完成后会自动跳转到你刚才创建的仓库内，在仓库中找到如下图所示位置，点击复制，后面修改博客的配置文件时会用到。\n\n使用vscode或者记事本打开_config.yml找到deploy修改其中的内容为，保存并退出。\ndeploy:  type: &#x27;git&#x27;  repo: &#x27;https://github.com/dettry/dettry.github.io.git&#x27; #为你创建的GitHub个人仓库地址  branch: &#x27;master&#x27;\n\n进入cmd中cd到博客存放的路径下执行如下命令就可以将博客部署到GitHub上了。\nhexo cleanhexo ghexo d\n\n记得在推送之前先开启梯子，然后将代理服务器打开。\n首先右键网络选择网络和Internet设置。\n\n找到使用代理服务器，点击编辑将代理服务器打开然后保存。\n\n最后推送成功后在地址栏输入dettry.github.io即可访问自己的博客。\n","tags":["hexo"]}]
<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-04T06:29:08.115Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k8s集群搭建常见问题汇总</title>
    <link href="http://example.com/2024/05/04/kubeadm%E6%90%AD%E5%BB%BAKubernetes%E9%9B%86%E7%BE%A4%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2024/05/04/kubeadm%E6%90%AD%E5%BB%BAKubernetes%E9%9B%86%E7%BE%A4%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2024-05-04T05:50:36.000Z</published>
    <updated>2024-05-04T06:29:08.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kubeadm搭建Kubernetes集群问题汇总"><a href="#kubeadm搭建Kubernetes集群问题汇总" class="headerlink" title="kubeadm搭建Kubernetes集群问题汇总"></a>kubeadm搭建Kubernetes集群问题汇总</h1><h2 id="问题一：kubeadm-init-报错-ERROR-CRI-container-runtime-is-not-running需要使用的解决方法"><a href="#问题一：kubeadm-init-报错-ERROR-CRI-container-runtime-is-not-running需要使用的解决方法" class="headerlink" title="问题一：kubeadm init 报错 [ERROR CRI]: container runtime is not running需要使用的解决方法"></a>问题一：kubeadm init 报错 [ERROR CRI]: container runtime is not running需要使用的解决方法</h2><ol><li>kubernetes使用crictl命令管理CRI，查看其配置文件<code>/etc/crictl.yaml</code>。初始情况下没有这个配置文件，这里建议添加这个配置，否则kubeadm init时会报其他错。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#containered做进行时</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br><span class="line">#cri-docker做进行时</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#执行crictl images list命令不报错</span><br><span class="line">crictl images list</span><br></pre></td></tr></table></figure><ol start="2"><li>查看配置文件：&#x2F;etc&#x2F;containerd&#x2F;config.toml</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改 disabled_plugins = [&quot;cri&quot;]为 disabled_plugins = []</span><br></pre></td></tr></table></figure><p>重启containerd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure><h2 id="问题二：ERROR-FileContent–proc-sys-net-bridge-bridge-nf-call-iptables"><a href="#问题二：ERROR-FileContent–proc-sys-net-bridge-bridge-nf-call-iptables" class="headerlink" title="问题二：ERROR FileContent–proc-sys-net-bridge-bridge-nf-call-iptables"></a>问题二：ERROR FileContent–proc-sys-net-bridge-bridge-nf-call-iptables</h2><p>报错原因：网桥过滤和地址转发功能不可用</p><p>解决方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/sysctl.d/kubernetes.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 然后执行,生效</span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><p>如果执行上述命令报&#x2F;proc&#x2F;sys&#x2F;net&#x2F;bridge&#x2F;bridge-nf-call-iptables does not exist错误是因为网桥功能未开启，执行下面的命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe br_netfilter</span><br></pre></td></tr></table></figure><h2 id="问题三：kubelet报错failed-to-run-Kubelet-running-with-swap-on-is-not-supported"><a href="#问题三：kubelet报错failed-to-run-Kubelet-running-with-swap-on-is-not-supported" class="headerlink" title="问题三：kubelet报错failed to run Kubelet: running with swap on is not supported"></a>问题三：kubelet报错failed to run Kubelet: running with swap on is not supported</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure><h2 id="问题四：kubeadm-init时报错一些配置文件已存在"><a href="#问题四：kubeadm-init时报错一些配置文件已存在" class="headerlink" title="问题四：kubeadm init时报错一些配置文件已存在"></a>问题四：kubeadm init时报错一些配置文件已存在</h2><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><h2 id="问题五：kubeadm-init时，kubelet-报错crictl-–runtime-endpoint配置不对"><a href="#问题五：kubeadm-init时，kubelet-报错crictl-–runtime-endpoint配置不对" class="headerlink" title="问题五：kubeadm init时，kubelet 报错crictl –runtime-endpoint配置不对"></a>问题五：kubeadm init时，kubelet 报错crictl –runtime-endpoint配置不对</h2><p>从日志看出时crictl命令运行时有问题。unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;containerd&#x2F;containerd.sock不存在。运行crictl命令，发现同样报错。出现报错的原因是crictl下载镜像时使用的是默认端点<code>[unix:///var/run/dockershim.sock unix:///run/containerd/containerd.sock unix:///run/crio/crio.sock unix:///var/run/cri-dockerd.sock]</code>。这些端点废弃了，需要重新指定<code>containerd.sock</code>。后面的报错就是找不到dockershim.sock。</p><p><strong>解决方法：修改crictl文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#containered做进行时</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br><span class="line">#cri-docker做进行时</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#执行crictl images list命令不报错</span><br><span class="line">crictl images list</span><br></pre></td></tr></table></figure><h2 id="问题六：报Usage-of-CRI-endpoints-without-URL-scheme-is-deprecated-and-can-cause-kubelet-errors-in-the-future-警告"><a href="#问题六：报Usage-of-CRI-endpoints-without-URL-scheme-is-deprecated-and-can-cause-kubelet-errors-in-the-future-警告" class="headerlink" title="问题六：报Usage of CRI endpoints without URL scheme is deprecated and can cause kubelet errors in the future.警告"></a>问题六：报Usage of CRI endpoints without URL scheme is deprecated and can cause kubelet errors in the future.警告</h2><p>W0504 10:46:57.238606    6046 initconfiguration.go:120] Usage of CRI endpoints without URL scheme is deprecated and can cause kubelet errors in the future. Automatically prepending scheme “unix” to the “criSocket” with value “&#x2F;var&#x2F;run&#x2F;cri-dockerd.sock”. Please update your configuration!  </p><p>如果是contained做进行时就执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo crictl config \</span><br><span class="line">--set runtime-endpoint=unix:///var/run/containerd/containerd.sock \</span><br><span class="line">--set image-endpoint=unix:///var/run/containerd/containerd.sock</span><br><span class="line">#或者</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>如果时cri-docker做进行时就执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo crictl config \</span><br><span class="line">--set runtime-endpoint=unix:///var/run/cri-dockerd.sock \</span><br><span class="line">--set image-endpoint=unix:///var/run/cri-dockerd.sock</span><br><span class="line">#或者</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="问题七：报错pause镜像获取失败"><a href="#问题七：报错pause镜像获取失败" class="headerlink" title="问题七：报错pause镜像获取失败"></a>问题七：报错pause镜像获取失败</h2><p>通过log提示执行命令<code>crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock ps -a</code> 发现没有容器在运行。查看containerd的日志，有如下报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">journalctl -fu containerd</span><br><span class="line">...</span><br><span class="line">Oct 11 08:35:16 master.k8s containerd[1903]: time=&quot;2023-10-11T08:35:16.760026536+08:00&quot; level=error msg=&quot;RunPodSandbox for &amp;PodSandboxMetadata&#123;Name:kube-apiserver-node,Uid:a5a7c15a42701ab6c9dca630e6523936,Namespace:kube-system,Attempt:0,&#125; failed, error&quot; error=&quot;failed to get sandbox image \&quot;registry.k8s.io/pause:3.6\&quot;: failed to pull image \&quot;registry.k8s.io/pause:3.6\&quot;: failed to pull and unpack image \&quot;registry.k8s.io/pause:3.6\&quot;: failed to resolve reference \&quot;registry.k8s.io/pause:3.6\&quot;: failed to do request: Head \&quot;https://asia-east1-docker.pkg.dev/v2/k8s-artifacts-prod/images/pause/manifests/3.6\&quot;: dial tcp 108.177.125.82:443: connect: connection refused&quot;</span><br><span class="line">Oct 11 08:35:18 master.k8s containerd[1903]: time=&quot;2023-10-11T08:35:18.606581001+08:00&quot; level=info msg=&quot;trying next host&quot; error=&quot;failed to do request: Head \&quot;https://asia-east1-docker.pkg.dev/v2/k8s-artifacts-prod/images/pause/manifests/3.6\&quot;: dial tcp 108.177.125.82:443: connect: connection refused&quot; host=registry.k8s.io</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>报错显示containerd拉去镜像失败。error&#x3D;”failed to get sandbox image&quot;registry.k8s.io&#x2F;pause:3.6&quot;</p><p><strong>解决方法：修改containered配置</strong></p><ul><li>运行containerd config dump &gt; &#x2F;etc&#x2F;containerd&#x2F;config.toml 命令，将当前配置导出到文件，并修改sandbox_image配置。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 修改配置文件/etc/containerd/config.toml， 更改sandbox_image配置</span><br><span class="line">[plugins]</span><br><span class="line">  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span><br><span class="line">    sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;</span><br></pre></td></tr></table></figure><ul><li>重启containerd</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart containerd</span><br><span class="line"></span><br><span class="line">#查看containerd当前配置，验证pause镜像是否生效</span><br><span class="line">containerd config dump | grep pause</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kubeadm搭建Kubernetes集群问题汇总&quot;&gt;&lt;a href=&quot;#kubeadm搭建Kubernetes集群问题汇总&quot; class=&quot;headerlink&quot; title=&quot;kubeadm搭建Kubernetes集群问题汇总&quot;&gt;&lt;/a&gt;kubeadm搭建Ku</summary>
      
    
    
    
    
    <category term="kubernetes" scheme="http://example.com/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>k8s集群搭建教程（使用cri-docker+flannel）</title>
    <link href="http://example.com/2024/05/04/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2024/05/04/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</id>
    <published>2024-05-04T04:24:36.000Z</published>
    <updated>2024-05-04T06:27:16.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k8s集群搭建教程（使用cri-docker-flannel）"><a href="#k8s集群搭建教程（使用cri-docker-flannel）" class="headerlink" title="k8s集群搭建教程（使用cri-docker+flannel）"></a>k8s集群搭建教程（使用cri-docker+flannel）</h1><h2 id="1-准备工作（所有节点）"><a href="#1-准备工作（所有节点）" class="headerlink" title="1. 准备工作（所有节点）"></a>1. 准备工作（所有节点）</h2><h3 id="1-1-系统环境-我是没配置也部署成功了，可以先部署，如果失败了再回来进行系统环境优化"><a href="#1-1-系统环境-我是没配置也部署成功了，可以先部署，如果失败了再回来进行系统环境优化" class="headerlink" title="1.1 系统环境(我是没配置也部署成功了，可以先部署，如果失败了再回来进行系统环境优化)"></a>1.1 系统环境(我是没配置也部署成功了，可以先部署，如果失败了再回来进行系统环境优化)</h3><ul><li>系统环境优化配置</li></ul><p>CentOs 7.x系统自带的3.10.x内核存在一些bug，导致运行的docker，kubernetes不稳定，获取源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm</span><br></pre></td></tr></table></figure><ul><li>安装内核，装完成后检查 &#x2F;boot&#x2F;grub2&#x2F;grub.cfg中对应内核menuentry中是否包含 initrd16 配置，如果没有，再安装一次！耗时可能会有点久</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=elrepo-kernel install -y kernel-lt </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#查看系统的全部内核</span><br><span class="line">rpm -qa | grep kernel</span><br><span class="line">#kernel-3.10.0-1160.el7.x86_64</span><br><span class="line">#kernel-lt-5.4.271-1.el7.elrepo.x86_64</span><br><span class="line">#kernel-tools-libs-3.10.0-1160.el7.x86_64</span><br><span class="line">#kernel-tools-3.10.0-1160.el7.x86_64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#设置开机从新内核启动</span><br><span class="line">grub2-set-default &#x27;CentoS Linux(5.4.271-1.el7.elrepo.x86_64) 7 (Core)&#x27;</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line">#查看正在使用的内核</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure><h3 id="1-2-系统参数设置"><a href="#1-2-系统参数设置" class="headerlink" title="1.2 系统参数设置"></a>1.2 系统参数设置</h3><ul><li>所有节点关闭swap和防火墙</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">#临时关闭swapoff</span><br><span class="line">swapoff -a</span><br><span class="line">#永久关闭swapoff（如果想永久关闭，将下面命令的#去掉）</span><br><span class="line">#sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><ul><li>禁用SELINUX</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config</span><br></pre></td></tr></table></figure><ul><li>所有节点设置主机名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname  k8s-master</span><br><span class="line">hostnamectl set-hostname  k8s-node1</span><br><span class="line">hostnamectl set-hostname  k8s-node2</span><br></pre></td></tr></table></figure><ul><li>所有节点主机名&#x2F;IP加入hosts解析</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line"></span><br><span class="line">加入如下内容：</span><br><span class="line">192.168.183.132 k8s-master</span><br><span class="line">192.168.183.133 k8s-node1</span><br><span class="line">192.168.183.134 k8s-node2</span><br></pre></td></tr></table></figure><ul><li>所有节点配置k8s内核</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kubernetes.conf &lt;&lt;EOF</span><br><span class="line">net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables=1</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.ipv4.tcp_tw_recycle=0</span><br><span class="line">vm.swappiness=0 #禁止使用swap空间，只有当系统OOM时才允许使用它</span><br><span class="line">vm.overcommit_memory=1 #不检查物理内存是否够用</span><br><span class="line">vm.panic_on_oom=0 #开启OOM</span><br><span class="line">fs.inotify.max_user_instances=8192</span><br><span class="line">fs.inotify.max_user_watches=1048576</span><br><span class="line">fs.file-max=52706963</span><br><span class="line">fs.nr_open=52706963</span><br><span class="line">net.ipv6.conf.all.disable_ipv6=1</span><br><span class="line">net.netfilter.nf_conntrack_max=2310720</span><br><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br><span class="line">net.ipv4.tcp_keepalive_intvl =15</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 36000</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_max_orphans = 327680</span><br><span class="line">net.ipv4.tcp_orphan_retries = 3</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 16384</span><br><span class="line">net.ipv4.ip_conntrack_max = 65536</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 16384</span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br><span class="line">net.core.somaxconn = 16384</span><br><span class="line">EOF</span><br><span class="line">cp kubernetes.conf /etc/sysctl.d/kubernetes.conf</span><br><span class="line">sysctl -p /etc/sysctl.d/kubernetes.conf</span><br></pre></td></tr></table></figure><ul><li>limit优化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ulimit -SHn 65535</span><br><span class="line"> </span><br><span class="line">cat &lt;&lt;EOF &gt;&gt; /etc/security/limits.conf</span><br><span class="line">soft nofile 655360</span><br><span class="line">hard nofile 131072</span><br><span class="line">soft nproc 655350</span><br><span class="line">hard nproc 655350</span><br><span class="line">soft memlock unlimited</span><br><span class="line">hard memlock unlimited</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="2-组件安装（所有节点）"><a href="#2-组件安装（所有节点）" class="headerlink" title="2. 组件安装（所有节点）"></a>2. 组件安装（所有节点）</h2><h3 id="2-1-Docker安装"><a href="#2-1-Docker安装" class="headerlink" title="2.1 Docker安装"></a>2.1 Docker安装</h3><p>如果你的系统未安装过Docker，直接按照下面步骤操作即可。如果之前安装过，请先自行百度卸载干净。</p><ul><li>安装软件包并设置存储库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><ul><li>安装Docker</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><ul><li>启动Docker</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><ul><li>创建 &#x2F;etc&#x2F;docker目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/docker</span><br><span class="line"> </span><br><span class="line">#配置daemon</span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;exec-opts&quot;:[&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">    &quot;log-driver&quot;:&quot;json-file&quot;,</span><br><span class="line">    &quot;log-opts&quot;:&#123;</span><br><span class="line">        &quot;max-size&quot;:&quot;100m&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line"> </span><br><span class="line">#重启docker服务</span><br><span class="line">systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl enable docker</span><br></pre></td></tr></table></figure><ul><li>注意事项</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubernetes 1.24+版本之后，docker必须要加装cir-docker</span><br></pre></td></tr></table></figure><h3 id="2-2-安装cri-docker"><a href="#2-2-安装cri-docker" class="headerlink" title="2.2 安装cri-docker"></a>2.2 安装cri-docker</h3><p><strong>go安装</strong></p><ul><li>下载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://golang.google.cn/dl/go1.20.12.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#安装go</span><br><span class="line">rm -rf /usr/local/go &amp;&amp; tar -C /usr/local/ -xzvf go1.20.12.linux-amd64.tar.gz </span><br></pre></td></tr></table></figure><ul><li>设置环境变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">添加以下内容到profile 文件中（gopath应提前创建好，或者配置完成后别忘了创建）</span><br><span class="line">#go setting</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/usr/local/gopath</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br><span class="line"></span><br><span class="line">#保存退出执行</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>构建cri-dockerd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Mirantis/cri-dockerd.git</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd cri-dockerd</span><br><span class="line">mkdir bin</span><br><span class="line">go build -o bin/cri-dockerd</span><br><span class="line">mkdir -p /usr/local/bin</span><br><span class="line">install -o root -g root -m 0755 bin/cri-dockerd /usr/local/bin/cri-dockerd</span><br><span class="line">cp -a packaging/systemd/* /etc/systemd/system</span><br><span class="line">sed -i -e &#x27;s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,&#x27; /etc/systemd/system/cri-docker.service</span><br></pre></td></tr></table></figure><p><strong>Kubernetes使用</strong></p><ul><li>编辑：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/cri-docker.service</span><br></pre></td></tr></table></figure><p>在ExecStart后面追加，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/local/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9</span><br></pre></td></tr></table></figure><ul><li>创建cri-docker启动文件，然后拷贝到其他节点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/cri-docker.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=CRI Interface for Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.mirantis.com</span><br><span class="line">After=network-online.target firewalld.service docker.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=cri-docker.socket</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/bin/cri-dockerd --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br><span class="line"> </span><br><span class="line">StartLimitBurst=3</span><br><span class="line"> </span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"> </span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"> </span><br><span class="line">TasksMax=infinity</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/cri-docker.socket</span><br><span class="line">[Unit]</span><br><span class="line">Description=CRI Docker Socket for the API</span><br><span class="line">PartOf=cri-docker.service</span><br><span class="line"> </span><br><span class="line">[Socket]</span><br><span class="line">ListenStream=%t/cri-dockerd.sock</span><br><span class="line">SocketMode=0660</span><br><span class="line">SocketUser=root</span><br><span class="line">SocketGroup=docker</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=sockets.target</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp /usr/lib/systemd/system/cri-docker.service /usr/lib/systemd/system/cri-docker.socket root@k8s-node1:/usr/lib/systemd/system/</span><br><span class="line"> </span><br><span class="line">scp /usr/lib/systemd/system/cri-docker.service /usr/lib/systemd/system/cri-docker.socket root@k8s-node2:/usr/lib/systemd/system/</span><br></pre></td></tr></table></figure><ul><li>启动cri-docker并设置开机自动启动</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload ; systemctl enable cri-docker --now</span><br><span class="line">#查看状态</span><br><span class="line">systemctl is-active cri-docker</span><br></pre></td></tr></table></figure><h3 id="2-3-所有节点安装-kubeadm，kubelet-和-kubectl"><a href="#2-3-所有节点安装-kubeadm，kubelet-和-kubectl" class="headerlink" title="2.3 所有节点安装 kubeadm，kubelet 和 kubectl"></a>2.3 所有节点安装 kubeadm，kubelet 和 kubectl</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line">setenforce 0</span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure><ul><li>设置kubelet开机自启</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now kubelet.service</span><br></pre></td></tr></table></figure><h2 id="3-搭建k8s集群"><a href="#3-搭建k8s集群" class="headerlink" title="3. 搭建k8s集群"></a>3. 搭建k8s集群</h2><h3 id="3-1-k8s初始化"><a href="#3-1-k8s初始化" class="headerlink" title="3.1 k8s初始化"></a>3.1 k8s初始化</h3><ul><li>在master上初始化k8s</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.183.132 \</span><br><span class="line">--image-repository=registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version=v1.28.2 \</span><br><span class="line">--service-cidr=10.96.0.0/12  \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">--cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure><ul><li>按照提示创建kubeconfig文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><ul><li>重新初始化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset --cri-socket /var/run/cri-dockerd.sock</span><br><span class="line"> </span><br><span class="line">rm -rf .kube/</span><br><span class="line">sudo mkdir ~/.kube</span><br><span class="line">sudo cp /etc/kubernetes/admin.conf ~/.kube/</span><br><span class="line">cd ~/.kube</span><br><span class="line">mv admin.conf config</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure><h3 id="3-2-node节点的加入"><a href="#3-2-node节点的加入" class="headerlink" title="3.2 node节点的加入"></a>3.2 node节点的加入</h3><ul><li>加入节点</li></ul><p>在node节点如k8s-node1上执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join kubeadm初始化成功后的token --cri-socket /var/run/cri-dockerd.sock</span><br><span class="line">例如我的kubeadm初始化成功后的token为：</span><br><span class="line">192.168.183.132:6443 --token vib96t.hmkd7hj7ykdigmp1 --discovery-token-ca-cert-hash sha256:c0bb3a82a4642cc4fe253edd0533ad8136b34dc243f274aa3cea27abc46e321f</span><br></pre></td></tr></table></figure><ul><li>查看节点状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">此时所有节点的状态为NotReady，这是因为还没有安装flannel网络插件</span><br></pre></td></tr></table></figure><ul><li>网络插件下载并安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#如果网络故障也可直接在网站中下载好文件后上传至虚拟机中（自行翻墙）</span><br><span class="line">wget https://github.com/flannel-io/flannel/releases/download/v0.24.3/kube-flannel.yml</span><br><span class="line">#执行</span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br><span class="line">#或者（两者的结果是一样的，只是执行工作原理不一样，想深究的可以自行查阅资料）</span><br><span class="line">kubectl create -f kube-flannel.yml</span><br></pre></td></tr></table></figure><ul><li>再次查看节点状态全部变为 Ready</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line">#如果查看节点没有变成ready，先等个几分钟，因为网络传输需要一定的时间。等几分钟后如果还是NotReady，再根据报错原因查找解决方案</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;k8s集群搭建教程（使用cri-docker-flannel）&quot;&gt;&lt;a href=&quot;#k8s集群搭建教程（使用cri-docker-flannel）&quot; class=&quot;headerlink&quot; title=&quot;k8s集群搭建教程（使用cri-docker+flannel</summary>
      
    
    
    
    
    <category term="kubernetes" scheme="http://example.com/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://example.com/2024/03/16/Java%E8%AF%AD%E8%A8%80/"/>
    <id>http://example.com/2024/03/16/Java%E8%AF%AD%E8%A8%80/</id>
    <published>2024-03-16T08:39:36.000Z</published>
    <updated>2024-05-04T06:24:36.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h1><h2 id="1-语言基础"><a href="#1-语言基础" class="headerlink" title="1. 语言基础"></a>1. 语言基础</h2><h3 id="1-1-基础语法"><a href="#1-1-基础语法" class="headerlink" title="1.1 基础语法"></a>1.1 基础语法</h3><ul><li><strong>数据类型</strong></li></ul><p>数据类型分为两类：基本数据类型、引用数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java中的基本数据类型只有**四类八种**</span><br><span class="line"></span><br><span class="line">整数型：byte、short、int、long</span><br><span class="line"></span><br><span class="line">short占两字节</span><br><span class="line"></span><br><span class="line">int 占用四个字节</span><br><span class="line"></span><br><span class="line">long 占用八个字节</span><br></pre></td></tr></table></figure><ul><li>浮点型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浮点型有两种：float、double</span><br><span class="line">float占用四位，double占用八位</span><br></pre></td></tr></table></figure><ul><li>字符型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符型为char，char类型是一个单一的16位Unicode字符。</span><br></pre></td></tr></table></figure><ul><li>布尔型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its &quot;size&quot; isn&#x27;t something that&#x27;s precisely defined.</span><br><span class="line"> </span><br><span class="line">翻译：布尔数据类型只有两种可能的值：true和false。使用这个数据类型用于追踪true/false状况的简单标识。这个数据类型表示1bit的信息，但是它的”大小“没有被精确定义。</span><br></pre></td></tr></table></figure><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20231228151136962.png"                        alt="image-20231228151136962"                 ></p><ul><li>引用数据类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要不是基本数据类型就是引用数据类型。</span><br></pre></td></tr></table></figure><ul><li>自动类型转换（隐式）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换规则： 数据范围必须是**从小到大**，即由小的转换成大的，自动转换。</span><br></pre></td></tr></table></figure><ul><li>强制类型转换（显式）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意事项：</span><br><span class="line">1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。 </span><br><span class="line">2. byte/short/char这三种类型都可以发生数学运算，例如加法“+”。</span><br><span class="line">3. byte/short/char这三种类型在运算的时候都会首先提升成为int类型，然后再计算。</span><br><span class="line">例：byte+byte-&gt;int+int-&gt;int</span><br><span class="line">4. boolean类型不能发生数据类型转换</span><br></pre></td></tr></table></figure><ul><li>运算符的优先级</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单目（一元）&gt;算术运算符&gt;移位&gt;关系&gt;位&gt;条件(三元)&gt;赋值</span><br></pre></td></tr></table></figure><ul><li><strong>基础语法</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 大小写敏感： Java是大小写敏感的语言，例如Hello和hello是不同的，这其实就是Java的字符串表示方式。</span><br><span class="line">2. 类名：类名使用 UpperCamelCase 风格，但以下情形例外： DO / BO / DTO / VO / AO /</span><br><span class="line">PO / UID 等。</span><br><span class="line">正例： ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion</span><br><span class="line">反例： forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion</span><br><span class="line">3. 包名：包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用</span><br><span class="line">单数形式，但是类名如果有复数含义，类名可以使用复数形式。</span><br><span class="line">正例： 应用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils（此规则参考 spring 的框架结构）</span><br><span class="line">4. 方法名、变量名、参数名：都统一使用 lowerCamelCase 风格</span><br><span class="line">正例： localValue / getHttpMessage() / inputUserId</span><br></pre></td></tr></table></figure><ul><li><strong>方法</strong></li><li>构造方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">作用：用来创建对象的</span><br><span class="line">注意事项：</span><br><span class="line">1. 构造方法的名称必须和所在类的名称完全一样，就连大小写也要一样</span><br><span class="line">2. 构造方法不要写返回值类型，连void都不写</span><br><span class="line">3. 构造方法不能return一个具体的返回值</span><br><span class="line">4. 如果没有编写任何构造方法，那么编译器会默认分配一个构造方法</span><br><span class="line">5. 一旦编写了一个构造方法，那么编译器就不会再分配任何构造方法</span><br></pre></td></tr></table></figure><ul><li>静态方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态方法又叫类方法。</span><br></pre></td></tr></table></figure><ul><li>非静态方法（成员方法）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法之间的调用注意事项：</span><br><span class="line">1. 同类型的方法之间可以直接调用</span><br><span class="line">2. 静态方法调用非静态方法需要先new一个对象，然后通过对象进行调用。</span><br><span class="line">3. 非静态方法可以直接调用静态方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>方法重载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">多个方法的名称相同，但是参数列表不一样。</span><br><span class="line">方法重载与下列因素相关：</span><br><span class="line">1. 参数个数不同</span><br><span class="line">2. 参数类型不同</span><br><span class="line">3. 多参数类型顺序不同</span><br><span class="line">方法重载与下列因素无关：</span><br><span class="line">1. 与参数名称无关</span><br><span class="line">2. 与方法的返回值类型无关</span><br><span class="line">3. </span><br></pre></td></tr></table></figure><ul><li>参数传递机制</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java的参数传递机制都是：值传递</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>数组</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Java的内存划分成为5个部分：</span><br><span class="line">1. 栈内存（stack）：存放的都是方法中的局部变量。  方法的运行一定要在栈中运行。</span><br><span class="line">         局部变量： 方法的参数、方法&#123;&#125;内部的变量</span><br><span class="line">2. 堆内存（heap）: 凡是new出来的东西都在堆当中。</span><br><span class="line">        堆内存里面的东西都有一个地址值：16进制</span><br><span class="line">        堆内存中的数据都有默认值。规则：</span><br><span class="line">                 整数         默认0</span><br><span class="line">                 浮点数       默认0.0</span><br><span class="line">                 字符         默认&#x27;\u0000&#x27;</span><br><span class="line">                 布尔         默认false</span><br><span class="line">                 引用类型      默认null</span><br><span class="line">3. 方法区（）: 存储.class相关信息，包含方法的信息。</span><br><span class="line"></span><br><span class="line">4. 本地方法栈（）： 与操作系统相关</span><br><span class="line">5. 寄存器（）： 与cpu相关</span><br></pre></td></tr></table></figure><h3 id="1-2-面向对象"><a href="#1-2-面向对象" class="headerlink" title="1.2 面向对象"></a>1.2 面向对象</h3><ul><li><strong>特点</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成指挥者。</span><br></pre></td></tr></table></figure><p><strong>面向对象语言包含三大基本特征：</strong></p><ul><li><p>封装</p><p>就是将一些细节信息隐藏起来，对外界不可见。</p><ol><li>方法就是一种封装</li><li>private关键字也是一种封装</li></ol><p>一旦使用private进行修饰，那么本类当中仍然可以随意访问，但是超出了本类范围之外就不能再直接访问了。</p><p>可以使用getter&#x2F;setter方法间接访问private成员变量。</p></li><li><p>继承</p></li></ul><p>​        继承是多态的前提，如果没有继承，就没有多态。</p><p>​        继承主要解决的问题就是：<strong>共性抽取</strong></p><pre><code>   **变量重名的解决方法**</code></pre><p>​         局部变量：                    直接写成员变量名</p><p>​         本类的成员变量：          this.成员变量名</p><p>​          父类的成员变量：          super.成员变量名</p><pre><code>  **重写（override）**    </code></pre><p>​         概念：在继承关系中，方法的名称一样，参数列表一样。</p><p>​         方法重写（override）：方法名称一样，参数列表也一样。（覆盖重写）</p><p>​         方法重载（overload）：方法名称一样，参数列表不一样。</p><pre><code>   **覆盖重写的注意事项：**              1. 必须保证父子类之间的方法名称相同，参数列表也相同。            2. 子类方法的权限必须大于等于父类方法的权限修饰符。</code></pre><p>​         public&gt;protected&gt;(default)&gt;private</p><p>​         备注：（default）不是关键字default，而是什么修饰符也不用。</p><p>​<strong>继承关系中，父子类构造方法的访问特点：</strong></p><pre><code>1. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造</code></pre><p>​注意事项：</p><p>​子类必须调用父类构造方法，不写则默认super（），写了则用写的指定的super调用，super只能有一个，还必须是第一个。</p><p>​<strong>Java继承的三大特点</strong></p><ol><li>Java语言是单继承的，即一个类的直接父类只能有唯一一个。</li><li>Java语言可以多级继承。</li><li>一个子类只能有一个父类，但是一个父类可以有多个子类。</li></ol><p> 如果父类当中的方法不确定如何进行{}方法体实现，那么这就应该是一个抽象方法。</p><p>抽象类：抽象方法所在的类必须是抽象类才行。在class之前写上abstract即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="comment">//这是一个抽象方法，代表吃东西，但是具体吃什么不确定。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何使用抽象类和抽象方法</strong></p><ol><li><p>不能直接创建new抽象类对象</p></li><li><p>必须用一个子类来继承抽象父类。</p></li><li><p>子类必须覆盖重写抽象父类当中的所有抽象方法。</p><p>覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号</p><ol start="4"><li>创建子类对象进行使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>多态</li></ul><p>一个对象拥有多种形态，这个就叫对象的多态性。</p><p><strong>代码当中体现多态性，其实就是一句话，父类引用指向子类对象。</strong></p><p>格式：</p><p>父类名称 对象名 &#x3D; new 子类名称（）；</p><p>或者</p><p>接口名称 对象名 &#x3D; new  实现类名称（）；</p><p>访问成员变量和方法的规则：</p><p>访问成员方法：等号右边new的谁，优先用谁，没有则向上找。</p><p>直接通过对象名称访问成员变量：等号左边是谁，优先用谁，没有则向上找。</p><p>间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。</p><p><strong>对象的转型</strong></p><ol><li>对象的向上转型，其实就是多态写法：</li></ol><p>格式：父类名称 对象名 &#x3D; new 子类名称（）；</p><ol start="2"><li>对象的向下转型，其实是一个【还原】的动作</li></ol><p>格式：子类名称 对象名 &#x3D; （子类名称） 父类对象</p><p>注意事项：</p><ol><li>必须保证对象本来创建的时候就是A,才能向下转型成为A。</li><li>如果创建的对象本来不是A，非要向下转型为A就会报错。</li></ol><p> <strong>四种权限修饰符</strong></p><p><strong>内部类</strong></p><ol><li>成员内部类</li><li>局部内部类（包含匿名内部类）</li></ol><p>成员内部类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">      修饰符 class 内部类名称&#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">注意：内用外，随意访问； 外用内，需要内部类对象。</span><br></pre></td></tr></table></figure><p>局部内部类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">      修饰符 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">              class 局部内部类名称&#123;</span><br><span class="line">      </span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">接口名称 对象名称 =  <span class="keyword">new</span> 接口名称（）&#123;</span><br><span class="line"> 覆盖重写所有抽象方法</span><br><span class="line">&#125;；</span><br><span class="line">注意事项：</span><br><span class="line">    <span class="number">1.</span> 匿名内部类在创建对象的时候只能使用唯一一次</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li><strong>类和对象</strong></li></ul><p><strong>什么是类</strong></p><ul><li>类：是一组相关属性和行为的集合。</li></ul><p>现实中，描述一类事物：</p><ul><li><p>属性：就是该事物的特征信息。（是什么）（成员变量）</p></li><li><p>行为：就是该事物能够做什么。（成员方法）成员方法不要写static关键字。</p></li></ul><p><strong>什么是对象</strong></p><ul><li>对象：是一类事物的具体体香。对象是类的一个实例。</li></ul><p><strong>类与对象的关系</strong></p><ul><li>类是对一类事物的描述，是抽象的。</li><li>对象是一类事物的实例，是具体的。</li><li>类是对象的模板，对象是类的实体。</li></ul><p><strong>成员变量和局部变量的区别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. 定义的位置不一样</span><br><span class="line">局部变量：在方法的内部</span><br><span class="line">成员变量：在方法的外部，直接写在类当中。</span><br><span class="line"></span><br><span class="line">2. 作用范围不一样</span><br><span class="line">局部变量：只有方法当中才可以使用</span><br><span class="line">成员变量：整个类全可以通用</span><br><span class="line"></span><br><span class="line">3. 默认值不一样</span><br><span class="line">局部变量：没有默认值，如果要想使用，必须手动赋值</span><br><span class="line">成员变量：如果没有赋值，会有默认值，规则和数组一样。</span><br><span class="line"></span><br><span class="line">4. 内存的位置不一样</span><br><span class="line">局部变量：位于栈内存</span><br><span class="line">成员变量：位于堆内存</span><br><span class="line"></span><br><span class="line">5. 生命周期不一样</span><br><span class="line">局部变量：随着方法进栈而生，随着方法出栈而亡</span><br><span class="line">成员变量：随着对象创建而生，随着对象被垃圾回收而亡。</span><br></pre></td></tr></table></figure><ul><li><strong>对象数组</strong></li></ul><p>数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变。</p><ul><li><strong>字符串</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 字符串的内容不可变</span><br><span class="line">2. 字符串可以共享使用</span><br><span class="line">3. 字符串效果上相当于char[]字符数组，但是底层原理是byte[]字节数组</span><br><span class="line">在堆内存中有一个字符串常量池。</span><br><span class="line">常用方法：</span><br><span class="line">equals</span><br><span class="line">length()</span><br><span class="line">concat:连接字符串</span><br><span class="line">charAt:</span><br><span class="line">indexOf:</span><br></pre></td></tr></table></figure><p>StringBuilder类：字符串缓冲区，可以提高字符串的效率</p><p>常用方法：</p><p>append</p><p>toString</p><ul><li><strong>静态关键字static</strong></li></ul><p>一旦用了static关键字，那么这样的内容不再属于对象自己，</p><p>而是属于类的，所以凡是本类的对象，都共享同一份。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一旦使用static修饰成员方法，那么就成为了静态方法，静态方法不属于对象，而是属于类的。</span><br><span class="line"></span><br><span class="line">如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。</span><br><span class="line"></span><br><span class="line">如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。</span><br><span class="line"></span><br><span class="line">无论是成员变量还是方法，如果有了static，都推荐使用类名称进行调用。</span><br><span class="line"></span><br><span class="line">静态变量：类名称.静态变量</span><br><span class="line"></span><br><span class="line">静态方法：类名称.静态方法（）</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line">1. 静态方法当中不能使用this</span><br></pre></td></tr></table></figure><p><strong>静态代码块</strong></p><p>特点：当第一次用到本类时，静态代码块执行唯一的一次。</p><p>静态内容总是优先于非静态，所以静态代码块比构造方法先执行。</p><p>静态代码块的用途：</p><p>用来一次性的对静态成员变量进行赋值。</p><p><strong>Arrays工具类</strong></p><p>toString(数组)：将参数数组变成字符串（按照默认格式：[元素1，元素2,………]）</p><h3 id="1-3-接口"><a href="#1-3-接口" class="headerlink" title="1.3 接口"></a>1.3 接口</h3><p>接口就是多个类的公共规范</p><p>接口是一种引用数据类型，最重要的内容就是其中的：<strong>抽象方法</strong>。</p><p>从Java 8开始，接口 里允许定义默认方法。</p><p>备注：接口当中的默认方法可以解决接口升级的问题。</p><p><strong>什么是接口升级？</strong></p><p>就是已经投入使用的接口，想在其中添加新的方法，这时如果直接添加，会导致所有实现该接口的类报错，但是使用default默认方法可以解决此问题，并且该方法也可以被其他接口实现类覆盖重写。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Java 9 开始，接口中允许定义私有方法。</p><ol><li>普通私有方法，解决多个默认方法之间的重复代码问题</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>静态私有方法：解决多个静态方法之间重复代码问题</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line"></span><br><span class="line">方法体</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口与接口之间是多继承的。</p><ul><li><strong>日期时间类</strong></li></ul><p>date</p><ul><li><strong>DateFormat类</strong></li></ul><p>日期时间格式化类</p><ul><li><strong>包装类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基本类型             对应的包装类</span><br><span class="line"><span class="type">byte</span>                  Byte</span><br><span class="line"><span class="type">short</span>                 Short</span><br><span class="line"><span class="type">int</span>                   Integer</span><br><span class="line"><span class="type">long</span>                  Long</span><br><span class="line"><span class="type">float</span>                 Float</span><br><span class="line"><span class="type">double</span>                Double</span><br><span class="line"><span class="type">char</span>                  Character</span><br><span class="line"><span class="type">boolean</span>               Boolean</span><br></pre></td></tr></table></figure><p><strong>装箱与拆箱</strong></p><p>装箱：从基本类型转换成对应的包装类对象</p><p>拆箱：从包装类对象转换为对应的基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i= Integer.valueOf(<span class="number">4</span>)<span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i.intValue();<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><h3 id="1-4-容器"><a href="#1-4-容器" class="headerlink" title="1.4 容器"></a>1.4 容器</h3><ul><li>collection集合</li></ul><p><strong>集合：</strong>集合是Java中提供的一种容器，可以用来存储多个数据。</p><p>集合和数组既然都是容器，它们有啥区别？</p><ol><li>数组的长度是固定的，集合的长度是可变的</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象，而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ol><p><strong>常用共性方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>: 添加对象</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>: 清空集合</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E e)</span>: 把给定对象从当前集合删除</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span>: 判断当前集合中是否包含给定的对象</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>:</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>: 返回集合中的元素个数</span><br><span class="line"><span class="keyword">public</span> Object[] toArray(): 把集合中的元素，存储到数组中</span><br></pre></td></tr></table></figure><p><strong>List</strong></p><ol><li>有序的集合（存储和取出元素顺序相同）</li><li>允许存储重复的元素</li><li>有索引，可以使用普通的for循环遍历</li></ol><ul><li>ArrayList（查询快，增删慢）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>常用方法：</p><p>add,get,remove,size</p><ul><li>LinkedList（查询慢，增删快）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;E&gt; linked = <span class="keyword">new</span> <span class="title class_">LinkerdList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>Set</strong></p><ol><li>不允许存储重复的元素</li><li>没有索引</li></ol><ul><li>HashSet</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;E&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><ol><li>是一个无序集合</li><li>底层是一个哈希表结构</li></ol><p>哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑i地址，是模拟出来的地址，不是数据实际存储的物理地址）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>:获取对象的哈希码值</span><br></pre></td></tr></table></figure><p>哈希表（查询快）</p><p>哈希表的结构，jdk1.8之后：</p><ol><li>哈希表&#x3D;数组+链表；</li><li>哈希表&#x3D;数组+红黑树；</li></ol><ul><li>LInkedHashSet</li></ul><p>LInkedHashSet特点：</p><p>底层是一个哈希表+链表，多了一条链表（记录元素的存储顺序），保证元素有序。</p><p><strong>HashSet存储自定义类型元素</strong></p><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。</p><p><strong>可变参数</strong></p><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（数据类型...变量名）&#123;</span><br><span class="line">&#125;</span><br><span class="line">实例</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>... arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">注意事项</span><br><span class="line">    <span class="number">1.</span> 一个方法的参数列表只能有一个可变参数</span><br><span class="line">    <span class="number">2.</span> 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾。</span><br><span class="line">可变参数的特殊（终极）写法</span><br><span class="line">    实例</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Object...obj)</span>&#123;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Map</strong></p><p>特点</p><ol><li>map集合是一个双列集合，一个元素包含两个值（key:value）</li><li>map集合中的元素，key和value的数据类型可以相同，也可以不同</li><li>map中key是不允许重复的，value可以重复</li><li>map中的key和value一一对应</li></ol><ul><li>HashMap（初始长度16）</li></ul><p>特点：</p><ol><li>HashMap集合底层是哈希表：查询速度特别快</li><li>hashMap是一个无序集合，存储和取出元素的顺序可能不一致</li></ol><ul><li>LinkedHashMap</li></ul><p>特点：</p><ol><li>底层是哈希表+链表（保证迭代的顺序）</li><li>是一个有序的集合，存储和取出元素的顺序是一致的</li></ol><ul><li>TreeMap</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>Collections工具类</p><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? <span class="built_in">super</span> T&gt; c, T... elements)</span> ：往集合中添加一些元素</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span> ：打乱集合顺序</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line">：将集合按照默认规则排序</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span>：将集合中元素按照指定规则排序</span><br></pre></td></tr></table></figure><h4 id="1-4-1-Iterator迭代器"><a href="#1-4-1-Iterator迭代器" class="headerlink" title="1.4.1 Iterator迭代器"></a>1.4.1 Iterator迭代器</h4><p>迭代：Collection集合元素的通用获取方式。</p><p>迭代器的使用案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       coll.add(<span class="string">&quot;姚明&quot;</span>);</span><br><span class="line">       coll.add(<span class="string">&quot;科比&quot;</span>);</span><br><span class="line">       coll.add(<span class="string">&quot;詹姆斯&quot;</span>);</span><br><span class="line">       coll.add(<span class="string">&quot;库里&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取一个迭代器对象</span></span><br><span class="line">       Iterator&lt;String&gt; iterator = coll.iterator();</span><br><span class="line">       <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-异常"><a href="#1-5-异常" class="headerlink" title="1.5 异常"></a>1.5 异常</h3><p><strong>异常</strong>：指的是程序在执行过程中，出现非正常的情况，最终导致JVM非正常停止。</p><p>Java处理异常的方式是中断处理。</p><p><strong>异常产生的过程解析</strong></p><h4 id="1-5-1-异常的处理"><a href="#1-5-1-异常的处理" class="headerlink" title="1.5.1 异常的处理"></a>1.5.1 异常的处理</h4><p>Java异常处理的五个关键字：try、catch、finally、throw、throws</p><ol><li>抛出异常throw</li></ol><p>throw作用：</p><p>可以使用throw关键字在指定的方法中抛出指定的异常</p><p>使用格式：</p><p>throw new xxxException（“异常产生的原因”）;</p><p>注意：</p><ol><li>throw关键字必须写在方法的内部</li><li>throw后面new的对象必须是Exception或者Exception的子类对象</li><li>throw抛出指定的异常对象，我们必须处理这个异常对象，要么用throws，要么try…..catch</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以后（工作中）我们首先必须对方法传递过来的参数进行合法性校验</span><br><span class="line"></span><br><span class="line">如果参数不合法，那么我们就必须使用抛出异常的方式，告知方法的调用者，传递的参数有问题。</span><br></pre></td></tr></table></figure><ol start="2"><li>声明异常throws（异常处理的第一种方式）</li></ol><p>作用：</p><p>当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象</p><p>可以使用throws处理异常对象，把异常声明抛出给方法的调用者处理（自己不处理，谁调用我让谁处理），最终交给jvm处理–&gt;中断异常</p><p>使用格式：在方法声明时使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数列表） <span class="keyword">throws</span> xxxException,.....&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">xxxException</span>(<span class="string">&quot;产生原因&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">注意</span><br><span class="line">    <span class="number">1.</span> <span class="keyword">throws</span> 必须写在方法声明处</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">throws</span> 后边声明的异常必须是Exception或者其子类</span><br><span class="line">    <span class="number">3.</span> 方法内部如果抛出多个异常，那么<span class="keyword">throws</span>后边也必须声明多个异常</span><br><span class="line">        如果多个异常之间有子父类关系，直接声明父类异常就行</span><br><span class="line">    <span class="number">4.</span> 调用了一个声明抛出异常的方法，我们就必须处理声明的异常</span><br><span class="line">        要么继续使用 <span class="keyword">throws</span> 声明抛出，交给方法的调用者处理，最终交给 JVM</span><br><span class="line">        要么 <span class="keyword">try</span>....<span class="keyword">catch</span> 自己处理。</span><br></pre></td></tr></table></figure><ol start="3"><li>捕获异常try…..catch（异常处理的第二种方式）</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>(xxxException e)&#123; <span class="comment">//try中抛出什么异常，catch就定义什么异常对象，用来接收这个异常。</span></span><br><span class="line">    一般在工作中，会把异常的信息记录在一个日志中。</span><br><span class="line">&#125;</span><br><span class="line">注意</span><br><span class="line">    <span class="number">1.</span> <span class="keyword">try</span> 可能会抛出多个异常，那么可以使用多个 <span class="keyword">catch</span> 来处理</span><br><span class="line">    <span class="number">2.</span> 如果 <span class="keyword">try</span> 中产生了异常，就会执行 <span class="keyword">catch</span> 中的异常处理逻辑，执行完后，继续执行 <span class="keyword">try</span>...<span class="keyword">catch</span> 后的代码。</span><br><span class="line">    <span class="number">3.</span> 如果 <span class="keyword">try</span> 中没有异常，就不执行 <span class="keyword">catch</span> ，执行完 <span class="keyword">try</span> 后，继续执行 <span class="keyword">try</span>...<span class="keyword">catch</span> 后的代码。</span><br></pre></td></tr></table></figure><h3 id="1-6-泛型"><a href="#1-6-泛型" class="headerlink" title="1.6 泛型"></a>1.6 泛型</h3><p>泛型是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型。</p><p><strong>泛型的数据类型在创建对象的时候确定</strong></p><p>创建集合对象，使用泛型</p><p>好处：</p><ol><li>避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型</li><li>把运行期异常（代码运行之后抛出的异常）提升到了编译期</li></ol><p>弊端：</p><ol><li>泛型是什么类型，只能存储什么类型的数据</li></ol><p><strong>含有泛型的方法</strong></p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表（使用泛型）)&#123;</span><br><span class="line">        方法体;</span><br><span class="line">    &#125;</span><br><span class="line">实例</span><br><span class="line"> <span class="keyword">public</span> &lt;H&gt; <span class="keyword">void</span> <span class="title function_">genericMethod</span><span class="params">(H h)</span>&#123;</span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>含有泛型的接口</strong></p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">第一种使用方式，定义接口的实现类，实现接口并指定接口的泛型</span><br><span class="line">实例</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Scanner</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">第二种使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt;&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;   </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>泛型通配符</p><p>​？：代表任意的数据类型</p><p>使用方式：</p><p>​不能创建对象使用</p><p>​  只能作为方法的参数使用</p><p><strong>高级使用-受限泛型（要求只要看源码能看懂就行）</strong></p><p>作用：限定数据的使用类型。</p><p>泛型的上限限定：？extends E 代表使用的泛型只能是E类型的子类&#x2F;本身</p><p>泛型的下限限定：？super E 代表使用的泛型只能是E类型的父类&#x2F;本身</p><ul><li><strong>数据结构</strong></li></ul><p><strong>红黑树</strong></p><p>特点：</p><ol><li>趋近于平衡树，查询的速度非常快，查询叶子节点最大次数和最小次数不能超过2倍</li></ol><p>约束：</p><ol><li>节点可以是红色或者黑色</li><li>根节点是黑色</li><li>叶子节点（空节点）是黑色</li><li>每个红色的节点的子节点都是黑色</li><li>任何一个节点到其每一个叶子节点所有路径上的黑色节点数相等</li></ol><h3 id="1-7-反射"><a href="#1-7-反射" class="headerlink" title="1.7 反射"></a>1.7 反射</h3><p><strong>作用</strong></p><ol><li>基本作用：可以得到一个类的全部成分然后操作</li><li>可以破坏封装性</li><li>最重要的用途是：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。</li></ol><h3 id="1-8-注解"><a href="#1-8-注解" class="headerlink" title="1.8 注解"></a>1.8 注解</h3><p>就是Java的特殊标记，作用是：让其他程序根据注解信息来决定怎么执行该程序</p><p><strong>特殊属性名：value</strong></p><p>如果注解只有一个value属性，使用注解时，value名称可以不写。</p><p><strong>元注解</strong></p><p>修饰注解的注解</p><p>常见的元注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="meta">@Target</span></span><br><span class="line">    作用：声明被修饰的注解只能在哪些位置使用</span><br><span class="line">    @<span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line">    <span class="number">1.</span> TYPE,类，接口</span><br><span class="line">    <span class="number">2.</span> FIELD， 成员变量</span><br><span class="line">    <span class="number">3.</span> METHOD，成员方法</span><br><span class="line">    .....</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> <span class="meta">@Retention</span></span><br><span class="line">    作用：声明注解的保留周期</span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="number">1.</span> SOURCE</span><br><span class="line">    只作用在源码阶段，字节码文件中不存在</span><br><span class="line">    <span class="number">3.</span>RUNTIME（开发常用）</span><br><span class="line">    一直保留到运行阶段</span><br></pre></td></tr></table></figure><p><strong>注解的解析</strong></p><p>要解析谁上面的注解，就先拿到谁</p><h3 id="1-9-I-O"><a href="#1-9-I-O" class="headerlink" title="1.9 I&#x2F;O"></a>1.9 I&#x2F;O</h3><p>重点：记住三个单词</p><p>​          file： 文件</p><p>​          directory：文件夹&#x2F;目录</p><p>​          path： 路径</p><p><strong>递归</strong>：指在当前方法内部调用自己的这种现象</p><p>递归的分类：</p><ol><li>直接递归</li></ol><p>​        方法自身调用自身</p><ol start="2"><li>间接递归</li></ol><p>​A方法调用B方法，B方法调用C方法，C方法调用A方法。</p><p><strong>Java中的I&#x2F;O操作主要是指使用Java.io包下的内容，进行输入、输出操作。</strong></p><ol><li>字节流（InputStream&#x2F;OutputStream）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream </span><br><span class="line">    文件字节输入流</span><br><span class="line">    作用：把硬盘文件中的数据，读取到内存中使用</span><br><span class="line">FileOutputStream</span><br><span class="line">    文件字节输出流</span><br><span class="line">    作用：把内存中的数据写入到硬盘的文件中</span><br></pre></td></tr></table></figure><p>使用字节流读取中文文件容易产生乱码</p><p>一个中文</p><p>​GBK： 占用两个字节</p><pre><code>     UTF-8：占用三个字节</code></pre><ol start="2"><li>字符流（reader&#x2F;writer）</li></ol><p>作用：读取字符信息，一次读取一个字符</p><p>jdk7的新特性</p><p>在try后边可以增加一个()，在括号中可以定义流对象</p><p>那么这个流对象的作用域就在try中有效</p><p>try中的代码执行完毕会自动把流对象释放，不用写finally</p><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(定义流对象；定义流对象...)&#123;</span><br><span class="line">    可能会产生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类变量 变量名)&#123;</span><br><span class="line">    异常的处理逻辑</span><br><span class="line">&#125;</span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoll</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(<span class="comment">//创建一个字符输出流对象，构造方法绑定需要写入的目的地</span></span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="literal">true</span>);) &#123;</span><br><span class="line"><span class="comment">//            //创建一个字符输入流对象，构造方法绑定需要读取的数据源</span></span><br><span class="line"><span class="comment">//            FileReader fr = new FileReader(&quot;test.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                fw.append(<span class="string">&quot;helloword&quot;</span>+i+<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>缓冲流</li></ol><p>作用：提高文件读写的效率</p><p>字节缓冲流（BufferedInputStream &amp; BufferedOutputStream）</p><p>字符缓冲流（BufferedReader &amp; BufferWriter）</p><ol start="4"><li>转换流(OutputStreamWriter &amp; InputStreamReader)</li></ol><p>作用：能够转换编码</p><ol start="5"><li>序列化流(ObjectOutputStream &amp; ObjectInputStream )</li></ol><p>作用：能够持久化存储对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Serializable 接口也叫标记型接口</span><br><span class="line">    要进行序列化和反序列化的类必须实现 Serializable 接口，就会给类添加一个标记</span><br><span class="line">    当我们进行序列化和反序列化的时候，就会检测是否有这个标记</span><br><span class="line">    有：就可以序列化和反系列化</span><br><span class="line">    没有：就会抛出 NotSerializableException 异常</span><br><span class="line"> <span class="keyword">transient</span>关键字：瞬态关键字</span><br><span class="line">    被 <span class="keyword">transient</span> 修饰的成员变量，不能被序列化</span><br><span class="line">问题：</span><br><span class="line">    每次修改类的定义，都会给class文件生成一个新的序列号，这样在进行序列化与反序列化时就会报invalidClassException异常</span><br><span class="line">解决方法：</span><br><span class="line">    无论是否对类的定义进行修改，都不重新生成新的序列号</span><br><span class="line">    可以手动给类添加一个序列号</span><br><span class="line">  格式：</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6161825669842708241L</span>;</span><br><span class="line">等号后面的常量可以为任意值，不可改变。</span><br></pre></td></tr></table></figure><p>序列化集合</p><p>当我们想在文件中保存多个对象的时候，可以把多个对象存储到一个集合中，然后对集合进行序列化和反序列化。</p><h2 id="2-JVM"><a href="#2-JVM" class="headerlink" title="2. JVM"></a>2. JVM</h2><h3 id="2-1-类加载机制"><a href="#2-1-类加载机制" class="headerlink" title="2.1 类加载机制"></a>2.1 类加载机制</h3><h3 id="2-2-字节码执行机制"><a href="#2-2-字节码执行机制" class="headerlink" title="2.2 字节码执行机制"></a>2.2 字节码执行机制</h3><h3 id="2-3-jvm内存模型"><a href="#2-3-jvm内存模型" class="headerlink" title="2.3 jvm内存模型"></a>2.3 jvm内存模型</h3><h3 id="2-4-gc垃圾回收机制"><a href="#2-4-gc垃圾回收机制" class="headerlink" title="2.4 gc垃圾回收机制"></a>2.4 gc垃圾回收机制</h3><h3 id="2-5-jvm性能监控和故障定位"><a href="#2-5-jvm性能监控和故障定位" class="headerlink" title="2.5 jvm性能监控和故障定位"></a>2.5 jvm性能监控和故障定位</h3><h3 id="2-6-jvm调优"><a href="#2-6-jvm调优" class="headerlink" title="2.6 jvm调优"></a>2.6 jvm调优</h3><h2 id="3-并发-多线程"><a href="#3-并发-多线程" class="headerlink" title="3. 并发&#x2F;多线程"></a>3. 并发&#x2F;多线程</h2><h3 id="3-1-并发编程"><a href="#3-1-并发编程" class="headerlink" title="3.1 并发编程"></a>3.1 并发编程</h3><h3 id="3-2-多线程"><a href="#3-2-多线程" class="headerlink" title="3.2 多线程"></a>3.2 多线程</h3><p>创建线程的步骤：</p><ol><li>声明Thread类的子类</li><li>重写Thread类的run方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置线程任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">创建线程的第二种方式</span><br><span class="line">    <span class="number">1.</span> 创建一个runnable接口的实现类</span><br><span class="line">    <span class="number">2.</span> 在实现类中重写runnable接口的run方法，设置线程任务 </span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableThreadImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置线程任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableThreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多态写法</span></span><br><span class="line">        <span class="comment">//Runnable runnable= new MyRunnableThreadImpl();</span></span><br><span class="line">        MyRunnableThreadImpl runnable= <span class="keyword">new</span> <span class="title class_">MyRunnableThreadImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">使用runnable接口创建多线程的好处：</span><br><span class="line">    <span class="number">1.</span> 避免了单继承的局限性</span><br><span class="line">    <span class="number">2.</span> 增强了程序的扩展性，降低了程序的耦合性（解耦）</span><br></pre></td></tr></table></figure><p><strong>Thread类中的常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span>：获取；当前线程名</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> ：此线程开始执行，Java虚拟机调用此线程的run方法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span>:使当前线程暂停指定多长时间</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>：线程要执行的任务都在此处编写</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>：返回当前正在执行的线程对象的引用</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p><strong>并发与并行</strong></p><p>并发：指两个或多个事件在同一时间段内发生</p><p>并行：指两个或多个事件在同一时刻发生（同时发生）</p><p><strong>线程与进程</strong></p><p>进程： 是指一个内存中运行的应用程序</p><p>线程： 是指进程中的一个执行单元，负责当前进程中程序的执行，一个进程至少有一个线程。一个进程中是可以有多个线程的，这个应用程序称为<strong>多线程程序</strong>。</p><p><strong>线程调度</strong></p><p>分时调度： 所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。</p><p>抢占式调度： 优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java使用的为抢占式调度。</p><h4 id="3-2-1-线程安全"><a href="#3-2-1-线程安全" class="headerlink" title="3.2.1 线程安全"></a>3.2.1 线程安全</h4><p> <strong>解决线程安全问题</strong></p><ol><li>同步代码块: synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</li></ol><p>使用synchronized关键字容易产生死锁（如何解决，在后续内容中写）</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>（同步锁（锁对象））&#123;</span><br><span class="line">    <span class="comment">//需要同步操作的代码即：可能出现线程安全问题的代码（访问了共享数据的代码）</span></span><br><span class="line">&#125;</span><br><span class="line">同步锁（锁对象）注意事项：</span><br><span class="line">    <span class="number">1.</span> 同步代码块中的锁对象，可以使用任意的对象</span><br><span class="line">    <span class="number">2.</span> 必须保证多个线程使用的锁对象是同一个</span><br><span class="line">    <span class="number">3.</span> 锁对象作用：</span><br><span class="line">             把同步代码块锁住，只让一个线程在同步代码块中执行</span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableThreadImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//同步锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>同步方法</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 参数名（参数列表）&#123;</span><br><span class="line">    <span class="comment">//需要同步操作的代码即：可能出现线程安全问题的代码（访问了共享数据的代码）</span></span><br><span class="line">&#125;</span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableThreadImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                payTicket();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//同步方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">payTicket</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">**静态同步方法**</span><br><span class="line"></span><br><span class="line">锁对象是谁？</span><br><span class="line"></span><br><span class="line">不能是<span class="built_in">this</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>是创建对象之后产生的，静态方法优先于对象</span><br><span class="line"></span><br><span class="line">静态方法的锁对象是本类的class属性--&gt;class文件对象(反射)</span><br></pre></td></tr></table></figure><ol start="3"><li>Lock锁</li></ol><p>Lock接口中的方法：</p><p>  void lock() 获取锁</p><p>   void unlock() 释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            l.lock();</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    l.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-线程池"><a href="#3-3-线程池" class="headerlink" title="3.3 线程池"></a>3.3 线程池</h3><p>  线程池： 其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作。</p><h3 id="3-4-锁"><a href="#3-4-锁" class="headerlink" title="3.4 锁"></a>3.4 锁</h3><h3 id="3-5-并发容器"><a href="#3-5-并发容器" class="headerlink" title="3.5 并发容器"></a>3.5 并发容器</h3><h3 id="3-6-原子类"><a href="#3-6-原子类" class="headerlink" title="3.6 原子类"></a>3.6 原子类</h3><h3 id="3-7-juc并发工具类"><a href="#3-7-juc并发工具类" class="headerlink" title="3.7 juc并发工具类"></a>3.7 juc并发工具类</h3><h2 id="4-网络编程"><a href="#4-网络编程" class="headerlink" title="4. 网络编程"></a>4. 网络编程</h2><p>软件结构：c&#x2F;s，b&#x2F;s</p><h3 id="4-1-网络通信"><a href="#4-1-网络通信" class="headerlink" title="4.1 网络通信"></a>4.1 网络通信</h3><p><strong>网络通信协议的分类</strong></p><ol><li>UDP：用户数据报协议</li></ol><p>特点：消耗资源小，通信效率高</p><p>通常用于音频、视频和普通数据的传输例如视频会议都使用udp协议，即使丢一两个数据包，也不会对接受结果产生太大影响。</p><ol start="2"><li>TCP：传输控制协议</li></ol><p>是面向连接的通信协议。在TCP连接中必须要明确客户端与服务器端，每次连接的创建都需要经过“三次握手”。</p><p>特点：传输安全</p><p>网络编程的三要素</p><ol><li>协议</li><li>IP地址</li></ol><ul><li>IPv4：32位的二进制数，通常被分为4个字节，表示a.b.c.d的形式，每个字节的范围都是0~255.</li><li>IPv6：</li></ul><ol start="3"><li>端口号</li></ol><h3 id="4-2-函数式接口"><a href="#4-2-函数式接口" class="headerlink" title="4.2 函数式接口"></a>4.2 函数式接口</h3><p>函数式接口：只有一个抽象方法的接口，称之为函数式接口</p><p>当然接口中可以包含其他的方法（默认，静态，私有）</p><p> <strong>Lambda表达式</strong></p><p>函数式编程思想：</p><p>​只要能获取到结果，谁去做，怎么做的都不重要，重视的是结果，不重视过程。</p><p>使用前提</p><ol><li>使用Lambda必须具有接口，且要求接口中有且只有一个抽象方法。</li><li>使用Lambda必须具有上下文推断</li></ol><p>有些场景的代码执行后结果不一定被使用，从而造成<strong>性能浪费</strong>。而Lambda表达式是延迟执行的，正好可以作为解决方案，提升性能。</p><p><strong>常用函数式接口</strong></p><ol><li>Supplier接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Supplier:被称为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个方法，用于获取int类型数组中元素的最大值，</span></span><br><span class="line"><span class="comment">     * 方法的参数传递Supplier接口，泛型使用Integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sup</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">100</span>,<span class="number">0</span>,-<span class="number">50</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> max= getMax(()-&gt;&#123;</span><br><span class="line">           <span class="type">int</span> temp= arr[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (temp&lt;arr[i])&#123;</span><br><span class="line">                   temp=arr[i];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Consumer接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Consumer:消费型接口，泛型执行什么类型，就可以使用accept方法使用什么类型的数据</span><br><span class="line">至于怎么消费（使用），需要自定义（输出，计算）</span><br><span class="line">默认方法：andThen</span><br><span class="line">作用：将两个Consumer接口连接到一起，然后再对数据进行消费（使用）</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String[] arr, Consumer&lt;String&gt; con1,Consumer&lt;String&gt; con2)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            con1.andThen(con2).accept(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr =  &#123;<span class="string">&quot;迪丽热巴，女&quot;</span>,<span class="string">&quot;古力娜扎，女&quot;</span>,<span class="string">&quot;沈腾，男&quot;</span>&#125;;</span><br><span class="line">        printMessage(arr,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;姓名：&quot;</span>+s.split(<span class="string">&quot;，&quot;</span>)[<span class="number">0</span>]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;性别：&quot;</span>+s.split(<span class="string">&quot;，&quot;</span>)[<span class="number">1</span>]+<span class="string">&quot;。&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ol start="3"><li>Predicate接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">对某种类型的数据进行判断，从而得到一个Boolean值结果。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoPredicate</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个方法，方法的参数传递一个字符串</span></span><br><span class="line"><span class="comment">     * 传递两个Predicate接口</span></span><br><span class="line"><span class="comment">     * 一个用于判断字符串的长度大于5</span></span><br><span class="line"><span class="comment">     * 一个用于判断字符串中是否包含a</span></span><br><span class="line"><span class="comment">     * 两个条件必须同时满足</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span>&#123;</span><br><span class="line">          <span class="comment">// return pre1.test(s) &amp;&amp; pre2.test(s);</span></span><br><span class="line">        <span class="comment">//return pre1.test(s) || pre2.test(s);</span></span><br><span class="line"><span class="comment">//        return pre1.or(pre2).test(s);</span></span><br><span class="line">          <span class="keyword">return</span> pre1.and(pre2).test(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;Hello world!!&quot;</span>;</span><br><span class="line">       <span class="type">boolean</span> b= checkString(test,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> s.length()&gt;<span class="number">5</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> s.contains(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-Stream流"><a href="#4-3-Stream流" class="headerlink" title="4.3 Stream流"></a>4.3 Stream流</h3><p>IO流和Stream流是两个概念，IO流是用于数据的读写，而Stream流可以用来对集合和数组进行简化操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java语言&quot;&gt;&lt;a href=&quot;#Java语言&quot; class=&quot;headerlink&quot; title=&quot;Java语言&quot;&gt;&lt;/a&gt;Java语言&lt;/h1&gt;&lt;h2 id=&quot;1-语言基础&quot;&gt;&lt;a href=&quot;#1-语言基础&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>个人博客搭建笔记</title>
    <link href="http://example.com/2023/12/24/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/12/24/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</id>
    <published>2023-12-24T11:50:36.000Z</published>
    <updated>2023-12-27T10:22:52.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人博客搭建笔记"><a href="#个人博客搭建笔记" class="headerlink" title="个人博客搭建笔记"></a>个人博客搭建笔记</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</span><br></pre></td></tr></table></figure><h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><h3 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1. 安装node.js"></a>1. 安装node.js</h3><p><a class="link"   href="https://blog.csdn.net/fenijd/article/details/135206205" >node.js的安装与配置教程-CSDN博客<i class="fas fa-external-link-alt"></i></a></p><h3 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2. 安装git"></a>2. 安装git</h3><p><a class="link"   href="https://blog.csdn.net/fenijd/article/details/135226795" >Git 2.43.0的安装教程-CSDN博客<i class="fas fa-external-link-alt"></i></a></p><h2 id="二、搭建博客"><a href="#二、搭建博客" class="headerlink" title="二、搭建博客"></a>二、搭建博客</h2><ol><li>以管理员的身份运行cmd输入命令下载hexo框架</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>出现下图所示样式表示下载成功，因为我已经下载过了，所以没有什么变化。图中的警告先不用管，不影响使用。警告的大致意思是fsevents不支持windows平台。因为它是适用于苹果系统的，但是我们下载框架的时候是全都下载的，所以会出现这个警告。</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20231227150126542.png"                        alt="image-20231227150126542"                 ></p><p>在自己想要存放博客的文件夹下新建一个文件，名字自拟。从本文件夹直接进入cmd，或者先进入cmd，cd该文件夹下。输入命令初始化一个博客。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>初始化中断，根据提示可以看到是在安装依赖时出了问题。</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20231227151412779.png"                        alt="image-20231227151412779"                 ></p><p>原因是因为国内现在无法百分百概率访问Github，因此npm可能会下载失败；也有可能是因为文件权限的问题。总之按照提示再重新操作一遍以管理员的身份运行cmd并进入新建的博客文件夹下，使用hexo init命令后居然成功了。如下图所示，出现 Start blogging with Hexo 字样代表成功。</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20231227155115602.png"                        alt="image-20231227155115602"                 ></p><p>初始化完成后使用命令就可以访问自己的博客了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>按住ctrl键鼠标左键点击即可跳转到博客网页。</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20231227162536967.png"                        alt="image-20231227162536967"                 ></p><p>博客网站如下图所示，默认会新建一篇文章。至此，博客的搭建工作告一段落。</p><img                           lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20231227162048417.png"                         alt="image-20231227162048417"                   ><h2 id="三、将博客部署到Github上"><a href="#三、将博客部署到Github上" class="headerlink" title="三、将博客部署到Github上"></a>三、将博客部署到Github上</h2><p>使用命令安装一键将博客推送至GitHub上的插件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>使用管理员的身份运行cmd输入命令后安装成功。</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20231227163832468.png"                        alt="image-20231227163832468"                 ></p><p>在Github上创建一个个人仓库用于存放博客，首先登录GitHub，在个人仓库中找到新建仓库点击进入。</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20231227164915105.png"                        alt="image-20231227164915105"                 ></p><p>仓库名为自己的GitHub用户名.github.io，如图所示，一定要这样设置，不然会不起作用。</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20231227165146140.png"                        alt="image-20231227165146140"                 ></p><p>描述根据自己需要填写，然后点击创建仓库。</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20231227165414068.png"                        alt="image-20231227165414068"                 ></p><p>创建完成后会自动跳转到你刚才创建的仓库内，在仓库中找到如下图所示位置，点击复制，后面修改博客的配置文件时会用到。</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20231227165755277.png"                        alt="image-20231227165755277"                 ></p><p>使用vscode或者记事本打开_config.yml找到deploy修改其中的内容为，保存并退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  repo: <span class="string">&#x27;https://github.com/dettry/dettry.github.io.git&#x27;</span> #为你创建的GitHub个人仓库地址</span><br><span class="line">  branch: <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure><p>进入cmd中cd到博客存放的路径下执行如下命令就可以将博客部署到GitHub上了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>记得在推送之前先开启梯子，然后将代理服务器打开。</p><p>首先右键网络选择网络和Internet设置。</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20231227175624944.png"                        alt="image-20231227175624944"                 ></p><p>找到使用代理服务器，点击编辑将代理服务器打开然后保存。</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20231227175530411.png"                        alt="image-20231227175530411"                 ></p><p>最后推送成功后在地址栏输入dettry.github.io即可访问自己的博客。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;个人博客搭建笔记&quot;&gt;&lt;a href=&quot;#个人博客搭建笔记&quot; class=&quot;headerlink&quot; title=&quot;个人博客搭建笔记&quot;&gt;&lt;/a&gt;个人博客搭建笔记&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Linux笔记</title>
    <link href="http://example.com/2023/05/05/Linux%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/05/05/Linux%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-05T06:12:45.000Z</published>
    <updated>2023-12-23T09:05:10.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux笔记"><a href="#Linux笔记" class="headerlink" title="Linux笔记"></a>Linux笔记</h1><h2 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1. 目录结构"></a>1. 目录结构</h2><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20230401113335627.png"                        alt="image-20230401113335627"                 ></p><h2 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h2><h3 id="2-1-ls"><a href="#2-1-ls" class="headerlink" title="2.1 ls"></a>2.1 ls</h3><p>对应英文：list  </p><p>作用： 查看当前目录下的内容</p><p>ll 对应 ls -l </p><p>作用： 查看当前目录下的所有内容和每个文件的详细信息。</p><h3 id="2-2-pwd"><a href="#2-2-pwd" class="headerlink" title="2.2 pwd"></a>2.2 pwd</h3><p>对应英文：print work directory </p><p>作用： 查看当前所在目录</p><h3 id="2-3-touch"><a href="#2-3-touch" class="headerlink" title="2.3 touch"></a>2.3 touch</h3><p>touch [文件名] </p><p>作用：如果文件不存在，新建文件</p><h3 id="2-4-cd"><a href="#2-4-cd" class="headerlink" title="2.4 cd"></a>2.4 cd</h3><p>~表示当前用户的home目录</p><p>.表示当前所在目录</p><p>..表示当前目录位置的上级目录</p><h3 id="2-5-cat"><a href="#2-5-cat" class="headerlink" title="2.5 cat"></a>2.5 cat</h3><p>cat [-n] fileName</p><p>-n: 由1开始对所有输出的行数编号</p><p>cat &#x2F;etc&#x2F;profile   查看&#x2F;etc目录下的profile文件内容</p><h3 id="2-6-rmdir"><a href="#2-6-rmdir" class="headerlink" title="2.6 rmdir"></a>2.6 rmdir</h3><p>作用：删除空目录</p><p>语法：rmdir [-p] dirName</p><p>-p: 当子目录被删除后使父目录为空目录的话，则一并删除</p><p>rm</p><p>作用：删除文件或者目录</p><p>语法：rm [-rf] name</p><p>-r:将目录及目录中的所有文件（目录）逐一删除，即递归删除</p><p>-f: 无需确认直接删除</p><h3 id="2-7-tar"><a href="#2-7-tar" class="headerlink" title="2.7 tar"></a>2.7 tar</h3><p>作用：对文件进行打包、解包、压缩、解压</p><p>语法：tar [-zcxvf] fileName [files]</p><p>包文件后缀为.tar表示只是完成了打包，并没有压缩</p><p>包文件后缀为.tar.gz表示打包的同时还进行了压缩</p><p>说明：</p><p>-z: z代表gzip，通过gzip命令处理文件，gzip可以对文件压缩或者解压</p><p>-c: c代表的是create，即创建新的包文件</p><p>-x: x代表的是extract，实现从包文件中还原文件</p><p>-v: v代表的是verbose,显示命令的执行过程</p><p>-f: f代表的是file ,用于指定包文件的名称</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux笔记&quot;&gt;&lt;a href=&quot;#Linux笔记&quot; class=&quot;headerlink&quot; title=&quot;Linux笔记&quot;&gt;&lt;/a&gt;Linux笔记&lt;/h1&gt;&lt;h2 id=&quot;1-目录结构&quot;&gt;&lt;a href=&quot;#1-目录结构&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记</title>
    <link href="http://example.com/2023/05/05/Java%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/05/05/Java%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-05T06:11:45.000Z</published>
    <updated>2023-12-23T08:43:30.855Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java笔记"><a href="#Java笔记" class="headerlink" title="Java笔记"></a>Java笔记</h1><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221112111329540.png"                        alt="image-20221112111329540"                 ></p><h3 id="java语言概述"><a href="#java语言概述" class="headerlink" title="java语言概述"></a>java语言概述</h3><h4 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h4><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221115162358155.png"                        alt="image-20221115162358155"                 ></p><h4 id="java语言的特点"><a href="#java语言的特点" class="headerlink" title="java语言的特点"></a>java语言的特点</h4><p>特点一：面向对象</p><p>两概三特：类、对象；封装、继承、多态；</p><p>特点二：健壮性</p><p>去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等）</p><p>特点三：跨平台性</p><p>原理：先安装一个JVM虚拟机，然后由JVM负责JAVA程序在该系统上运行。</p><p>Java核心机制</p><p>   Java虚拟机：对于不同的平台有不同的虚拟机；</p><p>   垃圾回收机制：</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>单行和多行注释与c语言注释相同</p><p>文档注释：JAVA所特有</p><p>格式：&#x2F;**  *&#x2F;</p><p>作用：注释的内容可以被jdk提供的工具javadoc所解析，生成网页形式的程序说明文档。</p><h4 id="java-API文档"><a href="#java-API文档" class="headerlink" title="java API文档"></a>java API文档</h4><p>英文版：版本8</p><p>中文版：版本6</p><h3 id="Java基本语法"><a href="#Java基本语法" class="headerlink" title="Java基本语法"></a>Java基本语法</h3><h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><p>goto、const，java没有赋予其特殊含义，但在命名时尽量避开。</p><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>凡是可以自己起的名字都叫标识符。e.g：变量名、类名等等</p><p>命名规范</p><p>包名：多个单词组成时所有字母都小写</p><p>类名、接口名：多单词组成时，所有单词首字母大写</p><p>变量名、方法名：多单词组成时，第一个单词首字母小写，从第二个单词开始首字母大写。</p><p>常量名：所有字母都大写，多单词时，每个单词用下划线连接。</p><h4 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h4><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221116165948252.png"                        alt="image-20221116165948252"                 ></p><h4 id="变量运算规则的两种特殊情况"><a href="#变量运算规则的两种特殊情况" class="headerlink" title="变量运算规则的两种特殊情况"></a>变量运算规则的两种特殊情况</h4><p>定义long型变量：long len&#x3D;78899786676l&#x2F;L;</p><p>定义float型变量：float len&#x3D;12.3f&#x2F;F;</p><p>但现实经常使用double型变量，精度更高。</p><p>整型常量默认类型：int</p><p>浮点型常量默认类型：double</p><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>+、-、*、&#x2F;、++、–、%</p><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>&#x3D;</p><p>扩展运算符:+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;+、%&#x3D;</p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>基本与c语言一样。</p><p>instanceof:检查是否是类的对象。</p><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p><strong>开发以后所用技术：mybatis+druid+远程服务器，别使用lombok进行开发</strong>。</p><h4 id="基础篇-1"><a href="#基础篇-1" class="headerlink" title="基础篇"></a>基础篇</h4><h5 id="1-parent"><a href="#1-parent" class="headerlink" title="1. parent"></a>1. parent</h5><p>将以前spring开发时所需要配置的pom 文件进行整合，方便管理。</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221125191759218.png"                        alt="image-20221125191759218"                 ></p><p>  <strong>小结</strong></p><ol><li><p>开发springBoot程序要继承spring-boot-starter-parent</p></li><li><p>spring-boot-starter-parent中定义了若干个依赖管理（不是具体的坐标，只是把你要用的版本管理好，而没提供具体的坐标）</p></li><li><p>继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突（做版本的统一化管理)</p></li><li><p>继承parent的形式也可以采用引入依赖的形式实现效果</p></li></ol><h5 id="2-starter"><a href="#2-starter" class="headerlink" title="2. starter"></a>2. starter</h5><p><strong>starter</strong></p><p>​1. SpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标 ，以达到<strong>减少依赖配置</strong>的目的</p><p><strong>parent</strong></p><pre><code>    1. 所有SpringBoot项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的    1. spring-boot-starter-parent各版本间存在着诸多坐标版本不同</code></pre><p><strong>实际开发</strong></p><ol><li><p>使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供，除非SpringBoot未提供对应版本V</p></li><li><p>如发生坐标错误，再指定Version（要小心版本冲突)</p></li></ol><p><strong>小结</strong></p><ol><li>开发springBoot程序需要导入坐标时通常导入对应的starter</li><li>每个不同的starter根据功能不同，通常包含多个依赖坐标</li><li>使用starter可以实现快速配置的效果，达到简化配置的目的</li></ol><h5 id="3-引导类"><a href="#3-引导类" class="headerlink" title="3. 引导类"></a>3. 引导类</h5><p>下图即为引导类</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221126100829179.png"                        alt="image-20221126100829179"                 ></p><p>无论是做spring程序还是做springmvc的程序，最后都会运行出来一个spring容器的对象。所有对象都以bean的形式交给spring容器管理。</p><p>SpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目</p><p>SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean</p><p><strong>得到bean的方式有四种：</strong></p><ol><li>以类型的形式（即class）</li><li></li></ol><h5 id="4-辅助功能"><a href="#4-辅助功能" class="headerlink" title="4. 辅助功能"></a>4. 辅助功能</h5><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221126135325136.png"                        alt="image-20221126135325136"                 ></p><blockquote><p>内置服务器：</p><p>tomcat(默认)</p><p>jetty</p><p>undertow</p></blockquote><p><strong>小结</strong></p><ol><li>内嵌Tomcat服务器是SpringBoot辅助功能之一</li><li>内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理</li><li>变更内嵌服务器思想是去除现有服务器，添加全新的服务器</li></ol><h5 id="5-Rest风格开发入门案例"><a href="#5-Rest风格开发入门案例" class="headerlink" title="5. Rest风格开发入门案例"></a>5. Rest风格开发入门案例</h5><h6 id="1-以前的开发"><a href="#1-以前的开发" class="headerlink" title="1.以前的开发"></a>1.以前的开发</h6><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221127170845847.png"                        alt="image-20221127170845847"                 ></p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221127171423014.png"                        alt="image-20221127171423014"                 ></p><h6 id="2-接受参数的三种方式"><a href="#2-接受参数的三种方式" class="headerlink" title="2. 接受参数的三种方式"></a>2. 接受参数的三种方式</h6><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221127171256707.png"                        alt="image-20221127171256707"                 ></p><h6 id="3-现在的开发"><a href="#3-现在的开发" class="headerlink" title="3.现在的开发"></a>3.现在的开发</h6><h5 id=""><a href="#" class="headerlink" title=""></a><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221127203229053.png"                        alt="image-20221127203229053"                 ></h5><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221127203519136.png"                        alt="image-20221127203519136"                 ></p><h5 id="6-boot配置"><a href="#6-boot配置" class="headerlink" title="6. boot配置"></a>6. boot配置</h5><h6 id="6-1-准备工作"><a href="#6-1-准备工作" class="headerlink" title="6.1 准备工作"></a>6.1 准备工作</h6><p>模板的制作</p><ol><li>在工作空间中复制对应工程，并修改工程名称</li><li>删除与Idea相关配置文件，仅保留src目录与pom. xml文件</li><li>修改pom.xml文件中的artifactId与新工程&#x2F;模块名相同</li><li>删除name标签（可选)</li><li>保留备份工程供后期使用</li></ol><h6 id="6-2-属性配置"><a href="#6-2-属性配置" class="headerlink" title="6.2 属性配置"></a>6.2 属性配置</h6><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221128170828876.png"                        alt="image-20221128170828876"                 ></p><ol><li><p>SpringBoot提供了3种配置文件的格式<br>properties (传统格式&#x2F;默认格式)<br>yml（主流格式)<br>yaml</p></li><li><p>配置文件间的加载优先级<br>properties (最高)</p><p>yml（常用）</p><p>yaml(最低)</p></li><li><p>不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留</p></li></ol><p>yaml或者yml自动提示功能消失解决方案</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221128172557083.png"                        alt="image-20221128172557083"                 ></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yaml书写格式：</span><br><span class="line"></span><br><span class="line">注意属性名冒号后面与数据之间有一个空格</span><br></pre></td></tr></table></figure><p>读取数据</p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221128203619298.png"                        alt="image-20221128203619298"                 ></p><h5 id="7-整合第三方技术"><a href="#7-整合第三方技术" class="headerlink" title="7. 整合第三方技术"></a>7. 整合第三方技术</h5><ol><li><p><strong>整合junit小结</strong></p><ul><li><p>导入测试对应的starter(如果是自己手工创建的话)</p></li><li><p>测试类使用@SpringBootTest修饰</p></li><li><p>使用自动装配的形式添加要测试的对象</p></li><li><p>测试类如果存在于引导类所在包或子包中无需指定引导类</p></li><li><p>测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类</p></li></ul></li><li><p><strong>整合mybatis小结</strong></p><ul><li><p>勾选MyBatis技术，也就是导入MyBatis对应的starter</p></li><li><p>数据库连接相关信息转换成配置</p></li><li><p>数据库sQL映射需要添加@Mapper被容器识别到</p><pre><code>  springboot的版本过低导致的问题处理</code></pre></li></ul></li></ol><p>​2.1 MySQL 8.X驱动强制要求设置时区</p><p>​修改url，添加serverTimezone设定</p><p>​修改MySQL数据库配置（略)</p><p>​2.2 驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver</p><blockquote><p>boot整合东西分为三个部分:</p><ol><li>导入对应的start</li><li>做相应的配置</li><li>直接使用对应的技术进行开发</li></ol></blockquote><ol start="3"><li><strong>整合mybatis-plus小结</strong> <img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221130093255881.png"                        alt="image-20221130093255881"                 ></li></ol><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221130093312809.png"                        alt="image-20221130093312809"                 ></p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20221130093423735.png"                        alt="image-20221130093423735"                 ></p><ol start="4"><li><strong>整合Druid(即数据源)</strong></li></ol><p>​      <img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20230222161204003.png"                        alt="image-20230222161204003"                 ></p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20230228145538979.png"                        alt="image-20230228145538979"                 ></p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20230228145621901.png"                        alt="image-20230228145621901"                 ></p><p><img                         lazyload                       alt="image"                       data-src="C:\Users\85793\AppData\Roaming\Typora\typora-user-images\image-20230228150602825.png"                        alt="image-20230228150602825"                 ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java笔记&quot;&gt;&lt;a href=&quot;#Java笔记&quot; class=&quot;headerlink&quot; title=&quot;Java笔记&quot;&gt;&lt;/a&gt;Java笔记&lt;/h1&gt;&lt;h2 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; class=&quot;headerlink&quot; title=&quot;基础篇</summary>
      
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
</feed>

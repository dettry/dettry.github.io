<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-13T02:21:26.466Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://example.com/2024/05/13/regular_expression_note/"/>
    <id>http://example.com/2024/05/13/regular_expression_note/</id>
    <published>2024-05-13T02:19:07.000Z</published>
    <updated>2024-05-13T02:21:26.466Z</updated>
    
    <content type="html"><![CDATA[<h1>正则表达式</h1><h2 id="1-基础正则表达式速查表">1. 基础正则表达式速查表</h2><h3 id="1-1-字符">1.1 字符</h3><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">[abc]</td><td style="text-align:left">字符集。匹配集合中所含的任一字符。</td></tr><tr><td style="text-align:center">[^abc]</td><td style="text-align:left">否定字符集。匹配任何不在集合中的字符。</td></tr><tr><td style="text-align:center">[a-z]</td><td style="text-align:left">字符范围。匹配指定范围内的任意字符。</td></tr><tr><td style="text-align:center">.</td><td style="text-align:left">匹配除换行符以外的任何单个字符。</td></tr><tr><td style="text-align:center">\</td><td style="text-align:left">转义字符。</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:left">匹配任何字母数字，包括下划线（等价于[A-Za-z0-9_]）。</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:left">匹配任何非字母数字（等价于[^A-Za-z0-9_]）。</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:left">数字。匹配任何数字。</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:left">非数字。匹配任何非数字字符。</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:left">空白。匹配任何空白字符，包括空格、制表符等。</td></tr></tbody></table><h3 id="1-2-分组和引用">1.2 分组和引用</h3><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>(expression)</td><td>分组。匹配括号里的整个表达式。</td></tr><tr><td>(?:expression)</td><td>非捕获分组。匹配括号里的整个字符串但不获取匹配结果，拿不到分组引用。</td></tr><tr><td>\num</td><td>对前面所匹配分组的引用。比如(\d)\1可以匹配两个相同的数字，(Code)(Sheep)\1\2则可以匹配CodeSheepCodeSheep。</td></tr></tbody></table><h3 id="1-3-锚点-边界">1.3 锚点/边界</h3><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串或行开头。</td></tr><tr><td>$</td><td>匹配字符串或行结尾。</td></tr><tr><td>\b</td><td>匹配单词边界。比如Sheep\b可以匹配CodeSheep末尾的Sheep，不能匹配CodeSheepCode中的Sheep</td></tr><tr><td>\B</td><td>匹配非单词边界。比如Code\B可以匹配HelloCodeSheep中的Code，不能匹配HelloCode中的Code。</td></tr></tbody></table><h3 id="1-4-数量表示">1.4 数量表示</h3><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>?</td><td>匹配前面的表达式0个或1个。即表示可选项。</td></tr><tr><td>+</td><td>匹配前面的表达式至少1个。</td></tr><tr><td>*</td><td>匹配前面的表达式0个或多个。</td></tr><tr><td>|</td><td>或运算符。并集，可以匹配符号前后的表达式。</td></tr><tr><td>{m}</td><td>匹配前面的表达式m个。</td></tr><tr><td>{m,}</td><td>匹配前面的表达式最少m个。</td></tr><tr><td>{m,n}</td><td>匹配前面的表达式最少m个，最多n个。</td></tr></tbody></table><h3 id="1-5-预查断言">1.5 预查断言</h3><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>(?=)</td><td>正向预查。比如Code(?=Sheep)能匹配CodeSheep中的Code，但不能匹配CodePig中的Code。</td></tr><tr><td>(?!)</td><td>正向否定预查。比如Code(?!Sheep)不能匹配CodeSheep中的Code，但能匹配CodePig中的Code。</td></tr><tr><td>(?&lt;=)</td><td>反向预查。比如(?&lt;=Code)Sheep能匹配CodeSheep中的Sheep，但不能匹配ReadSheep中的Sheep。</td></tr><tr><td>(?&lt;!)</td><td>反向否定预查。比如(?&lt;!Code)Sheep不能匹配CodeSheep中的Sheep，但能匹配ReadSheep中的Sheep。</td></tr></tbody></table><h3 id="1-6-特殊标志">1.6 特殊标志</h3><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>/…/i</td><td>忽略大小写。</td></tr><tr><td>/…/g</td><td>全局匹配。</td></tr><tr><td>/…/m</td><td>多行修饰符。用于多行匹配。</td></tr></tbody></table><h2 id="2-常用正则表达式示例">2. 常用正则表达式示例</h2><h3 id="2-1-数字校验">2.1 数字校验</h3><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>数字</td><td>^[0-9]*$</td><td></td></tr><tr><td>n位数字</td><td>^\d{n}$</td><td></td></tr><tr><td>至少n位数字</td><td>^\d{n,}$</td><td></td></tr><tr><td>m~n位数字</td><td>^\d{m,n}$</td><td></td></tr><tr><td>整数</td><td>^(-?[1-9]\d*)$</td><td>非0开头，包括正整数和负整数</td></tr><tr><td>正整数</td><td>^[1-9]\d*$</td><td></td></tr><tr><td>负整数</td><td>^-[1-9]\d*$</td><td></td></tr><tr><td>非负整数</td><td>^(([1-9]\d*)|0)$</td><td></td></tr><tr><td>非正整数</td><td>^((-[1-9]\d*)|0)$</td><td></td></tr><tr><td>浮点数</td><td>^-?(?:[1-9]\d*.\d*|0.\d*[1-9]\d*|0.0+|0)$</td><td>包括正浮点数和负浮点数</td></tr><tr><td>正浮点数</td><td>^(?:[1-9]\d*.\d*|0.\d*[1-9]\d*)$</td><td></td></tr><tr><td>负浮点数</td><td>^-(?:[1-9]\d*.\d*|0.\d*[1-9]\d*)$</td><td></td></tr><tr><td>非正浮点数</td><td>^(?:-(?:[1-9]\d*.\d+|0.\d*[1-9]\d*)|0.0+|0)$</td><td>包含0</td></tr><tr><td>非负浮点数</td><td>^(?:[1-9]\d*.\d+|0.\d+|0.0+|0)$</td><td>包含0</td></tr><tr><td>仅一位小数</td><td>^-?(?:0|[1-9][0-9]*).[0-9]{1}$</td><td></td></tr><tr><td>最少一位小数</td><td>^-?(?:0|[1-9][0-9]*).[0-9]{1,}$</td><td></td></tr><tr><td>最多两位小数</td><td>^-?(?:0|[1-9][0-9]*).[0-9]{1,2}$</td><td></td></tr><tr><td>连续重复的数字</td><td>^(\d)\1+$</td><td>例如：111，222</td></tr></tbody></table><h3 id="2-2-字符校验">2.2 字符校验</h3><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>中文</td><td>^[\u4E00-\u9FA5]+$</td><td></td></tr><tr><td>全角字符</td><td>^[\uFF00-\uFFFF]+$</td><td></td></tr><tr><td>半角字符</td><td>^[\u0000-\u00FF]+$</td><td></td></tr><tr><td>英文字符串（大写）</td><td>^[A-Z]+$</td><td></td></tr><tr><td>英文字符串（小写）</td><td>^[a-z]+$</td><td></td></tr><tr><td>英文字符串（不区分大小写）</td><td>^[A-Za-z]+$</td><td></td></tr><tr><td>中文和数字</td><td>^(?:[\u4E00-\u9FA5]{0,}|\d)+$</td><td></td></tr><tr><td>英文和数字</td><td>^[A-Za-z0-9]+$</td><td></td></tr><tr><td>数字、英文字母或者下划线组成的字符串</td><td>^\w+$</td><td></td></tr><tr><td>中文、英文、数字包括下划线</td><td>^[\u4E00-\u9FA5\w]+$</td><td></td></tr><tr><td>不含字母的字符串</td><td>^[^A-Za-z]*$</td><td></td></tr><tr><td>连续重复的字符串</td><td>^(.)\1+$</td><td>例如：aa，bb</td></tr><tr><td>长度为n的字符串</td><td>^.{n}$</td><td></td></tr><tr><td>ASCII</td><td>^[ -~]$</td><td></td></tr></tbody></table><h3 id="2-3-日期和时间校验">2.3 日期和时间校验</h3><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>日期</td><td>^\d{1,4}-(?:1[0-2]|0?[1-9])-(?:0?[1-9]|[1-2]\d|30|31)$</td><td>弱校验，例如：2022-06-12</td></tr><tr><td>日期</td><td>^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</td><td>严格校验，考虑平闰年</td></tr><tr><td>时间</td><td>^(?:1[0-2]|0?[1-9]):[0-5]\d:[0-5]\d$</td><td>12小时制，例如：11:21:31</td></tr><tr><td>时间</td><td>^(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d$</td><td>24小时制，例如：23:21:31</td></tr><tr><td>日期+时间</td><td>^(\d{1,4}-(?:1[0-2]|0?[1-9])-(?:0?[1-9]|[1-2]\d|30|31))  ((?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d)$</td><td>例如：2000-11-11  23:20:21</td></tr></tbody></table><h3 id="2-4-日常生活相关">2.4 日常生活相关</h3><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>中文名</td><td>^[\u4E00-\u9FA5·]{2,16}$</td><td></td></tr><tr><td>英文名</td><td>^[a-zA-Z][a-zA-Z\s]{0,20}[a-zA-Z]$</td><td></td></tr><tr><td>车牌号</td><td>^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z][A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳]$</td><td>不含新能源</td></tr><tr><td>车牌号</td><td>^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领]<a href="?:(?:%5BA-HJ-NP-Z0-9%5D%7B4%7D%5BA-HJ-NP-Z0-9%E6%8C%82%E5%AD%A6%E8%AD%A6%E6%B8%AF%E6%BE%B3%5D)%7C(?:(?:%5Cd%7B5%7D%5BA-HJK%5D)%7C(?:%5BA-HJK%5D%5BA-HJ-NP-Z0-9%5D%5B0-9%5D%7B4%7D))">A-HJ-NP-Z</a>$</td><td>包含新能源</td></tr><tr><td>火车车次</td><td>^[GCDZTSPKXLY1-9]\d{1,4}$</td><td>例如：G1234</td></tr><tr><td>手机号</td><td>^(?:(?:+|00)86)?1[3-9]\d{9}$</td><td>弱匹配</td></tr><tr><td>手机号</td><td>^(?:(?:+|00)86)?1(?:(?:3[\d])|(?:4[5-79])|(?:5[0-35-9])|(?:6[5-7])|(?:7[0-8])|(?:8[\d])|(?:9[189]))\d{8}$</td><td>严格匹配</td></tr><tr><td>固话号码</td><td>^(?:(?:\d{3}-)?\d{8}|^(?:\d{4}-)?\d{7,8})(?:-\d+)?$</td><td></td></tr><tr><td>手机IMEI码</td><td>^\d{15,17}$</td><td>一般是15位</td></tr><tr><td>邮编</td><td>^(?:0[1-7]|1[0-356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[0-5]|8[013-6])\d{4}$</td><td>例如：211100</td></tr><tr><td>统一社会信用代码</td><td>^[0-9A-HJ-NPQRTUWXY]{2}\d{6}[0-9A-HJ-NPQRTUWXY]{10}$</td><td></td></tr><tr><td>身份证号码(1代)</td><td>^[1-9]\d{7}(?:0\d|10|11|12)(?:0[1-9]|[1-2][\d]|30|31)\d{3}$</td><td>15位数字</td></tr><tr><td>身份证号码(2代)</td><td>^[1-9]\d{5}(?:18|19|20)\d{2}(?:0[1-9]|10|11|12)(?:0[1-9]|[1-2]\d|30|31)\d{3}[0-9Xx]$</td><td>18位数字</td></tr><tr><td>QQ号</td><td>^[1-9][0-9]{4,}$</td><td>一般是5到10位</td></tr><tr><td>微信号</td><td>^[a-zA-Z][-_a-zA-Z0-9]{5,19}$</td><td>一般6~20位，字母开头，可包含字母、数字、-、_，不含特殊字符</td></tr><tr><td>股票代码</td><td>^(s[hz]|S[HZ])(000[\d]{3}|002[\d]{3}|300[\d]{3}|600[\d]{3}|60[\d]{4})$</td><td>A股，例如：600519</td></tr><tr><td>银行卡卡号</td><td>^[1-9]{1}(?:\d{15}|\d{18})$</td><td>一般为19位</td></tr></tbody></table><h3 id="2-5-互联网相关">2.5 互联网相关</h3><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>域名</td><td>^[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$</td><td>例如：<a class="link"   href="http://r2coding.com" >r2coding.com<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>网址</td><td>^(?:https?://)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$</td><td>例如：<a class="link"   href="https://www.r2coding.com/" >https://www.r2coding.com/<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>带端口号的网址(或IP)</td><td>^(?:https?://)?[\w-]+(?:.[\w-]+)+:\d{1,5}/?$</td><td>例如：<a class="link"   href="http://127.0.0.1:8888/" >http://127.0.0.1:8888/<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>URL</td><td>^https?://(?:www.)?[-a-zA-Z0-9@:%.<em>+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()!@:%</em>+.~#?&amp;//=]*)$</td><td>例如：<a class="link"   href="https://www.r2coding.com/#/README?id=1" >https://www.r2coding.com/#/README?id=1<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>邮箱email</td><td>^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$</td><td>支持中文，例如：codesheep@cs.com</td></tr><tr><td>用户名</td><td>^[a-zA-Z0-9_-]{4,20}$</td><td>4到20位</td></tr><tr><td>弱密码</td><td>^[\w]{6,16}$</td><td>6~16位，包含大小写字母和数字的组合</td></tr><tr><td>强密码</td><td>^.<em>(?=.{6,})(?=.</em>\d)(?=.<em>[A-Z])(?=.</em>[a-z])(?=.<em>[!@.#$%^&amp;</em>?  ]).*$</td><td>至少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符</td></tr><tr><td>端口号</td><td>^(?:[0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$</td><td>例如：65535</td></tr><tr><td>IPv4地址</td><td>^(?:(?:\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]).){3}(?:\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])$</td><td>例如：192.168.31.1</td></tr><tr><td>IPv4地址+端口</td><td>^(?:(?:\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]).){3}(?:\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(?::(?:[0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?$</td><td>例如：192.168.31.1:8080</td></tr><tr><td>IPv6地址</td><td>^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$</td><td>例如：CDCD:910A:2222:5498:8475:1111:3900:2020</td></tr><tr><td>IPv6地址+端口</td><td>^[(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))](?::(?:[0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?$</td><td>例如：[CDCD:910A:2222:5498:8475:1111:3900:2020]:9800</td></tr><tr><td>子网掩码</td><td>^(?:254|252|248|240|224|192|128).0.0.0|255.(?:254|252|248|240|224|192|128|0).0.0|255.255.(?:254|252|248|240|224|192|128|0).0|255.255.255.(?:255|254|252|248|240|224|192|128|0)$</td><td>例如：255.255.255.0</td></tr><tr><td>MAC地址</td><td>^(?:(?:[a-f0-9A-F]{2}:){5}|(?:[a-f0-9A-F]{2}-){5})[a-f0-9A-F]{2}$</td><td></td></tr><tr><td>Version版本号</td><td>^\d+(?:.\d+){2}$</td><td>例如：12.1.1</td></tr><tr><td>图片后缀</td><td>.(gif|png|jpg|jpeg|webp|svg|psd|bmp|tif)+</td><td>可按需增删扩展名集合</td></tr><tr><td>视频后缀</td><td>.(swf|avi|flv|mpg|rm|mov|wav|asf|3gp|mkv|rmvb|mp4)+</td><td>可按需增删扩展名集合</td></tr><tr><td>图片链接</td><td>(?:https?://)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.+.(gif|png|jpg|jpeg|webp|svg|psd|bmp|tif)</td><td>可按需增删扩展名集合</td></tr><tr><td>视频链接</td><td>(?:https?://)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.+.(swf|avi|flv|mpg|rm|mov|wav|asf|3gp|mkv|rmvb|mp4)</td><td>可按需增删扩展名集合</td></tr><tr><td>迅雷链接</td><td>thunderx?://[a-zA-Z\d]+=</td><td></td></tr><tr><td>ed2k链接</td><td>ed2k://|file|.+|/</td><td></td></tr><tr><td>磁力链接</td><td>magnet:?xt=urn:btih:[0-9a-fA-F]{40,}.*</td><td></td></tr></tbody></table><h3 id="2-6-其他">2.6 其他</h3><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>MD5格式</td><td>^(?:[a-f\d]{32}|[A-F\d]{32})$</td><td>32位MD5，例如：7552E7071B118CBFFEC8C930455B4297</td></tr><tr><td>BASE64格式</td><td>^\s<em>data:(?:[a-z]+/[a-z0-9-+.]+(?:;[a-z-]+=[a-z0-9-]+)?)?(?:;base64)?,([a-z0-9!$&amp;',()</em>+;=-._~:@/?%\s]<em>?)\s</em>$</td><td>例如：data:image/jpeg;base64,xxxx==</td></tr><tr><td>UUID</td><td>^[a-f\d]{4}(?:[a-f\d]{4}-){4}[a-f\d]{12}$</td><td>例如：94f9d45a-71b0-4b3c-b69d-20c4bc9c8fdd</td></tr><tr><td>16进制</td><td>^[A-Fa-f0-9]+$</td><td>例如：FFFFFF</td></tr><tr><td>16进制颜色</td><td>^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$</td><td>例如：#FFFFFF</td></tr><tr><td>SQL语句</td><td>^(?:select|drop|delete|create|update|insert).*$</td><td></td></tr><tr><td>Java包名</td><td>^(?:[a-zA-Z_]\w*)+(?:[.][a-zA-Z_]\w*)+$</td><td>例如：com.r2coding.controller</td></tr><tr><td>文件扩展名</td><td>.(?:doc|pdf|txt)</td><td>可按需增删扩展名集合</td></tr><tr><td>Windows文件路径</td><td>^[a-zA-Z]:(?:\[\w\u4E00-\u9FA5\s]+)+[.\w\u4E00-\u9FA5\s]+$</td><td>例如：C:\Users\Administrator\Desktop\a.txt</td></tr><tr><td>Windows文件夹路径</td><td>^[a-zA-Z]:(?:\[\w\u4E00-\u9FA5\s]+)+$</td><td>例如：C:\Users\Administrator\Desktop</td></tr><tr><td>Linux文件路径</td><td>^/(?:[^/]+/)*[^/]+$</td><td>例如：/root/library/a.txt</td></tr><tr><td>Linux文件夹路径</td><td>^/(?:[^/]+/)*$</td><td>例如：/root/library/</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;正则表达式&lt;/h1&gt;
&lt;h2 id=&quot;1-基础正则表达式速查表&quot;&gt;1. 基础正则表达式速查表&lt;/h2&gt;
&lt;h3 id=&quot;1-1-字符&quot;&gt;1.1 字符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表达式&lt;/</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>区块链环境配置教程</title>
    <link href="http://example.com/2024/05/09/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>http://example.com/2024/05/09/%E5%8C%BA%E5%9D%97%E9%93%BE/</id>
    <published>2024-05-09T07:31:07.000Z</published>
    <updated>2024-05-09T08:29:06.425Z</updated>
    
    <content type="html"><![CDATA[<h1>区块链环境配置教程</h1><h2 id="一、安装CentOS">一、安装CentOS</h2><p>本例中采用虚拟化软件VMware Workstation安装CentOS 7.3（最小安装minimal）。实际应用中，单个服务器一般都设定为单一功能，比如Web服务器，数据库服务器，LDAP服务器等，或者多台服务器分布式部署云计算组件如Hadoop等，单个服务器只需要操作系统的基本功能，因此CentOS最小化安装符合需求，如果需要额外的功能，可以在使用过程中增加。云服务提供商（例如阿里云）提供的云服务器操作系统一般是CentOS minimal。</p><p>本例CentOS安装环境如下：</p><p>主机（Host Machine）：CPU 8核，内存16G，操作系统Windows 10专业版64位</p><p>虚拟化软件：VMware Workstation 14 pro</p><p>到 <a class="link"   href="https://www.centos.org/" >https://www.centos.org/<i class="fas fa-external-link-alt"></i></a> 下载安装包，本例是CentOS-7-x86_64-DVD-1804.iso</p><h3 id="1-1-安装前VMware设置">1.1 安装前VMware设置</h3><p>1、在VMware菜单“编辑-首选项”可以设置虚拟机默认放置的目录，应选择有足够空间的硬盘分区。本例中是 D:\MyVM（根据自己喜好设置虚拟机存放的位置）</p><p>2、创建虚拟机采用“自定义(高级)”配置，虚拟机名称(自己设置)。</p><p>3、选择安装来源时，载入CentOS的ISO后，VMware会自动识别出操作系统类型和版本。也可以选择“稍后安装操作系统”不采用简易安装，而采用手动安装。</p><p>4、为虚机分配处理器1个，内核数量2个，2G/4G（根据自己电脑内存大小）内存。本例中的这个虚机作为实验环境，将安装多种应用，因此配置较高。实验用虚机一般1核2G内存即可，可租用的轻量级云服务器一般是1核1G内存。实际应用虚机则根据需要分配资源，计算单元则对CPU要求较高，内容服务器则对内存要求较高。</p><p>5、使用NAT网络（默认选项），虚机没有与主机同级的IP地址。</p><p>桥接，NAT，仅主机模式，三者的简要区别如下：</p><p>（1）桥接：虚机与主机在网络中地位一样，虚机拥有与主机同级的独立IP地址。</p><p>（2）NAT：虚机共享主机的IP地址访问Internet，同一个主机中的各个虚机在同一网段中，可互相访问。外部无法直接访问虚机，但可通过主机的转接访问虚机。</p><p>（3）仅主机模式：同一主机中的各个虚机可互相访问，虚机无法访问Internet，外部也无法访问虚机。</p><p>6、I/O类型：默认LSI Logic，磁盘类型：默认SCSI，选择磁盘：创建新虚拟磁盘。</p><p>7、分配20G虚拟磁盘空间，存为单独文件（非默认选项）。</p><p>8、指定虚机磁盘文件，保持默认。</p><p>9、开始安装时，可能会提示要更改BIOS设置以支持64位操作系统之类的，按照提示修改主机BIOS设置，再回来安装。</p><p>注意：一般新的电脑无需设置自动支持64位虚拟化，有些电脑需要在BIOS里设置以支持64位虚拟化，有些更旧的电脑完全不支持64位虚拟化，则无法在VMware里安装64位的操作系统。</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135320528.8kzwg8l089.jpg"  alt="image-20240509135320528"></p><p>设置完成如上图，点击“完成”开始安装。</p><h3 id="1-2-安装过程">1.2 安装过程</h3><p>注意：安装过程中，鼠标点击虚机界面即可进入虚机操作，组合键ctrl + alt 可使鼠标返回主机。在VMware Workstation窗口的左下角会有提示。</p><p>1、安装过程与在真实裸机上安装一样，初始界面按键“i”选择“Install CentOS”，然后回车进入安装过程。</p><p>2、选择语言：保持默认 English - Englisth (United States)</p><p>3、如下图所示，设置安装选项：</p><p>Date &amp; Time 选到 Asian / Shanghai</p><p>Language Support 可以把中文，简体中文(中国)选上</p><p>Software Selection 保持Minimal Install不变</p><p>Installation Destination 需要点开，默认是自动配置磁盘，不需要修改，直接点“Done”按钮返回即可，黄色的感叹号才会消失，此界面右下角“Begin Installation”按钮才会亮起。</p><p>Network &amp; Hostname 点进去，如果有显示有线网络ens33之类的，打开ON</p><p>KDUMP可以设置为Disabled，保持默认也可以。</p><p>设置完成后，点击右下角“Begin Installation”按钮开始安装。</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135414360.92py4tmdt3.jpg"  alt="image-20240509135414360"></p><p>4、安装的过程中给root用户设置密码（4geT%not），非必需。如果密码太弱，需点击两次确定才能完成操作。</p><p>新建一个用户admin（密码d00r%Key），勾选“Make this user administrator”，今后的常用登录用户。如果密码太弱，需点击两次确定才能完成操作。</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135433610.13ll9r79t4.jpg"  alt="image-20240509135433610"></p><p>安装完成，点击“Reboot”重新启动。</p><p>5、系统是最小化安装，没有GUI，默认以admin登录，安装完成。</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135445611.7awz9x387e.jpg"  alt="image-20240509135445611"></p><p>非必需：虚机屏幕有时候不匹配VMware的窗口，需要拉动窗口的滚动条才能看见全部的虚机屏幕内容。从VMware菜单“电源 - 关闭客户机”，然后再开启此虚机，可解决这个问题。</p><h3 id="1-3-忘记密码">1.3 忘记密码</h3><p><strong>下面是CentOS 7的root密码修改</strong></p><p>开机按esc</p><p>选择CentOS Linux (3.10.0-693…)     按 e 键</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135456058.7i075cpdmy.jpg"  alt="image-20240509135456058"></p><p><code> </code>光标移动到 linux 16 开头的行，找到 ro 改为 rw init=sysroot/bin/sh</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135507355.2krqbibltj.jpg"  alt="image-20240509135507355"></p><p>按 Ctrl+x 执行</p><p>进入后输 chroot /sysroot</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135527785.92py4tml2w.jpg"  alt="image-20240509135527785"></p><p>输入 passwd</p><p>根据提示输入2次新密码</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135545983.8z6c73tid5.jpg"  alt="image-20240509135545983"></p><p>完成后输入  touch /.autorelabel  更新系统信息</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135557209.9kfztenynv.jpg"  alt="image-20240509135557209"></p><p>exit</p><p>reboot 重启</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135609834.7sn0yi4lrw.jpg"  alt="image-20240509135609834"></p><p>重启过程慢，耐心等等</p><p>重启后用新密码登录</p><h2 id="二、基本系统设置">二、基本系统设置</h2><h3 id="2-1-安装后设置">2.1 安装后设置</h3><h4 id="2-1-1-关于用户">2.1.1 关于用户</h4><p>目前系统里有2个用户，root是超级管理员，一般不用此账号登录；admin是常用用户，系统管理员。</p><p>系统提示符为 # 表明用户为root，提示符为$ 表明用户为其他用户。</p><p>每个用户都有自己的主目录，以 ~表示，root用户是 /root，其他用户是 /home/用户名。例如admin输入命令 cd ~ 则会进入其主目录 /home/admin</p><p>admin需要执行root权限的命令时，可以用 sudo 临时获得权限，也可以用 su 切换身份为root。</p><p>使用sudo时，需要输入admin用户自己的密码，使用 su时，需要输入root用户的密码，使用“sudo su”则可以使用admin自己的密码切换到root用户身份，在root用户没有设置密码时，这个方法很好用。</p><p>1、使用sudo不需要输入密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo -f /etc/sudoers</span><br></pre></td></tr></table></figure><p>如下修改内容，在 %wheel ALL=(ALL) ALL 前加注释符#，去掉 %wheel ALL=(ALL) NOPASSWD:ALL 前的注释符。保存退出就行了。</p><p>这是针对wheel这个组的设置，这个组的成员都不需要输入密码就可以使用sudo，admin是wheel组的成员。</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135652374.8s34bo7cxp.jpg"  alt="image-20240509135652374"></p><p>传统修改方法是在 root ALL=(ALL) ALL 下面增加一行 admin ALL=(ALL) NOPASSWD:ALL 但在这里会被 %wheel ALL=(ALL) ALL 覆盖掉。原因是在安装过程中，创建 admin用户时使其成为管理员，便成为了 wheel组的成员。系统只允许wheel组的用户来执行“su”命令登录为root用户，而让其他组的用户即使执行“su”、输入了正确的root密码，也无法登录为root用户。</p><p>用visudo编辑sudoers文件是正确的做法。有些做法是增加文件sudoers的写权限，用vi修改，再去掉其写权限。可能会出现文件权限错乱，如下恢复sudoers文件的正确属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod 0440 /etc/sudoers</span><br></pre></td></tr></table></figure><h4 id="2-2-2-连接网络，更新系统">2.2.2 连接网络，更新系统</h4><p>查找配置网络文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls /etc/sysconfig/network-scripts/</span><br></pre></td></tr></table></figure><p>看到有形如 ifcfg-ens33 或 ifcfg-eth0 这样的文件，修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><p>把 ONBOOT=no 改成 yes 即可，保存退出。</p><p>重启网络服务，应用设置，就可以联网了。安装时选择的是NAT方式，因此是使用主机的IP地址连接到Internet。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart network.service</span><br></pre></td></tr></table></figure><p>更新系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum update</span><br></pre></td></tr></table></figure><p>首先会查询要更新哪些内容，询问是否OK，确认后开始更新。</p><p>安装必备系统组件perl，gcc，kernel-devel，wget，yum-utils，net-tools</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum -y install perl gcc kernel-devel wget</span><br><span class="line"></span><br><span class="line">$ sudo yum -y install yum-utils</span><br><span class="line"></span><br><span class="line">$ sudo yum -y install net-tools</span><br><span class="line"></span><br><span class="line">yum install -y install unzip zip</span><br></pre></td></tr></table></figure><p>更新完毕后，可以重新启动一下系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl reboot</span><br></pre></td></tr></table></figure><h3 id="2-2-网络设置">2.2 网络设置</h3><p>安装net-tools包，以便后续使用ifconfig命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum -y install net-tools</span><br></pre></td></tr></table></figure><h2 id="三、区块链的环境搭建">三、区块链的环境搭建</h2><p>搭建Hyperledger fabric环境</p><p>搭建过程</p><h3 id="3-1-Go安装。（官网地址：https-golang-google-cn-dl-）">3.1 Go安装。（官网地址：<a class="link"   href="https://golang.google.cn/dl/%20" >https://golang.google.cn/dl/ <i class="fas fa-external-link-alt"></i></a>）</h3><ol><li><strong>下载安装包</strong></li></ol><p>箭头所指地址+自己系统所对应的版本。使用wget命令。</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509140638680.8s34bo7cxs.jpg"  alt="image-20240509140638680"></p><p>以我自己安装的为例，图中椭圆框中即为我所安装版本。</p><p>所以下载命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://golang.google.cn/dl/go1.18.5.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>解压安装包到指定路径</strong></li></ol><p>将下载的压缩包通过下面命令进行解压，一定注意大小写（否则可能导致安装失败）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf go1.18.5.linux-amd64.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>设置环境变量</strong></li></ol><p>使用vi /etc/profile 编辑profile文件。</p><p>添加以下内容到profile 文件中（gopath应提前创建好，或者配置完成后别忘了创建）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#go setting</span><br><span class="line"></span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line"></span><br><span class="line">export GOPATH=/usr/local/gopath</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br></pre></td></tr></table></figure><p>保存并退出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile 使文件立即生效。</span><br></pre></td></tr></table></figure><p>在gopath路径下使用mkdir创建三个文件，即mkdir src bin pkg。</p><p>其中bin存放编译后的可执行文件；pkg存放编译后的包文件；src存放项目源文件。</p><p>查看是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure><p>编辑hello.go文件测试.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/gopath/src/hello.go</span><br></pre></td></tr></table></figure><p>在hello.go中编写如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="string">`    `</span>fmt.Println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存并退出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run hello.go</span><br></pre></td></tr></table></figure><p>显示Hello world!正确执行。截止到此，安装GO语言环境完成。</p><h3 id="3-2-docker安装">3.2 <a class="link"   href="https://so.csdn.net/so/search?q=docker&amp;spm=1001.2101.3001.7020" >docker<i class="fas fa-external-link-alt"></i></a>安装</h3><p>第一种方式：<strong>curl -fsSL <a class="link"   href="https://get.docker.com/" >https://get.docker.com/<i class="fas fa-external-link-alt"></i></a> | sh 比较快捷，但是可能会因为无法访问国外的镜像而出错。如果不能安装，就是用第二种方式。</strong></p><p><strong>第二种方式（推荐）：</strong></p><p><strong>如果以前安装过docker，请先卸载或删除所有依赖关系。如果没装过跳过此过程。</strong></p><p>yum list installed | grep docker；查看所有安装的docker程序</p><p>yum -y remove+要删除程序的完整名称（如果安装的比较多，这个过程可能有点麻烦）</p><p>rm -rf /var/lib/docker：删除镜像容器。</p><p>输入Docker version出现如下图所示字样，表明已卸载干净。</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509141144124.4n7izka6v5.jpg"  alt="image-20240509141144124"></p><p><strong>然后开始安装docker</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #安装阿里镜像源</span><br><span class="line"></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin #（默认安装的是最新版的）</span><br></pre></td></tr></table></figure><p>查看版本信息</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509141520528.syrgls8xu.jpg"  alt="image-20240509141520528"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker #启动docker</span><br><span class="line">systemctl enable docker #将docker设置为开机自启，以便后续操作不会出错。</span><br></pre></td></tr></table></figure><p>安装docker-compose</p><p>1.下载docker-compose</p><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -SL https://github.com/docker/compose/releases/download/v2.11.2/docker-compose-linux-x86\_64 -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>也可以下载别的版本，只需将命令行中v2.11.2换成自己想装的版本即可。</p><p>2. 给docker-compose文件添加可执行权限</p><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>3. 添加软连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><p>4.查看版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker-compose version</span><br></pre></td></tr></table></figure><h3 id="3-3-nodejs安装">3.3 nodejs安装</h3><p>去这个网站<a class="link"   href="https://nodejs.org/dist/" >https://nodejs.org/dist/<i class="fas fa-external-link-alt"></i></a>找到自己想安装的版本。</p><p>复制整个网址，使用以下命令下载，例如我下载的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wget https://nodejs.org/dist/v16.14.1/node-v16.14.1-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>2.解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf node-v16.14.1-linux-x64.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line">cd /usr/local</span><br><span class="line"></span><br><span class="line">mv node-v10.19.0-linux-x64/ nodejs</span><br></pre></td></tr></table></figure><p>3.vi /etc/profile 增加环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export NODE\_HOME=/usr/local/nodejs</span><br><span class="line"></span><br><span class="line">export PATH=$NODE\_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>保存并退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile 使文件立即生效。</span><br></pre></td></tr></table></figure><p>4. 查看版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line"></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>5.设置淘宝镜像源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>6.which node、 whereis node   查看有无 node、npm等命令</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509141730932.73trehh2ro.jpg"  alt="image-20240509141730932"></p><p>7. 安装全局 pm2</p><p>npm install -g pm2</p><p>8. 查看 有无 pm2命令 ， pm2 版本</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509141742607.4jnx1uh45h.jpg"  alt="image-20240509141742607"></p><p><strong>下载源代码</strong><br>因为要用到git，所以需要先安装git。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p><strong>下载相关镜像文件。</strong></p><p>在想要安装<a class="link"   href="https://so.csdn.net/so/search?q=fabric&amp;spm=1001.2101.3001.7020" >fabric<i class="fas fa-external-link-alt"></i></a>的目录下运行以下命令来下载fabric （时间可能会有点久）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/hyperledger/fabric.git</span><br></pre></td></tr></table></figure><p>（git clone克隆时出现fatal: unable to access ‘<a class="link"   href="https://github.com/%5C*%5C*%E2%80%98:" >https://github.com/\*\*‘:<i class="fas fa-external-link-alt"></i></a> TCP connection resset by peer）</p><p>解决方法：</p><p>##发生这种情况是git设置了代理，取消代理即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hya ~]# git config --global --unset http.proxy</span><br><span class="line"></span><br><span class="line">[root@hya ~]# git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>下载完成后会得到一个fabric文件夹，进入fabric/scripts目录可以看到一个bootstrap.sh脚本（注意刚开始是没有fabric-samples这个文件夹的，是执行脚本后生成的）</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509142109592.1seutrv03q.jpg"  alt="image-20240509142109592"></p><p>直接执行bootstrap.sh脚本，就会自动进行fabric相关镜像的下载 （时间有点久，如果出现长时间停顿，可能需要重启虚拟机后重新执行脚本）</p><p>当相关镜像全部下载完成后，会自动罗列出下载的内容</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509142120044.8ad2n35zd4.jpg"  alt="image-20240509142120044"></p><p><strong>构建网络</strong></p><p>Fabric 1.x.x版本的应该是进入fabric/scripts/fabric-samples/first-network/</p><p>Fabric2.x.x版本的进入fabric/scripts/fabric-samples/test-network/</p><p>执行以下命令，开启测试网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./network.sh down</span><br><span class="line"></span><br><span class="line">./network.sh up</span><br></pre></td></tr></table></figure><p>创建信道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network.sh createChannel</span><br></pre></td></tr></table></figure><p>下载go依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on</span><br><span class="line"></span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><p>查看是否切换成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure><p>进入链码所在路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/go/fabric/scripts/fabric-samples/asset-transfer-basic/chaincode-go</span><br></pre></td></tr></table></figure><p>下载依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod vendor</span><br></pre></td></tr></table></figure><h2 id="四、在通道上启动链码chaincode（智能合约）">四、在通道上启动链码chaincode（智能合约）</h2><p>切换回 /fabric-samples/test-network 目录：</p><p>./network.sh deployCC -ccn basic -ccp …/asset-transfer-basic/chaincode-go -ccl go</p><p>如果出现下图所示情况：</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509142221121.4jnx1uh45l.jpg"  alt="image-20240509142221121"></p><p>解决方案</p><p><strong>下载并安装EPEL</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh epel-release-latest-7.noarch.rpm</span><br></pre></td></tr></table></figure><p># 检查是否已添加至源列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist</span><br></pre></td></tr></table></figure><p><strong>安装jq</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install jq</span><br></pre></td></tr></table></figure><h2 id="五、与网络交互">五、与网络交互</h2><p>首先确保自己位于test-network目录下。</p><p>进入CLI容器，进行invoke交互，需要几行命令设置CLI的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$&#123;PWD&#125;/../bin:$PATH</span><br><span class="line">export FABRIC\_CFG\_PATH=$PWD/../config/</span><br></pre></td></tr></table></figure><p>先设置为org1的环境变量进行交互：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export CORE\_PEER\_TLS\_ENABLED=true</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_LOCALMSPID=&quot;Org1MSP&quot;</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_TLS\_ROOTCERT\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_ADDRESS=localhost:7051</span><br></pre></td></tr></table></figure><p>用下面的命令初始化账本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot; -c &#x27;&#123;&quot;function&quot;:&quot;InitLedger&quot;,&quot;Args&quot;:[]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>使用下面的命令查找账本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -C mychannel -n basic -c &#x27;&#123;&quot;Args&quot;:[&quot;GetAllAssets&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>通过命令改变一笔资产的所有者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot; -c &#x27;&#123;&quot;function&quot;:&quot;TransferAsset&quot;,&quot;Args&quot;:[&quot;asset6&quot;,&quot;Christopher&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="六、关闭测试网络">六、关闭测试网络</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network.sh down</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;区块链环境配置教程&lt;/h1&gt;
&lt;h2 id=&quot;一、安装CentOS&quot;&gt;一、安装CentOS&lt;/h2&gt;
&lt;p&gt;本例中采用虚拟化软件VMware Workstation安装CentOS 7.3（最小安装minimal）。实际应用中，单个服务器一般都设定为单一功能，比如Web服</summary>
      
    
    
    
    
    <category term="区块链" scheme="http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用Hexo-asset-image图片无法正常显示的一些解决方案</title>
    <link href="http://example.com/2024/05/09/hexo-asset-image-note/"/>
    <id>http://example.com/2024/05/09/hexo-asset-image-note/</id>
    <published>2024-05-09T02:28:07.000Z</published>
    <updated>2024-05-09T04:45:46.094Z</updated>
    
    <content type="html"><![CDATA[<h1>hexo使用Hexo-asset-image图片无法正常显示的一些解决方案</h1><h2 id="1-问题描述">1. 问题描述</h2><p>在进行个人博客的搭建工作时，</p><h2 id="2-解决方案">2. 解决方案</h2><h3 id="2-1-修改hexo-asset-image的代码（未测试）">2.1 修改hexo-asset-image的代码（未测试）</h3><p>详细步骤参考下面文章：</p><p><a class="link"   href="https://blog.csdn.net/kurapika_030/article/details/130598712" >【Hexo】hexo-asset-image在hexo6.3.0下的使用以及与abbrlink插件的修改-CSDN博客<i class="fas fa-external-link-alt"></i></a></p><h3 id="2-2-换用hexo-renderer-marked-it（测试有效）">2.2 换用hexo-renderer-marked-it（测试有效）</h3><p>根据hexo官方中的描述如下</p><p>如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</p><p><strong>文章资源文件夹</strong></p><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p><p><strong>相对路径引用的标签插件</strong></p><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的<a class="link"   href="https://hexo.io/zh-cn/docs/tag-plugins#%E5%BC%95%E7%94%A8%E8%B5%84%E6%BA%90" >标签插件<i class="fas fa-external-link-alt"></i></a>被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure><p>比如说：当你打开文章资源文件夹功能后，你把一个 <code>example.jpg</code> 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](example.jpg)</code> ，它将 <em>不会</em> 出现在首页上。（但是它会在文章中按你期待的方式工作）</p><p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><p><strong>使用 Markdown 嵌入图片</strong></p><p><a class="link"   href="https://github.com/hexojs/hexo-renderer-marked" >hexo-renderer-marked<i class="fas fa-external-link-alt"></i></a> 3.1.0 引入了一个新的选项，其允许你无需使用 <code>asset_img</code> 标签插件就可以在 markdown 中嵌入图片（进入链接后往下翻找进入hexo-renderer-marked-it）</p><p>如需启用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">post_asset_folder: true</span><br><span class="line">images:</span><br><span class="line">    lazyload: false</span><br><span class="line">    prepend_root: true</span><br><span class="line">    post_asset: true</span><br></pre></td></tr></table></figure><p>启用后，资源图片将会被自动解析为其对应文章的路径。<br>例如： <code>image.jpg</code> 位置为 <code>/2020/01/02/foo/image.jpg</code> ，这表示它是 <code>/2020/01/02/foo/</code> 文章的一张资源图片， <code>![](image.jpg)</code> 将会被解析为 <code>&lt;img   src=&quot;/2020/01/02/foo/image.jpg&quot; &gt;</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意事项：</span><br><span class="line">如果使用![](image.jpg)这种引用格式的话在markdown编辑器中是无法看到图片的，只能在浏览器中看到</span><br><span class="line">可以使用![](your_essay_name/image.jpg)引用格式这样本地和浏览器中均可看到</span><br></pre></td></tr></table></figure><p>!!!特别注意你的文章名称不能是中文，这样会导致你的图片在浏览器中无法显示。博主亲测 :joy:</p><h3 id="2-3-使用图床">2.3 使用图床</h3><p>如果使用图床的话，这样post_asset_folder就可以不用启用了也不用安装图片转换插件了。博主目前正在使用的就是图床，网上也有人说由于图床有时可能不稳定会导致浏览器无法访问照片，管他呢先用着再说。</p><p>博主使用的图床工具是<a class="link"   href="https://picx.xpoet.cn/" >PicX<i class="fas fa-external-link-alt"></i></a>，感觉挺好用的不用安装直接在线就可上传图片。网上也有很多别的图床工具例如PicGo等等，配置教程就不一一赘述了，大家可自行百度。</p><p>PicX配置教程如下：</p><h4 id="2-3-1-GitHub-OAuth-授权登录">2.3.1 GitHub OAuth 授权登录</h4><p>不推荐，原因是还需要安装picX，麻烦！！！！！！！！！！！！！</p><h4 id="2-3-2-填写GitHub-Token登录">2.3.2 填写GitHub Token登录</h4><ol><li>创建一个带有 <code>repo</code> 权限的 GitHub Token点击 <a class="link"   href="https://github.com/settings/tokens/new" >https://github.com/settings/tokens/new<i class="fas fa-external-link-alt"></i></a> 快速新建 GitHub Token</li></ol><p><img   src="https://github.com/dettry/picx-images-hosting/raw/master/hexo-asset-image-note/image-20240509121100220.1e8f2s8xy5.jpg"  alt="image-20240509121100220"></p><ol start="2"><li><p>点击 <strong><code>Generate token</code></strong> 按钮，生成 GitHub Token并保存。</p></li><li><p>图床配置</p></li></ol><ul><li>填写 GitHub Token 之后，点击 <strong><code>一键配置</code></strong> PicX 会自动创建 GitHub 仓库，完成仓库、分支和目录之间的配置，并跳转到图片上传页面。</li></ul><p><img   src="https://github.com/dettry/picx-images-hosting/raw/master/hexo-asset-image-note/image-20240509121829318.1seutnh8ta.jpg"  alt="image-20240509121829318"></p><ul><li><p>进入页面后可以选择图床配置新建目录来设置新的图片保存路径，也可以直接上传图片。</p></li><li><p>图床设置中除了图片压缩选择图中的选项外，其余保持默认。</p></li></ul><p><img   src="https://github.com/dettry/picx-images-hosting/raw/master/hexo-asset-image-note/image-20240509123525925.2a4wi93vfm.jpg"  alt="image-20240509123525925"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;hexo使用Hexo-asset-image图片无法正常显示的一些解决方案&lt;/h1&gt;
&lt;h2 id=&quot;1-问题描述&quot;&gt;1. 问题描述&lt;/h2&gt;
&lt;p&gt;在进行个人博客的搭建工作时，&lt;/p&gt;
&lt;h2 id=&quot;2-解决方案&quot;&gt;2. 解决方案&lt;/h2&gt;
&lt;h3 id=&quot;2-1-修</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>k8s集群搭建常见问题汇总</title>
    <link href="http://example.com/2024/05/04/kubeadm%E6%90%AD%E5%BB%BAKubernetes%E9%9B%86%E7%BE%A4%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2024/05/04/kubeadm%E6%90%AD%E5%BB%BAKubernetes%E9%9B%86%E7%BE%A4%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2024-05-04T05:50:36.000Z</published>
    <updated>2024-05-04T06:29:08.115Z</updated>
    
    <content type="html"><![CDATA[<h1>kubeadm搭建Kubernetes集群问题汇总</h1><h2 id="问题一：kubeadm-init-报错-ERROR-CRI-container-runtime-is-not-running需要使用的解决方法">问题一：kubeadm init 报错 [ERROR CRI]: container runtime is not running需要使用的解决方法</h2><ol><li>kubernetes使用crictl命令管理CRI，查看其配置文件<code>/etc/crictl.yaml</code>。初始情况下没有这个配置文件，这里建议添加这个配置，否则kubeadm init时会报其他错。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#containered做进行时</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br><span class="line">#cri-docker做进行时</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#执行crictl images list命令不报错</span><br><span class="line">crictl images list</span><br></pre></td></tr></table></figure><ol start="2"><li>查看配置文件：/etc/containerd/config.toml</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改 disabled_plugins = [&quot;cri&quot;]为 disabled_plugins = []</span><br></pre></td></tr></table></figure><p>重启containerd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure><h2 id="问题二：ERROR-FileContent–proc-sys-net-bridge-bridge-nf-call-iptables">问题二：ERROR FileContent–proc-sys-net-bridge-bridge-nf-call-iptables</h2><p>报错原因：网桥过滤和地址转发功能不可用</p><p>解决方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/sysctl.d/kubernetes.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 然后执行,生效</span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><p>如果执行上述命令报/proc/sys/net/bridge/bridge-nf-call-iptables does not exist错误是因为网桥功能未开启，执行下面的命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe br_netfilter</span><br></pre></td></tr></table></figure><h2 id="问题三：kubelet报错failed-to-run-Kubelet-running-with-swap-on-is-not-supported">问题三：kubelet报错failed to run Kubelet: running with swap on is not supported</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure><h2 id="问题四：kubeadm-init时报错一些配置文件已存在">问题四：kubeadm init时报错一些配置文件已存在</h2><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><h2 id="问题五：kubeadm-init时，kubelet-报错crictl-runtime-endpoint配置不对">问题五：kubeadm init时，kubelet 报错crictl --runtime-endpoint配置不对</h2><p>从日志看出时crictl命令运行时有问题。unix:///var/run/containerd/containerd.sock不存在。运行crictl命令，发现同样报错。出现报错的原因是crictl下载镜像时使用的是默认端点<code>[unix:///var/run/dockershim.sock unix:///run/containerd/containerd.sock unix:///run/crio/crio.sock unix:///var/run/cri-dockerd.sock]</code>。这些端点废弃了，需要重新指定<code>containerd.sock</code>。后面的报错就是找不到dockershim.sock。</p><p><strong>解决方法：修改crictl文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#containered做进行时</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br><span class="line">#cri-docker做进行时</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#执行crictl images list命令不报错</span><br><span class="line">crictl images list</span><br></pre></td></tr></table></figure><h2 id="问题六：报Usage-of-CRI-endpoints-without-URL-scheme-is-deprecated-and-can-cause-kubelet-errors-in-the-future-警告">问题六：报Usage of CRI endpoints without URL scheme is deprecated and can cause kubelet errors in the future.警告</h2><p>W0504 10:46:57.238606    6046 initconfiguration.go:120] Usage of CRI endpoints without URL scheme is deprecated and can cause kubelet errors in the future. Automatically prepending scheme “unix” to the “criSocket” with value “/var/run/cri-dockerd.sock”. Please update your configuration!</p><p>如果是contained做进行时就执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo crictl config \</span><br><span class="line">--set runtime-endpoint=unix:///var/run/containerd/containerd.sock \</span><br><span class="line">--set image-endpoint=unix:///var/run/containerd/containerd.sock</span><br><span class="line">#或者</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>如果时cri-docker做进行时就执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo crictl config \</span><br><span class="line">--set runtime-endpoint=unix:///var/run/cri-dockerd.sock \</span><br><span class="line">--set image-endpoint=unix:///var/run/cri-dockerd.sock</span><br><span class="line">#或者</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="问题七：报错pause镜像获取失败">问题七：报错pause镜像获取失败</h2><p>通过log提示执行命令<code>crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock ps -a</code> 发现没有容器在运行。查看containerd的日志，有如下报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">journalctl -fu containerd</span><br><span class="line">...</span><br><span class="line">Oct 11 08:35:16 master.k8s containerd[1903]: time=&quot;2023-10-11T08:35:16.760026536+08:00&quot; level=error msg=&quot;RunPodSandbox for &amp;PodSandboxMetadata&#123;Name:kube-apiserver-node,Uid:a5a7c15a42701ab6c9dca630e6523936,Namespace:kube-system,Attempt:0,&#125; failed, error&quot; error=&quot;failed to get sandbox image \&quot;registry.k8s.io/pause:3.6\&quot;: failed to pull image \&quot;registry.k8s.io/pause:3.6\&quot;: failed to pull and unpack image \&quot;registry.k8s.io/pause:3.6\&quot;: failed to resolve reference \&quot;registry.k8s.io/pause:3.6\&quot;: failed to do request: Head \&quot;https://asia-east1-docker.pkg.dev/v2/k8s-artifacts-prod/images/pause/manifests/3.6\&quot;: dial tcp 108.177.125.82:443: connect: connection refused&quot;</span><br><span class="line">Oct 11 08:35:18 master.k8s containerd[1903]: time=&quot;2023-10-11T08:35:18.606581001+08:00&quot; level=info msg=&quot;trying next host&quot; error=&quot;failed to do request: Head \&quot;https://asia-east1-docker.pkg.dev/v2/k8s-artifacts-prod/images/pause/manifests/3.6\&quot;: dial tcp 108.177.125.82:443: connect: connection refused&quot; host=registry.k8s.io</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>报错显示containerd拉去镜像失败。error=&quot;failed to get sandbox image&quot;registry.k8s.io/pause:3.6&quot;</p><p><strong>解决方法：修改containered配置</strong></p><ul><li>运行containerd config dump &gt; /etc/containerd/config.toml 命令，将当前配置导出到文件，并修改sandbox_image配置。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 修改配置文件/etc/containerd/config.toml， 更改sandbox_image配置</span><br><span class="line">[plugins]</span><br><span class="line">  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span><br><span class="line">    sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;</span><br></pre></td></tr></table></figure><ul><li>重启containerd</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart containerd</span><br><span class="line"></span><br><span class="line">#查看containerd当前配置，验证pause镜像是否生效</span><br><span class="line">containerd config dump | grep pause</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;kubeadm搭建Kubernetes集群问题汇总&lt;/h1&gt;
&lt;h2 id=&quot;问题一：kubeadm-init-报错-ERROR-CRI-container-runtime-is-not-running需要使用的解决方法&quot;&gt;问题一：kubeadm init 报错 [ERR</summary>
      
    
    
    
    
    <category term="kubernetes" scheme="http://example.com/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>k8s集群搭建教程（使用cri-docker+flannel）</title>
    <link href="http://example.com/2024/05/04/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2024/05/04/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</id>
    <published>2024-05-04T04:24:36.000Z</published>
    <updated>2024-05-07T08:30:29.143Z</updated>
    
    <content type="html"><![CDATA[<h1>k8s集群搭建教程（使用cri-docker+flannel）</h1><h2 id="1-准备工作（所有节点）">1. 准备工作（所有节点）</h2><h3 id="1-1-系统环境-我是没配置也部署成功了，可以先部署，如果失败了再回来进行系统环境优化">1.1 系统环境(我是没配置也部署成功了，可以先部署，如果失败了再回来进行系统环境优化)</h3><ul><li>系统环境优化配置</li></ul><p>CentOs 7.x系统自带的3.10.x内核存在一些bug，导致运行的docker，kubernetes不稳定，获取源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm</span><br></pre></td></tr></table></figure><ul><li>安装内核，装完成后检查 /boot/grub2/grub.cfg中对应内核menuentry中是否包含 initrd16 配置，如果没有，再安装一次！耗时可能会有点久</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=elrepo-kernel install -y kernel-lt </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#查看系统的全部内核</span><br><span class="line">rpm -qa | grep kernel</span><br><span class="line">#kernel-3.10.0-1160.el7.x86_64</span><br><span class="line">#kernel-lt-5.4.271-1.el7.elrepo.x86_64</span><br><span class="line">#kernel-tools-libs-3.10.0-1160.el7.x86_64</span><br><span class="line">#kernel-tools-3.10.0-1160.el7.x86_64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#设置开机从新内核启动</span><br><span class="line">grub2-set-default &#x27;CentoS Linux(5.4.271-1.el7.elrepo.x86_64) 7 (Core)&#x27;</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line">#查看正在使用的内核</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure><h3 id="1-2-系统参数设置">1.2 系统参数设置</h3><ul><li>所有节点关闭swap和防火墙</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">#临时关闭swapoff</span><br><span class="line">swapoff -a</span><br><span class="line">#永久关闭swapoff（如果想永久关闭，将下面命令的#去掉）</span><br><span class="line">#sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><ul><li>禁用SELINUX</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config</span><br></pre></td></tr></table></figure><ul><li>所有节点设置主机名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname  k8s-master</span><br><span class="line">hostnamectl set-hostname  k8s-node1</span><br><span class="line">hostnamectl set-hostname  k8s-node2</span><br></pre></td></tr></table></figure><ul><li>所有节点主机名/IP加入hosts解析</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line"></span><br><span class="line">加入如下内容：</span><br><span class="line">192.168.183.132 k8s-master</span><br><span class="line">192.168.183.133 k8s-node1</span><br><span class="line">192.168.183.134 k8s-node2</span><br></pre></td></tr></table></figure><ul><li>所有节点配置k8s内核</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kubernetes.conf &lt;&lt;EOF</span><br><span class="line">net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables=1</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.ipv4.tcp_tw_recycle=0</span><br><span class="line">vm.swappiness=0 #禁止使用swap空间，只有当系统OOM时才允许使用它</span><br><span class="line">vm.overcommit_memory=1 #不检查物理内存是否够用</span><br><span class="line">vm.panic_on_oom=0 #开启OOM</span><br><span class="line">fs.inotify.max_user_instances=8192</span><br><span class="line">fs.inotify.max_user_watches=1048576</span><br><span class="line">fs.file-max=52706963</span><br><span class="line">fs.nr_open=52706963</span><br><span class="line">net.ipv6.conf.all.disable_ipv6=1</span><br><span class="line">net.netfilter.nf_conntrack_max=2310720</span><br><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br><span class="line">net.ipv4.tcp_keepalive_intvl =15</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 36000</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_max_orphans = 327680</span><br><span class="line">net.ipv4.tcp_orphan_retries = 3</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 16384</span><br><span class="line">net.ipv4.ip_conntrack_max = 65536</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 16384</span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br><span class="line">net.core.somaxconn = 16384</span><br><span class="line">EOF</span><br><span class="line">cp kubernetes.conf /etc/sysctl.d/kubernetes.conf</span><br><span class="line">sysctl -p /etc/sysctl.d/kubernetes.conf</span><br></pre></td></tr></table></figure><ul><li>limit优化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ulimit -SHn 65535</span><br><span class="line"> </span><br><span class="line">cat &lt;&lt;EOF &gt;&gt; /etc/security/limits.conf</span><br><span class="line">soft nofile 655360</span><br><span class="line">hard nofile 131072</span><br><span class="line">soft nproc 655350</span><br><span class="line">hard nproc 655350</span><br><span class="line">soft memlock unlimited</span><br><span class="line">hard memlock unlimited</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="2-组件安装（所有节点）">2. 组件安装（所有节点）</h2><h3 id="2-1-Docker安装">2.1 Docker安装</h3><p>如果你的系统未安装过Docker，直接按照下面步骤操作即可。如果之前安装过，请先自行百度卸载干净。</p><ul><li>安装软件包并设置存储库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><ul><li>安装Docker</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><ul><li>启动Docker</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><ul><li>创建 /etc/docker目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/docker</span><br><span class="line"> </span><br><span class="line">#配置daemon</span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;exec-opts&quot;:[&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">    &quot;log-driver&quot;:&quot;json-file&quot;,</span><br><span class="line">    &quot;log-opts&quot;:&#123;</span><br><span class="line">        &quot;max-size&quot;:&quot;100m&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line"> </span><br><span class="line">#重启docker服务</span><br><span class="line">systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl enable docker</span><br></pre></td></tr></table></figure><ul><li>注意事项</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubernetes 1.24+版本之后，docker必须要加装cir-docker</span><br></pre></td></tr></table></figure><h3 id="2-2-安装cri-docker">2.2 安装cri-docker</h3><p><strong>go安装</strong></p><ul><li>下载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://golang.google.cn/dl/go1.20.12.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#安装go</span><br><span class="line">rm -rf /usr/local/go &amp;&amp; tar -C /usr/local/ -xzvf go1.20.12.linux-amd64.tar.gz </span><br></pre></td></tr></table></figure><ul><li>设置环境变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">添加以下内容到profile 文件中（gopath应提前创建好，或者配置完成后别忘了创建）</span><br><span class="line">#go setting</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/usr/local/gopath</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br><span class="line"></span><br><span class="line">#保存退出执行</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>构建cri-dockerd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Mirantis/cri-dockerd.git</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd cri-dockerd</span><br><span class="line">mkdir bin</span><br><span class="line">go build -o bin/cri-dockerd</span><br><span class="line">mkdir -p /usr/local/bin</span><br><span class="line">install -o root -g root -m 0755 bin/cri-dockerd /usr/local/bin/cri-dockerd</span><br><span class="line">cp -a packaging/systemd/* /etc/systemd/system</span><br><span class="line">sed -i -e &#x27;s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,&#x27; /etc/systemd/system/cri-docker.service</span><br></pre></td></tr></table></figure><p><strong>Kubernetes使用</strong></p><ul><li>编辑：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/cri-docker.service</span><br></pre></td></tr></table></figure><p>在ExecStart后面追加，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/local/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9</span><br></pre></td></tr></table></figure><ul><li>创建cri-docker启动文件，然后拷贝到其他节点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/cri-docker.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=CRI Interface for Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.mirantis.com</span><br><span class="line">After=network-online.target firewalld.service docker.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=cri-docker.socket</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/bin/cri-dockerd --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br><span class="line"> </span><br><span class="line">StartLimitBurst=3</span><br><span class="line"> </span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"> </span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"> </span><br><span class="line">TasksMax=infinity</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/cri-docker.socket</span><br><span class="line">[Unit]</span><br><span class="line">Description=CRI Docker Socket for the API</span><br><span class="line">PartOf=cri-docker.service</span><br><span class="line"> </span><br><span class="line">[Socket]</span><br><span class="line">ListenStream=%t/cri-dockerd.sock</span><br><span class="line">SocketMode=0660</span><br><span class="line">SocketUser=root</span><br><span class="line">SocketGroup=docker</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=sockets.target</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp /usr/lib/systemd/system/cri-docker.service /usr/lib/systemd/system/cri-docker.socket root@k8s-node1:/usr/lib/systemd/system/</span><br><span class="line"> </span><br><span class="line">scp /usr/lib/systemd/system/cri-docker.service /usr/lib/systemd/system/cri-docker.socket root@k8s-node2:/usr/lib/systemd/system/</span><br></pre></td></tr></table></figure><ul><li>启动cri-docker并设置开机自动启动</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload ; systemctl enable cri-docker --now</span><br><span class="line">#查看状态</span><br><span class="line">systemctl is-active cri-docker</span><br></pre></td></tr></table></figure><h3 id="2-3-所有节点安装-kubeadm，kubelet-和-kubectl">2.3 所有节点安装 kubeadm，kubelet 和 kubectl</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line">setenforce 0</span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure><ul><li>设置kubelet开机自启</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now kubelet.service</span><br></pre></td></tr></table></figure><h2 id="3-搭建k8s集群">3. 搭建k8s集群</h2><h3 id="3-1-k8s初始化">3.1 k8s初始化</h3><ul><li>在master上初始化k8s</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.183.132 \</span><br><span class="line">--image-repository=registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version=v1.28.2 \</span><br><span class="line">--service-cidr=10.96.0.0/12  \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">--cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure><ul><li>按照提示创建kubeconfig文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><ul><li>重新初始化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset --cri-socket /var/run/cri-dockerd.sock</span><br><span class="line"> </span><br><span class="line">rm -rf .kube/</span><br><span class="line">sudo mkdir ~/.kube</span><br><span class="line">sudo cp /etc/kubernetes/admin.conf ~/.kube/</span><br><span class="line">cd ~/.kube</span><br><span class="line">mv admin.conf config</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure><h3 id="3-2-node节点的加入">3.2 node节点的加入</h3><ul><li>加入节点</li></ul><p>在node节点如k8s-node1上执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join kubeadm初始化成功后的token --cri-socket /var/run/cri-dockerd.sock</span><br><span class="line">例如我的kubeadm初始化成功后的token为：</span><br><span class="line">192.168.183.132:6443 --token vib96t.hmkd7hj7ykdigmp1 --discovery-token-ca-cert-hash sha256:c0bb3a82a4642cc4fe253edd0533ad8136b34dc243f274aa3cea27abc46e321f</span><br></pre></td></tr></table></figure><ul><li>查看节点状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">此时所有节点的状态为NotReady，这是因为还没有安装flannel网络插件</span><br></pre></td></tr></table></figure><ul><li>网络插件下载并安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#如果网络故障也可直接在网站中下载好文件后上传至虚拟机中（自行翻墙）</span><br><span class="line">wget https://github.com/flannel-io/flannel/releases/download/v0.24.3/kube-flannel.yml</span><br><span class="line">#执行</span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br><span class="line">#或者（两者的结果是一样的，只是执行工作原理不一样，想深究的可以自行查阅资料）</span><br><span class="line">kubectl create -f kube-flannel.yml</span><br></pre></td></tr></table></figure><ul><li>再次查看节点状态全部变为 Ready</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line">#如果查看节点没有变成ready，先等个几分钟，因为网络传输需要一定的时间。等几分钟后如果还是NotReady，再根据报错原因查找解决方案</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;k8s集群搭建教程（使用cri-docker+flannel）&lt;/h1&gt;
&lt;h2 id=&quot;1-准备工作（所有节点）&quot;&gt;1. 准备工作（所有节点）&lt;/h2&gt;
&lt;h3 id=&quot;1-1-系统环境-我是没配置也部署成功了，可以先部署，如果失败了再回来进行系统环境优化&quot;&gt;1.1 系</summary>
      
    
    
    
    
    <category term="kubernetes" scheme="http://example.com/tags/kubernetes/"/>
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://example.com/2024/03/16/Java%E8%AF%AD%E8%A8%80/"/>
    <id>http://example.com/2024/03/16/Java%E8%AF%AD%E8%A8%80/</id>
    <published>2024-03-16T08:39:36.000Z</published>
    <updated>2024-05-09T05:38:40.346Z</updated>
    
    <content type="html"><![CDATA[<h1>Java语言</h1><h2 id="1-语言基础">1. 语言基础</h2><h3 id="1-1-基础语法">1.1 基础语法</h3><ul><li><strong>数据类型</strong></li></ul><p>数据类型分为两类：基本数据类型、引用数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java中的基本数据类型只有**四类八种**</span><br><span class="line"></span><br><span class="line">整数型：byte、short、int、long</span><br><span class="line"></span><br><span class="line">short占两字节</span><br><span class="line"></span><br><span class="line">int 占用四个字节</span><br><span class="line"></span><br><span class="line">long 占用八个字节</span><br></pre></td></tr></table></figure><ul><li>浮点型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浮点型有两种：float、double</span><br><span class="line">float占用四位，double占用八位</span><br></pre></td></tr></table></figure><ul><li>字符型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符型为char，char类型是一个单一的16位Unicode字符。</span><br></pre></td></tr></table></figure><ul><li>布尔型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its &quot;size&quot; isn&#x27;t something that&#x27;s precisely defined.</span><br><span class="line"> </span><br><span class="line">翻译：布尔数据类型只有两种可能的值：true和false。使用这个数据类型用于追踪true/false状况的简单标识。这个数据类型表示1bit的信息，但是它的”大小“没有被精确定义。</span><br></pre></td></tr></table></figure><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20231228151136962.2krqbfmbzc.jpg"  alt="image-20231228151136962"></p><ul><li>引用数据类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要不是基本数据类型就是引用数据类型。</span><br></pre></td></tr></table></figure><ul><li>自动类型转换（隐式）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换规则： 数据范围必须是**从小到大**，即由小的转换成大的，自动转换。</span><br></pre></td></tr></table></figure><ul><li>强制类型转换（显式）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意事项：</span><br><span class="line">1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。 </span><br><span class="line">2. byte/short/char这三种类型都可以发生数学运算，例如加法“+”。</span><br><span class="line">3. byte/short/char这三种类型在运算的时候都会首先提升成为int类型，然后再计算。</span><br><span class="line">例：byte+byte-&gt;int+int-&gt;int</span><br><span class="line">4. boolean类型不能发生数据类型转换</span><br></pre></td></tr></table></figure><ul><li>运算符的优先级</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单目（一元）&gt;算术运算符&gt;移位&gt;关系&gt;位&gt;条件(三元)&gt;赋值</span><br></pre></td></tr></table></figure><ul><li><strong>基础语法</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 大小写敏感： Java是大小写敏感的语言，例如Hello和hello是不同的，这其实就是Java的字符串表示方式。</span><br><span class="line">2. 类名：类名使用 UpperCamelCase 风格，但以下情形例外： DO / BO / DTO / VO / AO /</span><br><span class="line">PO / UID 等。</span><br><span class="line">正例： ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion</span><br><span class="line">反例： forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion</span><br><span class="line">3. 包名：包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用</span><br><span class="line">单数形式，但是类名如果有复数含义，类名可以使用复数形式。</span><br><span class="line">正例： 应用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils（此规则参考 spring 的框架结构）</span><br><span class="line">4. 方法名、变量名、参数名：都统一使用 lowerCamelCase 风格</span><br><span class="line">正例： localValue / getHttpMessage() / inputUserId</span><br></pre></td></tr></table></figure><ul><li><strong>方法</strong></li><li>构造方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">作用：用来创建对象的</span><br><span class="line">注意事项：</span><br><span class="line">1. 构造方法的名称必须和所在类的名称完全一样，就连大小写也要一样</span><br><span class="line">2. 构造方法不要写返回值类型，连void都不写</span><br><span class="line">3. 构造方法不能return一个具体的返回值</span><br><span class="line">4. 如果没有编写任何构造方法，那么编译器会默认分配一个构造方法</span><br><span class="line">5. 一旦编写了一个构造方法，那么编译器就不会再分配任何构造方法</span><br></pre></td></tr></table></figure><ul><li>静态方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态方法又叫类方法。</span><br></pre></td></tr></table></figure><ul><li>非静态方法（成员方法）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法之间的调用注意事项：</span><br><span class="line">1. 同类型的方法之间可以直接调用</span><br><span class="line">2. 静态方法调用非静态方法需要先new一个对象，然后通过对象进行调用。</span><br><span class="line">3. 非静态方法可以直接调用静态方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>方法重载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">多个方法的名称相同，但是参数列表不一样。</span><br><span class="line">方法重载与下列因素相关：</span><br><span class="line">1. 参数个数不同</span><br><span class="line">2. 参数类型不同</span><br><span class="line">3. 多参数类型顺序不同</span><br><span class="line">方法重载与下列因素无关：</span><br><span class="line">1. 与参数名称无关</span><br><span class="line">2. 与方法的返回值类型无关</span><br><span class="line">3. </span><br></pre></td></tr></table></figure><ul><li>参数传递机制</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java的参数传递机制都是：值传递</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>数组</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Java的内存划分成为5个部分：</span><br><span class="line">1. 栈内存（stack）：存放的都是方法中的局部变量。  方法的运行一定要在栈中运行。</span><br><span class="line">         局部变量： 方法的参数、方法&#123;&#125;内部的变量</span><br><span class="line">2. 堆内存（heap）: 凡是new出来的东西都在堆当中。</span><br><span class="line">        堆内存里面的东西都有一个地址值：16进制</span><br><span class="line">        堆内存中的数据都有默认值。规则：</span><br><span class="line">                 整数         默认0</span><br><span class="line">                 浮点数       默认0.0</span><br><span class="line">                 字符         默认&#x27;\u0000&#x27;</span><br><span class="line">                 布尔         默认false</span><br><span class="line">                 引用类型      默认null</span><br><span class="line">3. 方法区（）: 存储.class相关信息，包含方法的信息。</span><br><span class="line"></span><br><span class="line">4. 本地方法栈（）： 与操作系统相关</span><br><span class="line">5. 寄存器（）： 与cpu相关</span><br></pre></td></tr></table></figure><h3 id="1-2-面向对象">1.2 面向对象</h3><ul><li><strong>特点</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成指挥者。</span><br></pre></td></tr></table></figure><p><strong>面向对象语言包含三大基本特征：</strong></p><ul><li><p>封装</p><p>就是将一些细节信息隐藏起来，对外界不可见。</p><ol><li>方法就是一种封装</li><li>private关键字也是一种封装</li></ol><p>一旦使用private进行修饰，那么本类当中仍然可以随意访问，但是超出了本类范围之外就不能再直接访问了。</p><p>可以使用getter/setter方法间接访问private成员变量。</p></li><li><p>继承</p></li></ul><p>​        继承是多态的前提，如果没有继承，就没有多态。</p><p>​        继承主要解决的问题就是：<strong>共性抽取</strong></p><pre><code>  **变量重名的解决方法**</code></pre><p>​         局部变量：                    直接写成员变量名</p><p>​         本类的成员变量：          this.成员变量名</p><p>​          父类的成员变量：          super.成员变量名</p><pre><code> **重写（override）**    </code></pre><p>​         概念：在继承关系中，方法的名称一样，参数列表一样。</p><p>​         方法重写（override）：方法名称一样，参数列表也一样。（覆盖重写）</p><p>​         方法重载（overload）：方法名称一样，参数列表不一样。</p><pre><code> **覆盖重写的注意事项：**          1. 必须保证父子类之间的方法名称相同，参数列表也相同。          2. 子类方法的权限必须大于等于父类方法的权限修饰符。</code></pre><p>​         public&gt;protected&gt;(default)&gt;private</p><p>​         备注：（default）不是关键字default，而是什么修饰符也不用。</p><p>​<strong>继承关系中，父子类构造方法的访问特点：</strong></p><pre><code>1. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造</code></pre><p>​注意事项：</p><p>​子类必须调用父类构造方法，不写则默认super（），写了则用写的指定的super调用，super只能有一个，还必须是第一个。</p><p>​<strong>Java继承的三大特点</strong></p><ol><li>Java语言是单继承的，即一个类的直接父类只能有唯一一个。</li><li>Java语言可以多级继承。</li><li>一个子类只能有一个父类，但是一个父类可以有多个子类。</li></ol><p>如果父类当中的方法不确定如何进行{}方法体实现，那么这就应该是一个抽象方法。</p><p>抽象类：抽象方法所在的类必须是抽象类才行。在class之前写上abstract即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="comment">//这是一个抽象方法，代表吃东西，但是具体吃什么不确定。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何使用抽象类和抽象方法</strong></p><ol><li><p>不能直接创建new抽象类对象</p></li><li><p>必须用一个子类来继承抽象父类。</p></li><li><p>子类必须覆盖重写抽象父类当中的所有抽象方法。</p><p>覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号</p><ol start="4"><li>创建子类对象进行使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>多态</li></ul><p>一个对象拥有多种形态，这个就叫对象的多态性。</p><p><strong>代码当中体现多态性，其实就是一句话，父类引用指向子类对象。</strong></p><p>格式：</p><p>父类名称 对象名 = new 子类名称（）；</p><p>或者</p><p>接口名称 对象名 = new  实现类名称（）；</p><p>访问成员变量和方法的规则：</p><p>访问成员方法：等号右边new的谁，优先用谁，没有则向上找。</p><p>直接通过对象名称访问成员变量：等号左边是谁，优先用谁，没有则向上找。</p><p>间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。</p><p><strong>对象的转型</strong></p><ol><li>对象的向上转型，其实就是多态写法：</li></ol><p>格式：父类名称 对象名 = new 子类名称（）；</p><ol start="2"><li>对象的向下转型，其实是一个【还原】的动作</li></ol><p>格式：子类名称 对象名 = （子类名称） 父类对象</p><p>注意事项：</p><ol><li>必须保证对象本来创建的时候就是A,才能向下转型成为A。</li><li>如果创建的对象本来不是A，非要向下转型为A就会报错。</li></ol><p><strong>四种权限修饰符</strong></p><p><strong>内部类</strong></p><ol><li>成员内部类</li><li>局部内部类（包含匿名内部类）</li></ol><p>成员内部类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">      修饰符 class 内部类名称&#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">注意：内用外，随意访问； 外用内，需要内部类对象。</span><br></pre></td></tr></table></figure><p>局部内部类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">      修饰符 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">              class 局部内部类名称&#123;</span><br><span class="line">      </span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">接口名称 对象名称 =  <span class="keyword">new</span> 接口名称（）&#123;</span><br><span class="line"> 覆盖重写所有抽象方法</span><br><span class="line">&#125;；</span><br><span class="line">注意事项：</span><br><span class="line">    <span class="number">1.</span> 匿名内部类在创建对象的时候只能使用唯一一次</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li><strong>类和对象</strong></li></ul><p><strong>什么是类</strong></p><ul><li>类：是一组相关属性和行为的集合。</li></ul><p>现实中，描述一类事物：</p><ul><li><p>属性：就是该事物的特征信息。（是什么）（成员变量）</p></li><li><p>行为：就是该事物能够做什么。（成员方法）成员方法不要写static关键字。</p></li></ul><p><strong>什么是对象</strong></p><ul><li>对象：是一类事物的具体体香。对象是类的一个实例。</li></ul><p><strong>类与对象的关系</strong></p><ul><li>类是对一类事物的描述，是抽象的。</li><li>对象是一类事物的实例，是具体的。</li><li>类是对象的模板，对象是类的实体。</li></ul><p><strong>成员变量和局部变量的区别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. 定义的位置不一样</span><br><span class="line">局部变量：在方法的内部</span><br><span class="line">成员变量：在方法的外部，直接写在类当中。</span><br><span class="line"></span><br><span class="line">2. 作用范围不一样</span><br><span class="line">局部变量：只有方法当中才可以使用</span><br><span class="line">成员变量：整个类全可以通用</span><br><span class="line"></span><br><span class="line">3. 默认值不一样</span><br><span class="line">局部变量：没有默认值，如果要想使用，必须手动赋值</span><br><span class="line">成员变量：如果没有赋值，会有默认值，规则和数组一样。</span><br><span class="line"></span><br><span class="line">4. 内存的位置不一样</span><br><span class="line">局部变量：位于栈内存</span><br><span class="line">成员变量：位于堆内存</span><br><span class="line"></span><br><span class="line">5. 生命周期不一样</span><br><span class="line">局部变量：随着方法进栈而生，随着方法出栈而亡</span><br><span class="line">成员变量：随着对象创建而生，随着对象被垃圾回收而亡。</span><br></pre></td></tr></table></figure><ul><li><strong>对象数组</strong></li></ul><p>数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变。</p><ul><li><strong>字符串</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 字符串的内容不可变</span><br><span class="line">2. 字符串可以共享使用</span><br><span class="line">3. 字符串效果上相当于char[]字符数组，但是底层原理是byte[]字节数组</span><br><span class="line">在堆内存中有一个字符串常量池。</span><br><span class="line">常用方法：</span><br><span class="line">equals</span><br><span class="line">length()</span><br><span class="line">concat:连接字符串</span><br><span class="line">charAt:</span><br><span class="line">indexOf:</span><br></pre></td></tr></table></figure><p>StringBuilder类：字符串缓冲区，可以提高字符串的效率</p><p>常用方法：</p><p>append</p><p>toString</p><ul><li><strong>静态关键字static</strong></li></ul><p>一旦用了static关键字，那么这样的内容不再属于对象自己，</p><p>而是属于类的，所以凡是本类的对象，都共享同一份。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一旦使用static修饰成员方法，那么就成为了静态方法，静态方法不属于对象，而是属于类的。</span><br><span class="line"></span><br><span class="line">如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。</span><br><span class="line"></span><br><span class="line">如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。</span><br><span class="line"></span><br><span class="line">无论是成员变量还是方法，如果有了static，都推荐使用类名称进行调用。</span><br><span class="line"></span><br><span class="line">静态变量：类名称.静态变量</span><br><span class="line"></span><br><span class="line">静态方法：类名称.静态方法（）</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line">1. 静态方法当中不能使用this</span><br></pre></td></tr></table></figure><p><strong>静态代码块</strong></p><p>特点：当第一次用到本类时，静态代码块执行唯一的一次。</p><p>静态内容总是优先于非静态，所以静态代码块比构造方法先执行。</p><p>静态代码块的用途：</p><p>用来一次性的对静态成员变量进行赋值。</p><p><strong>Arrays工具类</strong></p><p>toString(数组)：将参数数组变成字符串（按照默认格式：[元素1，元素2,…]）</p><h3 id="1-3-接口">1.3 接口</h3><p>接口就是多个类的公共规范</p><p>接口是一种引用数据类型，最重要的内容就是其中的：<strong>抽象方法</strong>。</p><p>从Java 8开始，接口 里允许定义默认方法。</p><p>备注：接口当中的默认方法可以解决接口升级的问题。</p><p><strong>什么是接口升级？</strong></p><p>就是已经投入使用的接口，想在其中添加新的方法，这时如果直接添加，会导致所有实现该接口的类报错，但是使用default默认方法可以解决此问题，并且该方法也可以被其他接口实现类覆盖重写。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Java 9 开始，接口中允许定义私有方法。</p><ol><li>普通私有方法，解决多个默认方法之间的重复代码问题</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>静态私有方法：解决多个静态方法之间重复代码问题</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line"></span><br><span class="line">方法体</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口与接口之间是多继承的。</p><ul><li><strong>日期时间类</strong></li></ul><p>date</p><ul><li><strong>DateFormat类</strong></li></ul><p>日期时间格式化类</p><ul><li><strong>包装类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基本类型             对应的包装类</span><br><span class="line"><span class="type">byte</span>                  Byte</span><br><span class="line"><span class="type">short</span>                 Short</span><br><span class="line"><span class="type">int</span>                   Integer</span><br><span class="line"><span class="type">long</span>                  Long</span><br><span class="line"><span class="type">float</span>                 Float</span><br><span class="line"><span class="type">double</span>                Double</span><br><span class="line"><span class="type">char</span>                  Character</span><br><span class="line"><span class="type">boolean</span>               Boolean</span><br></pre></td></tr></table></figure><p><strong>装箱与拆箱</strong></p><p>装箱：从基本类型转换成对应的包装类对象</p><p>拆箱：从包装类对象转换为对应的基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i= Integer.valueOf(<span class="number">4</span>)<span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i.intValue();<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><h3 id="1-4-容器">1.4 容器</h3><ul><li>collection集合</li></ul><p>**集合：**集合是Java中提供的一种容器，可以用来存储多个数据。</p><p>集合和数组既然都是容器，它们有啥区别？</p><ol><li>数组的长度是固定的，集合的长度是可变的</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象，而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ol><p><strong>常用共性方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>: 添加对象</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>: 清空集合</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E e)</span>: 把给定对象从当前集合删除</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span>: 判断当前集合中是否包含给定的对象</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>:</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>: 返回集合中的元素个数</span><br><span class="line"><span class="keyword">public</span> Object[] toArray(): 把集合中的元素，存储到数组中</span><br></pre></td></tr></table></figure><p><strong>List</strong></p><ol><li>有序的集合（存储和取出元素顺序相同）</li><li>允许存储重复的元素</li><li>有索引，可以使用普通的for循环遍历</li></ol><ul><li>ArrayList（查询快，增删慢）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>常用方法：</p><p>add,get,remove,size</p><ul><li>LinkedList（查询慢，增删快）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;E&gt; linked = <span class="keyword">new</span> <span class="title class_">LinkerdList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>Set</strong></p><ol><li>不允许存储重复的元素</li><li>没有索引</li></ol><ul><li>HashSet</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;E&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><ol><li>是一个无序集合</li><li>底层是一个哈希表结构</li></ol><p>哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑i地址，是模拟出来的地址，不是数据实际存储的物理地址）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>:获取对象的哈希码值</span><br></pre></td></tr></table></figure><p>哈希表（查询快）</p><p>哈希表的结构，jdk1.8之后：</p><ol><li>哈希表=数组+链表；</li><li>哈希表=数组+红黑树；</li></ol><ul><li>LInkedHashSet</li></ul><p>LInkedHashSet特点：</p><p>底层是一个哈希表+链表，多了一条链表（记录元素的存储顺序），保证元素有序。</p><p><strong>HashSet存储自定义类型元素</strong></p><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。</p><p><strong>可变参数</strong></p><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（数据类型...变量名）&#123;</span><br><span class="line">&#125;</span><br><span class="line">实例</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>... arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">注意事项</span><br><span class="line">    <span class="number">1.</span> 一个方法的参数列表只能有一个可变参数</span><br><span class="line">    <span class="number">2.</span> 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾。</span><br><span class="line">可变参数的特殊（终极）写法</span><br><span class="line">    实例</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Object...obj)</span>&#123;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Map</strong></p><p>特点</p><ol><li>map集合是一个双列集合，一个元素包含两个值（key:value）</li><li>map集合中的元素，key和value的数据类型可以相同，也可以不同</li><li>map中key是不允许重复的，value可以重复</li><li>map中的key和value一一对应</li></ol><ul><li>HashMap（初始长度16）</li></ul><p>特点：</p><ol><li>HashMap集合底层是哈希表：查询速度特别快</li><li>hashMap是一个无序集合，存储和取出元素的顺序可能不一致</li></ol><ul><li>LinkedHashMap</li></ul><p>特点：</p><ol><li>底层是哈希表+链表（保证迭代的顺序）</li><li>是一个有序的集合，存储和取出元素的顺序是一致的</li></ol><ul><li>TreeMap</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>Collections工具类</p><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? <span class="built_in">super</span> T&gt; c, T... elements)</span> ：往集合中添加一些元素</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span> ：打乱集合顺序</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line">：将集合按照默认规则排序</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span>：将集合中元素按照指定规则排序</span><br></pre></td></tr></table></figure><h4 id="1-4-1-Iterator迭代器">1.4.1 Iterator迭代器</h4><p>迭代：Collection集合元素的通用获取方式。</p><p>迭代器的使用案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       coll.add(<span class="string">&quot;姚明&quot;</span>);</span><br><span class="line">       coll.add(<span class="string">&quot;科比&quot;</span>);</span><br><span class="line">       coll.add(<span class="string">&quot;詹姆斯&quot;</span>);</span><br><span class="line">       coll.add(<span class="string">&quot;库里&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取一个迭代器对象</span></span><br><span class="line">       Iterator&lt;String&gt; iterator = coll.iterator();</span><br><span class="line">       <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-异常">1.5 异常</h3><p><strong>异常</strong>：指的是程序在执行过程中，出现非正常的情况，最终导致JVM非正常停止。</p><p>Java处理异常的方式是中断处理。</p><p><strong>异常产生的过程解析</strong></p><h4 id="1-5-1-异常的处理">1.5.1 异常的处理</h4><p>Java异常处理的五个关键字：try、catch、finally、throw、throws</p><ol><li>抛出异常throw</li></ol><p>throw作用：</p><p>可以使用throw关键字在指定的方法中抛出指定的异常</p><p>使用格式：</p><p>throw new xxxException（“异常产生的原因”）;</p><p>注意：</p><ol><li>throw关键字必须写在方法的内部</li><li>throw后面new的对象必须是Exception或者Exception的子类对象</li><li>throw抛出指定的异常对象，我们必须处理这个异常对象，要么用throws，要么try…catch</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以后（工作中）我们首先必须对方法传递过来的参数进行合法性校验</span><br><span class="line"></span><br><span class="line">如果参数不合法，那么我们就必须使用抛出异常的方式，告知方法的调用者，传递的参数有问题。</span><br></pre></td></tr></table></figure><ol start="2"><li>声明异常throws（异常处理的第一种方式）</li></ol><p>作用：</p><p>当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象</p><p>可以使用throws处理异常对象，把异常声明抛出给方法的调用者处理（自己不处理，谁调用我让谁处理），最终交给jvm处理–&gt;中断异常</p><p>使用格式：在方法声明时使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数列表） <span class="keyword">throws</span> xxxException,.....&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">xxxException</span>(<span class="string">&quot;产生原因&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">注意</span><br><span class="line">    <span class="number">1.</span> <span class="keyword">throws</span> 必须写在方法声明处</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">throws</span> 后边声明的异常必须是Exception或者其子类</span><br><span class="line">    <span class="number">3.</span> 方法内部如果抛出多个异常，那么<span class="keyword">throws</span>后边也必须声明多个异常</span><br><span class="line">        如果多个异常之间有子父类关系，直接声明父类异常就行</span><br><span class="line">    <span class="number">4.</span> 调用了一个声明抛出异常的方法，我们就必须处理声明的异常</span><br><span class="line">        要么继续使用 <span class="keyword">throws</span> 声明抛出，交给方法的调用者处理，最终交给 JVM</span><br><span class="line">        要么 <span class="keyword">try</span>....<span class="keyword">catch</span> 自己处理。</span><br></pre></td></tr></table></figure><ol start="3"><li>捕获异常try…catch（异常处理的第二种方式）</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>(xxxException e)&#123; <span class="comment">//try中抛出什么异常，catch就定义什么异常对象，用来接收这个异常。</span></span><br><span class="line">    一般在工作中，会把异常的信息记录在一个日志中。</span><br><span class="line">&#125;</span><br><span class="line">注意</span><br><span class="line">    <span class="number">1.</span> <span class="keyword">try</span> 可能会抛出多个异常，那么可以使用多个 <span class="keyword">catch</span> 来处理</span><br><span class="line">    <span class="number">2.</span> 如果 <span class="keyword">try</span> 中产生了异常，就会执行 <span class="keyword">catch</span> 中的异常处理逻辑，执行完后，继续执行 <span class="keyword">try</span>...<span class="keyword">catch</span> 后的代码。</span><br><span class="line">    <span class="number">3.</span> 如果 <span class="keyword">try</span> 中没有异常，就不执行 <span class="keyword">catch</span> ，执行完 <span class="keyword">try</span> 后，继续执行 <span class="keyword">try</span>...<span class="keyword">catch</span> 后的代码。</span><br></pre></td></tr></table></figure><h3 id="1-6-泛型">1.6 泛型</h3><p>泛型是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型。</p><p><strong>泛型的数据类型在创建对象的时候确定</strong></p><p>创建集合对象，使用泛型</p><p>好处：</p><ol><li>避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型</li><li>把运行期异常（代码运行之后抛出的异常）提升到了编译期</li></ol><p>弊端：</p><ol><li>泛型是什么类型，只能存储什么类型的数据</li></ol><p><strong>含有泛型的方法</strong></p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表（使用泛型）)&#123;</span><br><span class="line">        方法体;</span><br><span class="line">    &#125;</span><br><span class="line">实例</span><br><span class="line"> <span class="keyword">public</span> &lt;H&gt; <span class="keyword">void</span> <span class="title function_">genericMethod</span><span class="params">(H h)</span>&#123;</span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>含有泛型的接口</strong></p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">第一种使用方式，定义接口的实现类，实现接口并指定接口的泛型</span><br><span class="line">实例</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Scanner</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">第二种使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt;&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;   </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>泛型通配符</p><p>​？：代表任意的数据类型</p><p>使用方式：</p><p>​不能创建对象使用</p><p>​  只能作为方法的参数使用</p><p><strong>高级使用-受限泛型（要求只要看源码能看懂就行）</strong></p><p>作用：限定数据的使用类型。</p><p>泛型的上限限定：？extends E 代表使用的泛型只能是E类型的子类/本身</p><p>泛型的下限限定：？super E 代表使用的泛型只能是E类型的父类/本身</p><ul><li><strong>数据结构</strong></li></ul><p><strong>红黑树</strong></p><p>特点：</p><ol><li>趋近于平衡树，查询的速度非常快，查询叶子节点最大次数和最小次数不能超过2倍</li></ol><p>约束：</p><ol><li>节点可以是红色或者黑色</li><li>根节点是黑色</li><li>叶子节点（空节点）是黑色</li><li>每个红色的节点的子节点都是黑色</li><li>任何一个节点到其每一个叶子节点所有路径上的黑色节点数相等</li></ol><h3 id="1-7-反射">1.7 反射</h3><p><strong>作用</strong></p><ol><li>基本作用：可以得到一个类的全部成分然后操作</li><li>可以破坏封装性</li><li>最重要的用途是：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。</li></ol><h3 id="1-8-注解">1.8 注解</h3><p>就是Java的特殊标记，作用是：让其他程序根据注解信息来决定怎么执行该程序</p><p><strong>特殊属性名：value</strong></p><p>如果注解只有一个value属性，使用注解时，value名称可以不写。</p><p><strong>元注解</strong></p><p>修饰注解的注解</p><p>常见的元注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="meta">@Target</span></span><br><span class="line">    作用：声明被修饰的注解只能在哪些位置使用</span><br><span class="line">    @<span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line">    <span class="number">1.</span> TYPE,类，接口</span><br><span class="line">    <span class="number">2.</span> FIELD， 成员变量</span><br><span class="line">    <span class="number">3.</span> METHOD，成员方法</span><br><span class="line">    .....</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> <span class="meta">@Retention</span></span><br><span class="line">    作用：声明注解的保留周期</span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="number">1.</span> SOURCE</span><br><span class="line">    只作用在源码阶段，字节码文件中不存在</span><br><span class="line">    <span class="number">3.</span>RUNTIME（开发常用）</span><br><span class="line">    一直保留到运行阶段</span><br></pre></td></tr></table></figure><p><strong>注解的解析</strong></p><p>要解析谁上面的注解，就先拿到谁</p><h3 id="1-9-I-O">1.9 I/O</h3><p>重点：记住三个单词</p><p>​          file： 文件</p><p>​          directory：文件夹/目录</p><p>​          path： 路径</p><p><strong>递归</strong>：指在当前方法内部调用自己的这种现象</p><p>递归的分类：</p><ol><li>直接递归</li></ol><p>​        方法自身调用自身</p><ol start="2"><li>间接递归</li></ol><p>​A方法调用B方法，B方法调用C方法，C方法调用A方法。</p><p><strong>Java中的I/O操作主要是指使用Java.io包下的内容，进行输入、输出操作。</strong></p><ol><li>字节流（InputStream/OutputStream）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream </span><br><span class="line">    文件字节输入流</span><br><span class="line">    作用：把硬盘文件中的数据，读取到内存中使用</span><br><span class="line">FileOutputStream</span><br><span class="line">    文件字节输出流</span><br><span class="line">    作用：把内存中的数据写入到硬盘的文件中</span><br></pre></td></tr></table></figure><p>使用字节流读取中文文件容易产生乱码</p><p>一个中文</p><p>​GBK： 占用两个字节</p><pre><code>UTF-8：占用三个字节</code></pre><ol start="2"><li>字符流（reader/writer）</li></ol><p>作用：读取字符信息，一次读取一个字符</p><p>jdk7的新特性</p><p>在try后边可以增加一个()，在括号中可以定义流对象</p><p>那么这个流对象的作用域就在try中有效</p><p>try中的代码执行完毕会自动把流对象释放，不用写finally</p><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(定义流对象；定义流对象...)&#123;</span><br><span class="line">    可能会产生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类变量 变量名)&#123;</span><br><span class="line">    异常的处理逻辑</span><br><span class="line">&#125;</span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoll</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(<span class="comment">//创建一个字符输出流对象，构造方法绑定需要写入的目的地</span></span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="literal">true</span>);) &#123;</span><br><span class="line"><span class="comment">//            //创建一个字符输入流对象，构造方法绑定需要读取的数据源</span></span><br><span class="line"><span class="comment">//            FileReader fr = new FileReader(&quot;test.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                fw.append(<span class="string">&quot;helloword&quot;</span>+i+<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>缓冲流</li></ol><p>作用：提高文件读写的效率</p><p>字节缓冲流（BufferedInputStream &amp; BufferedOutputStream）</p><p>字符缓冲流（BufferedReader &amp; BufferWriter）</p><ol start="4"><li>转换流(OutputStreamWriter &amp; InputStreamReader)</li></ol><p>作用：能够转换编码</p><ol start="5"><li>序列化流(ObjectOutputStream &amp; ObjectInputStream )</li></ol><p>作用：能够持久化存储对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Serializable 接口也叫标记型接口</span><br><span class="line">    要进行序列化和反序列化的类必须实现 Serializable 接口，就会给类添加一个标记</span><br><span class="line">    当我们进行序列化和反序列化的时候，就会检测是否有这个标记</span><br><span class="line">    有：就可以序列化和反系列化</span><br><span class="line">    没有：就会抛出 NotSerializableException 异常</span><br><span class="line"> <span class="keyword">transient</span>关键字：瞬态关键字</span><br><span class="line">    被 <span class="keyword">transient</span> 修饰的成员变量，不能被序列化</span><br><span class="line">问题：</span><br><span class="line">    每次修改类的定义，都会给class文件生成一个新的序列号，这样在进行序列化与反序列化时就会报invalidClassException异常</span><br><span class="line">解决方法：</span><br><span class="line">    无论是否对类的定义进行修改，都不重新生成新的序列号</span><br><span class="line">    可以手动给类添加一个序列号</span><br><span class="line">  格式：</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6161825669842708241L</span>;</span><br><span class="line">等号后面的常量可以为任意值，不可改变。</span><br></pre></td></tr></table></figure><p>序列化集合</p><p>当我们想在文件中保存多个对象的时候，可以把多个对象存储到一个集合中，然后对集合进行序列化和反序列化。</p><h2 id="2-JVM">2. JVM</h2><h3 id="2-1-类加载机制">2.1 类加载机制</h3><h3 id="2-2-字节码执行机制">2.2 字节码执行机制</h3><h3 id="2-3-jvm内存模型">2.3 jvm内存模型</h3><h3 id="2-4-gc垃圾回收机制">2.4 gc垃圾回收机制</h3><h3 id="2-5-jvm性能监控和故障定位">2.5 jvm性能监控和故障定位</h3><h3 id="2-6-jvm调优">2.6 jvm调优</h3><h2 id="3-并发-多线程">3. 并发/多线程</h2><h3 id="3-1-并发编程">3.1 并发编程</h3><h3 id="3-2-多线程">3.2 多线程</h3><p>创建线程的步骤：</p><ol><li>声明Thread类的子类</li><li>重写Thread类的run方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置线程任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">创建线程的第二种方式</span><br><span class="line">    <span class="number">1.</span> 创建一个runnable接口的实现类</span><br><span class="line">    <span class="number">2.</span> 在实现类中重写runnable接口的run方法，设置线程任务 </span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableThreadImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置线程任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableThreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多态写法</span></span><br><span class="line">        <span class="comment">//Runnable runnable= new MyRunnableThreadImpl();</span></span><br><span class="line">        MyRunnableThreadImpl runnable= <span class="keyword">new</span> <span class="title class_">MyRunnableThreadImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">使用runnable接口创建多线程的好处：</span><br><span class="line">    <span class="number">1.</span> 避免了单继承的局限性</span><br><span class="line">    <span class="number">2.</span> 增强了程序的扩展性，降低了程序的耦合性（解耦）</span><br></pre></td></tr></table></figure><p><strong>Thread类中的常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span>：获取；当前线程名</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> ：此线程开始执行，Java虚拟机调用此线程的run方法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span>:使当前线程暂停指定多长时间</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>：线程要执行的任务都在此处编写</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>：返回当前正在执行的线程对象的引用</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p><strong>并发与并行</strong></p><p>并发：指两个或多个事件在同一时间段内发生</p><p>并行：指两个或多个事件在同一时刻发生（同时发生）</p><p><strong>线程与进程</strong></p><p>进程： 是指一个内存中运行的应用程序</p><p>线程： 是指进程中的一个执行单元，负责当前进程中程序的执行，一个进程至少有一个线程。一个进程中是可以有多个线程的，这个应用程序称为<strong>多线程程序</strong>。</p><p><strong>线程调度</strong></p><p>分时调度： 所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。</p><p>抢占式调度： 优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java使用的为抢占式调度。</p><h4 id="3-2-1-线程安全">3.2.1 线程安全</h4><p><strong>解决线程安全问题</strong></p><ol><li>同步代码块: synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</li></ol><p>使用synchronized关键字容易产生死锁（如何解决，在后续内容中写）</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>（同步锁（锁对象））&#123;</span><br><span class="line">    <span class="comment">//需要同步操作的代码即：可能出现线程安全问题的代码（访问了共享数据的代码）</span></span><br><span class="line">&#125;</span><br><span class="line">同步锁（锁对象）注意事项：</span><br><span class="line">    <span class="number">1.</span> 同步代码块中的锁对象，可以使用任意的对象</span><br><span class="line">    <span class="number">2.</span> 必须保证多个线程使用的锁对象是同一个</span><br><span class="line">    <span class="number">3.</span> 锁对象作用：</span><br><span class="line">             把同步代码块锁住，只让一个线程在同步代码块中执行</span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableThreadImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//同步锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>同步方法</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 参数名（参数列表）&#123;</span><br><span class="line">    <span class="comment">//需要同步操作的代码即：可能出现线程安全问题的代码（访问了共享数据的代码）</span></span><br><span class="line">&#125;</span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableThreadImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                payTicket();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//同步方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">payTicket</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">**静态同步方法**</span><br><span class="line"></span><br><span class="line">锁对象是谁？</span><br><span class="line"></span><br><span class="line">不能是<span class="built_in">this</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>是创建对象之后产生的，静态方法优先于对象</span><br><span class="line"></span><br><span class="line">静态方法的锁对象是本类的class属性--&gt;class文件对象(反射)</span><br></pre></td></tr></table></figure><ol start="3"><li>Lock锁</li></ol><p>Lock接口中的方法：</p><p>void lock() 获取锁</p><p>void unlock() 释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            l.lock();</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    l.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-线程池">3.3 线程池</h3><p>线程池： 其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作。</p><h3 id="3-4-锁">3.4 锁</h3><h3 id="3-5-并发容器">3.5 并发容器</h3><h3 id="3-6-原子类">3.6 原子类</h3><h3 id="3-7-juc并发工具类">3.7 juc并发工具类</h3><h2 id="4-网络编程">4. 网络编程</h2><p>软件结构：c/s，b/s</p><h3 id="4-1-网络通信">4.1 网络通信</h3><p><strong>网络通信协议的分类</strong></p><ol><li>UDP：用户数据报协议</li></ol><p>特点：消耗资源小，通信效率高</p><p>通常用于音频、视频和普通数据的传输例如视频会议都使用udp协议，即使丢一两个数据包，也不会对接受结果产生太大影响。</p><ol start="2"><li>TCP：传输控制协议</li></ol><p>是面向连接的通信协议。在TCP连接中必须要明确客户端与服务器端，每次连接的创建都需要经过“三次握手”。</p><p>特点：传输安全</p><p>网络编程的三要素</p><ol><li>协议</li><li>IP地址</li></ol><ul><li>IPv4：32位的二进制数，通常被分为4个字节，表示a.b.c.d的形式，每个字节的范围都是0~255.</li><li>IPv6：</li></ul><ol start="3"><li>端口号</li></ol><h3 id="4-2-函数式接口">4.2 函数式接口</h3><p>函数式接口：只有一个抽象方法的接口，称之为函数式接口</p><p>当然接口中可以包含其他的方法（默认，静态，私有）</p><p><strong>Lambda表达式</strong></p><p>函数式编程思想：</p><p>​只要能获取到结果，谁去做，怎么做的都不重要，重视的是结果，不重视过程。</p><p>使用前提</p><ol><li>使用Lambda必须具有接口，且要求接口中有且只有一个抽象方法。</li><li>使用Lambda必须具有上下文推断</li></ol><p>有些场景的代码执行后结果不一定被使用，从而造成<strong>性能浪费</strong>。而Lambda表达式是延迟执行的，正好可以作为解决方案，提升性能。</p><p><strong>常用函数式接口</strong></p><ol><li>Supplier接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Supplier:被称为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个方法，用于获取int类型数组中元素的最大值，</span></span><br><span class="line"><span class="comment">     * 方法的参数传递Supplier接口，泛型使用Integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sup</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">100</span>,<span class="number">0</span>,-<span class="number">50</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> max= getMax(()-&gt;&#123;</span><br><span class="line">           <span class="type">int</span> temp= arr[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (temp&lt;arr[i])&#123;</span><br><span class="line">                   temp=arr[i];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Consumer接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Consumer:消费型接口，泛型执行什么类型，就可以使用accept方法使用什么类型的数据</span><br><span class="line">至于怎么消费（使用），需要自定义（输出，计算）</span><br><span class="line">默认方法：andThen</span><br><span class="line">作用：将两个Consumer接口连接到一起，然后再对数据进行消费（使用）</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String[] arr, Consumer&lt;String&gt; con1,Consumer&lt;String&gt; con2)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            con1.andThen(con2).accept(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr =  &#123;<span class="string">&quot;迪丽热巴，女&quot;</span>,<span class="string">&quot;古力娜扎，女&quot;</span>,<span class="string">&quot;沈腾，男&quot;</span>&#125;;</span><br><span class="line">        printMessage(arr,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;姓名：&quot;</span>+s.split(<span class="string">&quot;，&quot;</span>)[<span class="number">0</span>]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;性别：&quot;</span>+s.split(<span class="string">&quot;，&quot;</span>)[<span class="number">1</span>]+<span class="string">&quot;。&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ol start="3"><li>Predicate接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">对某种类型的数据进行判断，从而得到一个Boolean值结果。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoPredicate</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个方法，方法的参数传递一个字符串</span></span><br><span class="line"><span class="comment">     * 传递两个Predicate接口</span></span><br><span class="line"><span class="comment">     * 一个用于判断字符串的长度大于5</span></span><br><span class="line"><span class="comment">     * 一个用于判断字符串中是否包含a</span></span><br><span class="line"><span class="comment">     * 两个条件必须同时满足</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span>&#123;</span><br><span class="line">          <span class="comment">// return pre1.test(s) &amp;&amp; pre2.test(s);</span></span><br><span class="line">        <span class="comment">//return pre1.test(s) || pre2.test(s);</span></span><br><span class="line"><span class="comment">//        return pre1.or(pre2).test(s);</span></span><br><span class="line">          <span class="keyword">return</span> pre1.and(pre2).test(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;Hello world!!&quot;</span>;</span><br><span class="line">       <span class="type">boolean</span> b= checkString(test,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> s.length()&gt;<span class="number">5</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> s.contains(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-Stream流">4.3 Stream流</h3><p>IO流和Stream流是两个概念，IO流是用于数据的读写，而Stream流可以用来对集合和数组进行简化操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java语言&lt;/h1&gt;
&lt;h2 id=&quot;1-语言基础&quot;&gt;1. 语言基础&lt;/h2&gt;
&lt;h3 id=&quot;1-1-基础语法&quot;&gt;1.1 基础语法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据类型分为两类：基本数据类型、引用</summary>
      
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>个人博客搭建笔记</title>
    <link href="http://example.com/2023/12/24/my_blog_build_note/"/>
    <id>http://example.com/2023/12/24/my_blog_build_note/</id>
    <published>2023-12-24T11:50:36.000Z</published>
    <updated>2024-05-07T09:03:55.335Z</updated>
    
    <content type="html"><![CDATA[<h1>个人博客搭建笔记</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</span><br></pre></td></tr></table></figure><h2 id="一、环境准备">一、环境准备</h2><h3 id="1-安装node-js">1. 安装node.js</h3><p><a class="link"   href="https://blog.csdn.net/fenijd/article/details/135206205" >node.js的安装与配置教程-CSDN博客<i class="fas fa-external-link-alt"></i></a></p><h3 id="2-安装git">2. 安装git</h3><p><a class="link"   href="https://blog.csdn.net/fenijd/article/details/135226795" >Git 2.43.0的安装教程-CSDN博客<i class="fas fa-external-link-alt"></i></a></p><h2 id="二、搭建博客">二、搭建博客</h2><ol><li>以管理员的身份运行cmd输入命令下载hexo框架</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>出现下图所示样式表示下载成功，因为我已经下载过了，所以没有什么变化。图中的警告先不用管，不影响使用。警告的大致意思是fsevents不支持windows平台。因为它是适用于苹果系统的，但是我们下载框架的时候是全都下载的，所以会出现这个警告。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227150126542.widbihaic.jpg"  alt="image-20231227150126542"></p><p>在自己想要存放博客的文件夹下新建一个文件，名字自拟。从本文件夹直接进入cmd，或者先进入cmd，cd该文件夹下。输入命令初始化一个博客。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>初始化中断，根据提示可以看到是在安装依赖时出了问题。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227151412779.6pnbkt4qr9.jpg"  alt="image-20231227151412779"></p><p>原因是因为国内现在无法百分百概率访问Github，因此npm可能会下载失败；也有可能是因为文件权限的问题。总之按照提示再重新操作一遍以管理员的身份运行cmd并进入新建的博客文件夹下，使用hexo init命令后居然成功了。如下图所示，出现 Start blogging with Hexo 字样代表成功。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227155115602.9nzlobd088.jpg"  alt="image-20231227155115602"></p><p>初始化完成后使用命令就可以访问自己的博客了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>按住ctrl键鼠标左键点击即可跳转到博客网页。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227162536967.2doid9lf8s.jpg"  alt="image-20231227162536967"></p><p>博客网站如下图所示，默认会新建一篇文章。至此，博客的搭建工作告一段落。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227162048417.1lbmvj4tij.jpg"  alt="image20231227162048417"></p><h2 id="三、将博客部署到Github上">三、将博客部署到Github上</h2><p>使用命令安装一键将博客推送至GitHub上的插件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>使用管理员的身份运行cmd输入命令后安装成功。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227163832468.widbihai5.jpg"  alt="image-20231227163832468"></p><p>在Github上创建一个个人仓库用于存放博客，首先登录GitHub，在个人仓库中找到新建仓库点击进入。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227164915105.2yy5zkfvji.jpg"  alt="image-20231227164915105"></p><p><a class="link"   href="http://xn--GitHub-vy7ix4bc60aha959yqwbp5vuz0e7ie5n9c.github.io" >仓库名为自己的GitHub用户名.github.io<i class="fas fa-external-link-alt"></i></a>，如图所示，一定要这样设置，不然会不起作用。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227165146140.6m3pn3bo1b.jpg"  alt="image-20231227165146140"></p><p>描述根据自己需要填写，然后点击创建仓库。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227165414068.39kzspv3ow.jpg"  alt="image-20231227165414068"></p><p>创建完成后会自动跳转到你刚才创建的仓库内，在仓库中找到如下图所示位置，点击复制，后面修改博客的配置文件时会用到。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227165755277.7p3rhtrht.jpg"  alt="image-20231227165755277"></p><p>使用vscode或者记事本打开_config.yml找到deploy修改其中的内容为，保存并退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  repo: <span class="string">&#x27;https://github.com/dettry/dettry.github.io.git&#x27;</span> #为你创建的GitHub个人仓库地址</span><br><span class="line">  branch: <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure><p>进入cmd中cd到博客存放的路径下执行如下命令就可以将博客部署到GitHub上了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>记得在推送之前先开启梯子，然后将代理服务器打开。</p><p>首先右键网络选择网络和Internet设置。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227175624944.5xag32o50z.jpg"  alt="image-20231227175624944"></p><p>找到使用代理服务器，点击编辑将代理服务器打开然后保存。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227175530411.7i072jlche.jpg"  alt="image-20231227175530411"></p><p>最后推送成功后在地址栏输入dettry.github.io即可访问自己的博客。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;个人博客搭建笔记&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Linux笔记</title>
    <link href="http://example.com/2023/05/05/Linux%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/05/05/Linux%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-05T06:12:45.000Z</published>
    <updated>2024-05-09T07:19:19.887Z</updated>
    
    <content type="html"><![CDATA[<h1>Linux笔记</h1><h2 id="1-目录结构">1. 目录结构</h2><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20230401113335627.8kzwg6uwmd.jpg"  alt="image-20230401113335627"></p><h2 id="2-常用命令">2. 常用命令</h2><h3 id="2-1-ls">2.1 ls</h3><p>对应英文：list</p><p>作用： 查看当前目录下的内容</p><p>ll 对应 ls -l</p><p>作用： 查看当前目录下的所有内容和每个文件的详细信息。</p><h3 id="2-2-pwd">2.2 pwd</h3><p>对应英文：print work directory</p><p>作用： 查看当前所在目录</p><h3 id="2-3-touch">2.3 touch</h3><p>touch [文件名]</p><p>作用：如果文件不存在，新建文件</p><h3 id="2-4-cd">2.4 cd</h3><p>~表示当前用户的home目录</p><p>.表示当前所在目录</p><p>…表示当前目录位置的上级目录</p><h3 id="2-5-cat">2.5 cat</h3><p>cat [-n] fileName</p><p>-n: 由1开始对所有输出的行数编号</p><p>cat /etc/profile   查看/etc目录下的profile文件内容</p><h3 id="2-6-rmdir">2.6 rmdir</h3><p>作用：删除空目录</p><p>语法：rmdir [-p] dirName</p><p>-p: 当子目录被删除后使父目录为空目录的话，则一并删除</p><p>rm</p><p>作用：删除文件或者目录</p><p>语法：rm [-rf] name</p><p>-r:将目录及目录中的所有文件（目录）逐一删除，即递归删除</p><p>-f: 无需确认直接删除</p><h3 id="2-7-tar">2.7 tar</h3><p>作用：对文件进行打包、解包、压缩、解压</p><p>语法：tar [-zcxvf] fileName [files]</p><p>包文件后缀为.tar表示只是完成了打包，并没有压缩</p><p>包文件后缀为.tar.gz表示打包的同时还进行了压缩</p><p>说明：</p><p>-z: z代表gzip，通过gzip命令处理文件，gzip可以对文件压缩或者解压</p><p>-c: c代表的是create，即创建新的包文件</p><p>-x: x代表的是extract，实现从包文件中还原文件</p><p>-v: v代表的是verbose,显示命令的执行过程</p><p>-f: f代表的是file ,用于指定包文件的名称</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Linux笔记&lt;/h1&gt;
&lt;h2 id=&quot;1-目录结构&quot;&gt;1. 目录结构&lt;/h2&gt;
&lt;p&gt;&lt;img   src=&quot;https://dettry.github.io/picx-images-hosting/Java/image-20230401113335627.8kzwg</summary>
      
    
    
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记</title>
    <link href="http://example.com/2023/05/05/Java%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/05/05/Java%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-05T06:11:45.000Z</published>
    <updated>2024-05-09T05:38:23.600Z</updated>
    
    <content type="html"><![CDATA[<h1>Java笔记</h1><h2 id="基础篇">基础篇</h2><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221112111329540.1vygre2xdd.jpg"  alt="image-20221112111329540"></p><h3 id="java语言概述">java语言概述</h3><h4 id="整体概述">整体概述</h4><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221115162358155.70a5go2yyo.jpg"  alt="image-20221115162358155"></p><h4 id="java语言的特点">java语言的特点</h4><p>特点一：面向对象</p><p>两概三特：类、对象；封装、继承、多态；</p><p>特点二：健壮性</p><p>去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等）</p><p>特点三：跨平台性</p><p>原理：先安装一个JVM虚拟机，然后由JVM负责JAVA程序在该系统上运行。</p><p>Java核心机制</p><p>Java虚拟机：对于不同的平台有不同的虚拟机；</p><p>垃圾回收机制：</p><h4 id="注释">注释</h4><p>单行和多行注释与c语言注释相同</p><p>文档注释：JAVA所特有</p><p>格式：/**  */</p><p>作用：注释的内容可以被jdk提供的工具javadoc所解析，生成网页形式的程序说明文档。</p><h4 id="java-API文档">java API文档</h4><p>英文版：版本8</p><p>中文版：版本6</p><h3 id="Java基本语法">Java基本语法</h3><h4 id="保留字">保留字</h4><p>goto、const，java没有赋予其特殊含义，但在命名时尽量避开。</p><h4 id="标识符">标识符</h4><p>凡是可以自己起的名字都叫标识符。e.g：变量名、类名等等</p><p>命名规范</p><p>包名：多个单词组成时所有字母都小写</p><p>类名、接口名：多单词组成时，所有单词首字母大写</p><p>变量名、方法名：多单词组成时，第一个单词首字母小写，从第二个单词开始首字母大写。</p><p>常量名：所有字母都大写，多单词时，每个单词用下划线连接。</p><h4 id="变量的类型">变量的类型</h4><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221116165948252.361dxpl4w1.jpg"  alt="image-20221116165948252"></p><h4 id="变量运算规则的两种特殊情况">变量运算规则的两种特殊情况</h4><p>定义long型变量：long len=78899786676l/L;</p><p>定义float型变量：float len=12.3f/F;</p><p>但现实经常使用double型变量，精度更高。</p><p>整型常量默认类型：int</p><p>浮点型常量默认类型：double</p><h4 id="算数运算符">算数运算符</h4><p>+、-、*、/、++、–、%</p><h4 id="赋值运算符">赋值运算符</h4><p>=</p><p>扩展运算符:+=、-=、*=、/+、%=</p><h4 id="比较运算符">比较运算符</h4><p>基本与c语言一样。</p><p>instanceof:检查是否是类的对象。</p><h2 id="进阶篇">进阶篇</h2><h3 id="SpringBoot">SpringBoot</h3><p><strong>开发以后所用技术：mybatis+druid+远程服务器，别使用lombok进行开发</strong>。</p><h4 id="基础篇-2">基础篇</h4><h5 id="1-parent">1. parent</h5><p>将以前spring开发时所需要配置的pom 文件进行整合，方便管理。</p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221125191759218.7ljt2yzuti.jpg"  alt="image-20221125191759218"></p><p><strong>小结</strong></p><ol><li><p>开发springBoot程序要继承spring-boot-starter-parent</p></li><li><p>spring-boot-starter-parent中定义了若干个依赖管理（不是具体的坐标，只是把你要用的版本管理好，而没提供具体的坐标）</p></li><li><p>继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突（做版本的统一化管理)</p></li><li><p>继承parent的形式也可以采用引入依赖的形式实现效果</p></li></ol><h5 id="2-starter">2. starter</h5><p><strong>starter</strong></p><p>​1. SpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标 ，以达到<strong>减少依赖配置</strong>的目的</p><p><strong>parent</strong></p><pre><code>1. 所有SpringBoot项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的1. spring-boot-starter-parent各版本间存在着诸多坐标版本不同</code></pre><p><strong>实际开发</strong></p><ol><li><p>使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供，除非SpringBoot未提供对应版本V</p></li><li><p>如发生坐标错误，再指定Version（要小心版本冲突)</p></li></ol><p><strong>小结</strong></p><ol><li>开发springBoot程序需要导入坐标时通常导入对应的starter</li><li>每个不同的starter根据功能不同，通常包含多个依赖坐标</li><li>使用starter可以实现快速配置的效果，达到简化配置的目的</li></ol><h5 id="3-引导类">3. 引导类</h5><p>下图即为引导类</p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221126100829179.4jnx1qxvc9.jpg"  alt="image-20221126100829179"></p><p>无论是做spring程序还是做springmvc的程序，最后都会运行出来一个spring容器的对象。所有对象都以bean的形式交给spring容器管理。</p><p>SpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目</p><p>SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean</p><p><strong>得到bean的方式有四种：</strong></p><ol><li>以类型的形式（即class）</li><li></li></ol><h5 id="4-辅助功能">4. 辅助功能</h5><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221126135325136.5q78aco423.jpg"  alt="image-20221126135325136"></p><blockquote><p>内置服务器：</p><p>tomcat(默认)</p><p>jetty</p><p>undertow</p></blockquote><p><strong>小结</strong></p><ol><li>内嵌Tomcat服务器是SpringBoot辅助功能之一</li><li>内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理</li><li>变更内嵌服务器思想是去除现有服务器，添加全新的服务器</li></ol><h5 id="5-Rest风格开发入门案例">5. Rest风格开发入门案例</h5><h6 id="1-以前的开发">1.以前的开发</h6><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221127170845847.54xko1u3yh.jpg"  alt="image-20221127170845847"></p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221127171423014.4jnx1r08ol.jpg"  alt="image-20221127171423014"></p><h6 id="2-接受参数的三种方式">2. 接受参数的三种方式</h6><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221127171256707.45hwhnugj.jpg"  alt="image-20221127171256707"></p><h6 id="3-现在的开发">3.现在的开发</h6><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221127203229053.2h84dp1nna.jpg"  alt="image-20221127203229053"></p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221127203519136.41xvd5yv3c.jpg"  alt="image-20221127203519136"></p><h5 id="6-boot配置">6. boot配置</h5><h6 id="6-1-准备工作">6.1 准备工作</h6><p>模板的制作</p><ol><li>在工作空间中复制对应工程，并修改工程名称</li><li>删除与Idea相关配置文件，仅保留src目录与pom. xml文件</li><li>修改pom.xml文件中的artifactId与新工程/模块名相同</li><li>删除name标签（可选)</li><li>保留备份工程供后期使用</li></ol><h6 id="6-2-属性配置">6.2 属性配置</h6><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221128170828876.7i07598i5n.jpg"  alt="image-20221128170828876"></p><ol><li><p>SpringBoot提供了3种配置文件的格式<br>properties (传统格式/默认格式)<br>yml（主流格式)<br>yaml</p></li><li><p>配置文件间的加载优先级<br>properties (最高)</p><p>yml（常用）</p><p>yaml(最低)</p></li><li><p>不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留</p></li></ol><p>yaml或者yml自动提示功能消失解决方案</p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221128172557083.4xucsm8jjk.jpg"  alt="image-20221128172557083"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yaml书写格式：</span><br><span class="line"></span><br><span class="line">注意属性名冒号后面与数据之间有一个空格</span><br></pre></td></tr></table></figure><p>读取数据</p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221128203619298.5q78addq5h.jpg"  alt="image-20221128203619298"></p><h5 id="7-整合第三方技术">7. 整合第三方技术</h5><ol><li><p><strong>整合junit小结</strong></p><ul><li><p>导入测试对应的starter(如果是自己手工创建的话)</p></li><li><p>测试类使用@SpringBootTest修饰</p></li><li><p>使用自动装配的形式添加要测试的对象</p></li><li><p>测试类如果存在于引导类所在包或子包中无需指定引导类</p></li><li><p>测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类</p></li></ul></li><li><p><strong>整合mybatis小结</strong></p><ul><li><p>勾选MyBatis技术，也就是导入MyBatis对应的starter</p></li><li><p>数据库连接相关信息转换成配置</p></li><li><p>数据库sQL映射需要添加@Mapper被容器识别到</p><pre><code>springboot的版本过低导致的问题处理</code></pre></li></ul></li></ol><p>​2.1 MySQL 8.X驱动强制要求设置时区</p><p>​修改url，添加serverTimezone设定</p><p>​修改MySQL数据库配置（略)</p><p>​2.2 驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver</p><blockquote><p>boot整合东西分为三个部分:</p><ol><li>导入对应的start</li><li>做相应的配置</li><li>直接使用对应的技术进行开发</li></ol></blockquote><ol start="3"><li><strong>整合mybatis-plus小结</strong> <img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221130093255881.4uaqux41pj.jpg"  alt="image-20221130093255881"></li></ol><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221130093312809.2ruy6v5go9.jpg"  alt="image-20221130093312809"></p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221130093423735.ibxndkq6z.jpg"  alt="image-20221130093423735"></p><ol start="4"><li><strong>整合Druid(即数据源)</strong></li></ol><p>​      <img   src="https://dettry.github.io/picx-images-hosting/Java/image-20230222161204003.101zbym3rx.jpg"  alt="image-20230222161204003"></p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20230228145538979.7awz9uaxlq.jpg"  alt="image-20230228145538979"></p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20230228145621901.17577e897l.jpg"  alt="image-20230228145621901"></p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20230228150602825.1aot541bxf.jpg"  alt="image-20230228150602825"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2 id=&quot;基础篇&quot;&gt;基础篇&lt;/h2&gt;
&lt;p&gt;&lt;img   src=&quot;https://dettry.github.io/picx-images-hosting/Java/image-20221112111329540.1vygre2xdd.jp</summary>
      
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
</feed>

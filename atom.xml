<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-05-21T05:45:28.847Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://example.com/2024/05/13/regular_expression_note/"/>
    <id>http://example.com/2024/05/13/regular_expression_note/</id>
    <published>2024-05-13T02:19:07.000Z</published>
    <updated>2024-05-21T05:45:28.847Z</updated>
    
    <content type="html"><![CDATA[<h1>正则表达式</h1><h2 id="1-基础正则表达式速查表">1. 基础正则表达式速查表</h2><h3 id="1-1-字符">1.1 字符</h3><table><thead><tr><th style="text-align:center">表达式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">[abc]</td><td style="text-align:left">字符集。匹配集合中所含的任一字符。</td></tr><tr><td style="text-align:center">[^abc]</td><td style="text-align:left">否定字符集。匹配任何不在集合中的字符。</td></tr><tr><td style="text-align:center">[a-z]</td><td style="text-align:left">字符范围。匹配指定范围内的任意字符。</td></tr><tr><td style="text-align:center">.</td><td style="text-align:left">匹配除换行符以外的任何单个字符。</td></tr><tr><td style="text-align:center">\</td><td style="text-align:left">转义字符。</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:left">匹配任何字母数字，包括下划线（等价于[A-Za-z0-9_]）。</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:left">匹配任何非字母数字（等价于[^A-Za-z0-9_]）。</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:left">数字。匹配任何数字。</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:left">非数字。匹配任何非数字字符。</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:left">空白。匹配任何空白字符，包括空格、制表符等。</td></tr></tbody></table><h3 id="1-2-分组和引用">1.2 分组和引用</h3><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>(expression)</td><td>分组。匹配括号里的整个表达式。</td></tr><tr><td>(?:expression)</td><td>非捕获分组。匹配括号里的整个字符串但不获取匹配结果，拿不到分组引用。</td></tr><tr><td>\num</td><td>对前面所匹配分组的引用。比如(\d)\1可以匹配两个相同的数字，(Code)(Sheep)\1\2则可以匹配CodeSheepCodeSheep。</td></tr></tbody></table><h3 id="1-3-锚点-边界">1.3 锚点/边界</h3><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串或行开头。</td></tr><tr><td>$</td><td>匹配字符串或行结尾。</td></tr><tr><td>\b</td><td>匹配单词边界。比如Sheep\b可以匹配CodeSheep末尾的Sheep，不能匹配CodeSheepCode中的Sheep</td></tr><tr><td>\B</td><td>匹配非单词边界。比如Code\B可以匹配HelloCodeSheep中的Code，不能匹配HelloCode中的Code。</td></tr></tbody></table><h3 id="1-4-数量表示">1.4 数量表示</h3><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>?</td><td>匹配前面的表达式0个或1个。即表示可选项。</td></tr><tr><td>+</td><td>匹配前面的表达式至少1个。</td></tr><tr><td>*</td><td>匹配前面的表达式0个或多个。</td></tr><tr><td>|</td><td>或运算符。并集，可以匹配符号前后的表达式。</td></tr><tr><td>{m}</td><td>匹配前面的表达式m个。</td></tr><tr><td>{m,}</td><td>匹配前面的表达式最少m个。</td></tr><tr><td>{m,n}</td><td>匹配前面的表达式最少m个，最多n个。</td></tr></tbody></table><h3 id="1-5-预查断言">1.5 预查断言</h3><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>(?=)</td><td>正向预查。比如Code(?=Sheep)能匹配CodeSheep中的Code，但不能匹配CodePig中的Code。</td></tr><tr><td>(?!)</td><td>正向否定预查。比如Code(?!Sheep)不能匹配CodeSheep中的Code，但能匹配CodePig中的Code。</td></tr><tr><td>(?&lt;=)</td><td>反向预查。比如(?&lt;=Code)Sheep能匹配CodeSheep中的Sheep，但不能匹配ReadSheep中的Sheep。</td></tr><tr><td>(?&lt;!)</td><td>反向否定预查。比如(?&lt;!Code)Sheep不能匹配CodeSheep中的Sheep，但能匹配ReadSheep中的Sheep。</td></tr></tbody></table><h3 id="1-6-特殊标志">1.6 特殊标志</h3><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>/…/i</td><td>忽略大小写。</td></tr><tr><td>/…/g</td><td>全局匹配。</td></tr><tr><td>/…/m</td><td>多行修饰符。用于多行匹配。</td></tr></tbody></table><h2 id="2-常用正则表达式示例">2. 常用正则表达式示例</h2><h3 id="2-1-数字校验">2.1 数字校验</h3><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>数字</td><td>^[0-9]*$</td><td></td></tr><tr><td>n位数字</td><td>^\d{n}$</td><td></td></tr><tr><td>至少n位数字</td><td>^\d{n,}$</td><td></td></tr><tr><td>m~n位数字</td><td>^\d{m,n}$</td><td></td></tr><tr><td>整数</td><td>^(-?[1-9]\d*)$</td><td>非0开头，包括正整数和负整数</td></tr><tr><td>正整数</td><td>^[1-9]\d*$</td><td></td></tr><tr><td>负整数</td><td>^-[1-9]\d*$</td><td></td></tr><tr><td>非负整数</td><td>^(([1-9]\d*)|0)$</td><td></td></tr><tr><td>非正整数</td><td>^((-[1-9]\d*)|0)$</td><td></td></tr><tr><td>浮点数</td><td>^-?(?:[1-9]\d*.\d*|0.\d*[1-9]\d*|0.0+|0)$</td><td>包括正浮点数和负浮点数</td></tr><tr><td>正浮点数</td><td>^(?:[1-9]\d*.\d*|0.\d*[1-9]\d*)$</td><td></td></tr><tr><td>负浮点数</td><td>^-(?:[1-9]\d*.\d*|0.\d*[1-9]\d*)$</td><td></td></tr><tr><td>非正浮点数</td><td>^(?:-(?:[1-9]\d*.\d+|0.\d*[1-9]\d*)|0.0+|0)$</td><td>包含0</td></tr><tr><td>非负浮点数</td><td>^(?:[1-9]\d*.\d+|0.\d+|0.0+|0)$</td><td>包含0</td></tr><tr><td>仅一位小数</td><td>^-?(?:0|[1-9][0-9]*).[0-9]{1}$</td><td></td></tr><tr><td>最少一位小数</td><td>^-?(?:0|[1-9][0-9]*).[0-9]{1,}$</td><td></td></tr><tr><td>最多两位小数</td><td>^-?(?:0|[1-9][0-9]*).[0-9]{1,2}$</td><td></td></tr><tr><td>连续重复的数字</td><td>^(\d)\1+$</td><td>例如：111，222</td></tr></tbody></table><h3 id="2-2-字符校验">2.2 字符校验</h3><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>中文</td><td>^[\u4E00-\u9FA5]+$</td><td></td></tr><tr><td>全角字符</td><td>^[\uFF00-\uFFFF]+$</td><td></td></tr><tr><td>半角字符</td><td>^[\u0000-\u00FF]+$</td><td></td></tr><tr><td>英文字符串（大写）</td><td>^[A-Z]+$</td><td></td></tr><tr><td>英文字符串（小写）</td><td>^[a-z]+$</td><td></td></tr><tr><td>英文字符串（不区分大小写）</td><td>^[A-Za-z]+$</td><td></td></tr><tr><td>中文和数字</td><td>^(?:[\u4E00-\u9FA5]{0,}|\d)+$</td><td></td></tr><tr><td>英文和数字</td><td>^[A-Za-z0-9]+$</td><td></td></tr><tr><td>数字、英文字母或者下划线组成的字符串</td><td>^\w+$</td><td></td></tr><tr><td>中文、英文、数字包括下划线</td><td>^[\u4E00-\u9FA5\w]+$</td><td></td></tr><tr><td>不含字母的字符串</td><td>^[^A-Za-z]*$</td><td></td></tr><tr><td>连续重复的字符串</td><td>^(.)\1+$</td><td>例如：aa，bb</td></tr><tr><td>长度为n的字符串</td><td>^.{n}$</td><td></td></tr><tr><td>ASCII</td><td>^[ -~]$</td><td></td></tr></tbody></table><h3 id="2-3-日期和时间校验">2.3 日期和时间校验</h3><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>日期</td><td>^\d{1,4}-(?:1[0-2]|0?[1-9])-(?:0?[1-9]|[1-2]\d|30|31)$</td><td>弱校验，例如：2022-06-12</td></tr><tr><td>日期</td><td>^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</td><td>严格校验，考虑平闰年</td></tr><tr><td>时间</td><td>^(?:1[0-2]|0?[1-9]):[0-5]\d:[0-5]\d$</td><td>12小时制，例如：11:21:31</td></tr><tr><td>时间</td><td>^(?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d$</td><td>24小时制，例如：23:21:31</td></tr><tr><td>日期+时间</td><td>^(\d{1,4}-(?:1[0-2]|0?[1-9])-(?:0?[1-9]|[1-2]\d|30|31))  ((?:[01]\d|2[0-3]):[0-5]\d:[0-5]\d)$</td><td>例如：2000-11-11  23:20:21</td></tr></tbody></table><h3 id="2-4-日常生活相关">2.4 日常生活相关</h3><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>中文名</td><td>^[\u4E00-\u9FA5·]{2,16}$</td><td></td></tr><tr><td>英文名</td><td>^[a-zA-Z][a-zA-Z\s]{0,20}[a-zA-Z]$</td><td></td></tr><tr><td>车牌号</td><td>^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领][A-HJ-NP-Z][A-HJ-NP-Z0-9]{4}[A-HJ-NP-Z0-9挂学警港澳]$</td><td>不含新能源</td></tr><tr><td>车牌号</td><td>^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领]<a href="?:(?:%5BA-HJ-NP-Z0-9%5D%7B4%7D%5BA-HJ-NP-Z0-9%E6%8C%82%E5%AD%A6%E8%AD%A6%E6%B8%AF%E6%BE%B3%5D)%7C(?:(?:%5Cd%7B5%7D%5BA-HJK%5D)%7C(?:%5BA-HJK%5D%5BA-HJ-NP-Z0-9%5D%5B0-9%5D%7B4%7D))">A-HJ-NP-Z</a>$</td><td>包含新能源</td></tr><tr><td>火车车次</td><td>^[GCDZTSPKXLY1-9]\d{1,4}$</td><td>例如：G1234</td></tr><tr><td>手机号</td><td>^(?:(?:+|00)86)?1[3-9]\d{9}$</td><td>弱匹配</td></tr><tr><td>手机号</td><td>^(?:(?:+|00)86)?1(?:(?:3[\d])|(?:4[5-79])|(?:5[0-35-9])|(?:6[5-7])|(?:7[0-8])|(?:8[\d])|(?:9[189]))\d{8}$</td><td>严格匹配</td></tr><tr><td>固话号码</td><td>^(?:(?:\d{3}-)?\d{8}|^(?:\d{4}-)?\d{7,8})(?:-\d+)?$</td><td></td></tr><tr><td>手机IMEI码</td><td>^\d{15,17}$</td><td>一般是15位</td></tr><tr><td>邮编</td><td>^(?:0[1-7]|1[0-356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[0-5]|8[013-6])\d{4}$</td><td>例如：211100</td></tr><tr><td>统一社会信用代码</td><td>^[0-9A-HJ-NPQRTUWXY]{2}\d{6}[0-9A-HJ-NPQRTUWXY]{10}$</td><td></td></tr><tr><td>身份证号码(1代)</td><td>^[1-9]\d{7}(?:0\d|10|11|12)(?:0[1-9]|[1-2][\d]|30|31)\d{3}$</td><td>15位数字</td></tr><tr><td>身份证号码(2代)</td><td>^[1-9]\d{5}(?:18|19|20)\d{2}(?:0[1-9]|10|11|12)(?:0[1-9]|[1-2]\d|30|31)\d{3}[0-9Xx]$</td><td>18位数字</td></tr><tr><td>QQ号</td><td>^[1-9][0-9]{4,}$</td><td>一般是5到10位</td></tr><tr><td>微信号</td><td>^[a-zA-Z][-_a-zA-Z0-9]{5,19}$</td><td>一般6~20位，字母开头，可包含字母、数字、-、_，不含特殊字符</td></tr><tr><td>股票代码</td><td>^(s[hz]|S[HZ])(000[\d]{3}|002[\d]{3}|300[\d]{3}|600[\d]{3}|60[\d]{4})$</td><td>A股，例如：600519</td></tr><tr><td>银行卡卡号</td><td>^[1-9]{1}(?:\d{15}|\d{18})$</td><td>一般为19位</td></tr></tbody></table><h3 id="2-5-互联网相关">2.5 互联网相关</h3><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>域名</td><td>^[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$</td><td>例如：<a class="link"   href="http://r2coding.com" >r2coding.com<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>网址</td><td>^(?:https?://)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$</td><td>例如：<a class="link"   href="https://www.r2coding.com/" >https://www.r2coding.com/<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>带端口号的网址(或IP)</td><td>^(?:https?://)?[\w-]+(?:.[\w-]+)+:\d{1,5}/?$</td><td>例如：<a class="link"   href="http://127.0.0.1:8888/" >http://127.0.0.1:8888/<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>URL</td><td>^https?://(?:www.)?[-a-zA-Z0-9@:%.<em>+~#=]{1,256}.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()!@:%</em>+.~#?&amp;//=]*)$</td><td>例如：<a class="link"   href="https://www.r2coding.com/#/README?id=1" >https://www.r2coding.com/#/README?id=1<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>邮箱email</td><td>^[A-Za-z0-9\u4e00-\u9fa5]+@[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+$</td><td>支持中文，例如：codesheep@cs.com</td></tr><tr><td>用户名</td><td>^[a-zA-Z0-9_-]{4,20}$</td><td>4到20位</td></tr><tr><td>弱密码</td><td>^[\w]{6,16}$</td><td>6~16位，包含大小写字母和数字的组合</td></tr><tr><td>强密码</td><td>^.<em>(?=.{6,})(?=.</em>\d)(?=.<em>[A-Z])(?=.</em>[a-z])(?=.<em>[!@.#$%^&amp;</em>?  ]).*$</td><td>至少6位，包括至少1个大写字母，1个小写字母，1个数字，1个特殊字符</td></tr><tr><td>端口号</td><td>^(?:[0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$</td><td>例如：65535</td></tr><tr><td>IPv4地址</td><td>^(?:(?:\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]).){3}(?:\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])$</td><td>例如：192.168.31.1</td></tr><tr><td>IPv4地址+端口</td><td>^(?:(?:\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]).){3}(?:\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(?::(?:[0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?$</td><td>例如：192.168.31.1:8080</td></tr><tr><td>IPv6地址</td><td>^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$</td><td>例如：CDCD:910A:2222:5498:8475:1111:3900:2020</td></tr><tr><td>IPv6地址+端口</td><td>^[(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]).){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))](?::(?:[0-9]|[1-9][0-9]{1,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5]))?$</td><td>例如：[CDCD:910A:2222:5498:8475:1111:3900:2020]:9800</td></tr><tr><td>子网掩码</td><td>^(?:254|252|248|240|224|192|128).0.0.0|255.(?:254|252|248|240|224|192|128|0).0.0|255.255.(?:254|252|248|240|224|192|128|0).0|255.255.255.(?:255|254|252|248|240|224|192|128|0)$</td><td>例如：255.255.255.0</td></tr><tr><td>MAC地址</td><td>^(?:(?:[a-f0-9A-F]{2}:){5}|(?:[a-f0-9A-F]{2}-){5})[a-f0-9A-F]{2}$</td><td></td></tr><tr><td>Version版本号</td><td>^\d+(?:.\d+){2}$</td><td>例如：12.1.1</td></tr><tr><td>图片后缀</td><td>.(gif|png|jpg|jpeg|webp|svg|psd|bmp|tif)+</td><td>可按需增删扩展名集合</td></tr><tr><td>视频后缀</td><td>.(swf|avi|flv|mpg|rm|mov|wav|asf|3gp|mkv|rmvb|mp4)+</td><td>可按需增删扩展名集合</td></tr><tr><td>图片链接</td><td>(?:https?://)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.+.(gif|png|jpg|jpeg|webp|svg|psd|bmp|tif)</td><td>可按需增删扩展名集合</td></tr><tr><td>视频链接</td><td>(?:https?://)?[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(?:.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.+.(swf|avi|flv|mpg|rm|mov|wav|asf|3gp|mkv|rmvb|mp4)</td><td>可按需增删扩展名集合</td></tr><tr><td>迅雷链接</td><td>thunderx?://[a-zA-Z\d]+=</td><td></td></tr><tr><td>ed2k链接</td><td>ed2k://|file|.+|/</td><td></td></tr><tr><td>磁力链接</td><td>magnet:?xt=urn:btih:[0-9a-fA-F]{40,}.*</td><td></td></tr></tbody></table><h3 id="2-6-其他">2.6 其他</h3><table><thead><tr><th>描述</th><th>正则表达式</th><th>备注</th></tr></thead><tbody><tr><td>MD5格式</td><td>^(?:[a-f\d]{32}|[A-F\d]{32})$</td><td>32位MD5，例如：7552E7071B118CBFFEC8C930455B4297</td></tr><tr><td>BASE64格式</td><td>^\s<em>data:(?:[a-z]+/[a-z0-9-+.]+(?:;[a-z-]+=[a-z0-9-]+)?)?(?:;base64)?,([a-z0-9!$&amp;',()</em>+;=-._~:@/?%\s]<em>?)\s</em>$</td><td>例如：data:image/jpeg;base64,xxxx==</td></tr><tr><td>UUID</td><td>^[a-f\d]{4}(?:[a-f\d]{4}-){4}[a-f\d]{12}$</td><td>例如：94f9d45a-71b0-4b3c-b69d-20c4bc9c8fdd</td></tr><tr><td>16进制</td><td>^[A-Fa-f0-9]+$</td><td>例如：FFFFFF</td></tr><tr><td>16进制颜色</td><td>^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$</td><td>例如：#FFFFFF</td></tr><tr><td>SQL语句</td><td>^(?:select|drop|delete|create|update|insert).*$</td><td></td></tr><tr><td>Java包名</td><td>^(?:[a-zA-Z_]\w*)+(?:[.][a-zA-Z_]\w*)+$</td><td>例如：com.r2coding.controller</td></tr><tr><td>文件扩展名</td><td>.(?:doc|pdf|txt)</td><td>可按需增删扩展名集合</td></tr><tr><td>Windows文件路径</td><td>^[a-zA-Z]:(?:\[\w\u4E00-\u9FA5\s]+)+[.\w\u4E00-\u9FA5\s]+$</td><td>例如：C:\Users\Administrator\Desktop\a.txt</td></tr><tr><td>Windows文件夹路径</td><td>^[a-zA-Z]:(?:\[\w\u4E00-\u9FA5\s]+)+$</td><td>例如：C:\Users\Administrator\Desktop</td></tr><tr><td>Linux文件路径</td><td>^/(?:[^/]+/)*[^/]+$</td><td>例如：/root/library/a.txt</td></tr><tr><td>Linux文件夹路径</td><td>^/(?:[^/]+/)*$</td><td>例如：/root/library/</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;正则表达式&lt;/h1&gt;
&lt;h2 id=&quot;1-基础正则表达式速查表&quot;&gt;1. 基础正则表达式速查表&lt;/h2&gt;
&lt;h3 id=&quot;1-1-字符&quot;&gt;1.1 字符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;表达式&lt;/</summary>
      
    
    
    
    <category term="Java开发专题" scheme="http://example.com/categories/Java%E5%BC%80%E5%8F%91%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用Hexo-asset-image图片无法正常显示的一些解决方案</title>
    <link href="http://example.com/2024/05/09/hexo-asset-image-note/"/>
    <id>http://example.com/2024/05/09/hexo-asset-image-note/</id>
    <published>2024-05-09T02:28:07.000Z</published>
    <updated>2024-05-09T04:45:46.094Z</updated>
    
    <content type="html"><![CDATA[<h1>hexo使用Hexo-asset-image图片无法正常显示的一些解决方案</h1><h2 id="1-问题描述">1. 问题描述</h2><p>在进行个人博客的搭建工作时，</p><h2 id="2-解决方案">2. 解决方案</h2><h3 id="2-1-修改hexo-asset-image的代码（未测试）">2.1 修改hexo-asset-image的代码（未测试）</h3><p>详细步骤参考下面文章：</p><p><a class="link"   href="https://blog.csdn.net/kurapika_030/article/details/130598712" >【Hexo】hexo-asset-image在hexo6.3.0下的使用以及与abbrlink插件的修改-CSDN博客<i class="fas fa-external-link-alt"></i></a></p><h3 id="2-2-换用hexo-renderer-marked-it（测试有效）">2.2 换用hexo-renderer-marked-it（测试有效）</h3><p>根据hexo官方中的描述如下</p><p>如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</p><p><strong>文章资源文件夹</strong></p><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure><p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p><p><strong>相对路径引用的标签插件</strong></p><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的<a class="link"   href="https://hexo.io/zh-cn/docs/tag-plugins#%E5%BC%95%E7%94%A8%E8%B5%84%E6%BA%90" >标签插件<i class="fas fa-external-link-alt"></i></a>被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure><p>比如说：当你打开文章资源文件夹功能后，你把一个 <code>example.jpg</code> 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](example.jpg)</code> ，它将 <em>不会</em> 出现在首页上。（但是它会在文章中按你期待的方式工作）</p><p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><p><strong>使用 Markdown 嵌入图片</strong></p><p><a class="link"   href="https://github.com/hexojs/hexo-renderer-marked" >hexo-renderer-marked<i class="fas fa-external-link-alt"></i></a> 3.1.0 引入了一个新的选项，其允许你无需使用 <code>asset_img</code> 标签插件就可以在 markdown 中嵌入图片（进入链接后往下翻找进入hexo-renderer-marked-it）</p><p>如需启用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_config.yml</span><br><span class="line">post_asset_folder: true</span><br><span class="line">images:</span><br><span class="line">    lazyload: false</span><br><span class="line">    prepend_root: true</span><br><span class="line">    post_asset: true</span><br></pre></td></tr></table></figure><p>启用后，资源图片将会被自动解析为其对应文章的路径。<br>例如： <code>image.jpg</code> 位置为 <code>/2020/01/02/foo/image.jpg</code> ，这表示它是 <code>/2020/01/02/foo/</code> 文章的一张资源图片， <code>![](image.jpg)</code> 将会被解析为 <code>&lt;img   src=&quot;/2020/01/02/foo/image.jpg&quot; &gt;</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意事项：</span><br><span class="line">如果使用![](image.jpg)这种引用格式的话在markdown编辑器中是无法看到图片的，只能在浏览器中看到</span><br><span class="line">可以使用![](your_essay_name/image.jpg)引用格式这样本地和浏览器中均可看到</span><br></pre></td></tr></table></figure><p>!!!特别注意你的文章名称不能是中文，这样会导致你的图片在浏览器中无法显示。博主亲测 :joy:</p><h3 id="2-3-使用图床">2.3 使用图床</h3><p>如果使用图床的话，这样post_asset_folder就可以不用启用了也不用安装图片转换插件了。博主目前正在使用的就是图床，网上也有人说由于图床有时可能不稳定会导致浏览器无法访问照片，管他呢先用着再说。</p><p>博主使用的图床工具是<a class="link"   href="https://picx.xpoet.cn/" >PicX<i class="fas fa-external-link-alt"></i></a>，感觉挺好用的不用安装直接在线就可上传图片。网上也有很多别的图床工具例如PicGo等等，配置教程就不一一赘述了，大家可自行百度。</p><p>PicX配置教程如下：</p><h4 id="2-3-1-GitHub-OAuth-授权登录">2.3.1 GitHub OAuth 授权登录</h4><p>不推荐，原因是还需要安装picX，麻烦！！！！！！！！！！！！！</p><h4 id="2-3-2-填写GitHub-Token登录">2.3.2 填写GitHub Token登录</h4><ol><li>创建一个带有 <code>repo</code> 权限的 GitHub Token点击 <a class="link"   href="https://github.com/settings/tokens/new" >https://github.com/settings/tokens/new<i class="fas fa-external-link-alt"></i></a> 快速新建 GitHub Token</li></ol><p><img   src="https://github.com/dettry/picx-images-hosting/raw/master/hexo-asset-image-note/image-20240509121100220.1e8f2s8xy5.jpg"  alt="image-20240509121100220"></p><ol start="2"><li><p>点击 <strong><code>Generate token</code></strong> 按钮，生成 GitHub Token并保存。</p></li><li><p>图床配置</p></li></ol><ul><li>填写 GitHub Token 之后，点击 <strong><code>一键配置</code></strong> PicX 会自动创建 GitHub 仓库，完成仓库、分支和目录之间的配置，并跳转到图片上传页面。</li></ul><p><img   src="https://github.com/dettry/picx-images-hosting/raw/master/hexo-asset-image-note/image-20240509121829318.1seutnh8ta.jpg"  alt="image-20240509121829318"></p><ul><li><p>进入页面后可以选择图床配置新建目录来设置新的图片保存路径，也可以直接上传图片。</p></li><li><p>图床设置中除了图片压缩选择图中的选项外，其余保持默认。</p></li></ul><p><img   src="https://github.com/dettry/picx-images-hosting/raw/master/hexo-asset-image-note/image-20240509123525925.2a4wi93vfm.jpg"  alt="image-20240509123525925"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;hexo使用Hexo-asset-image图片无法正常显示的一些解决方案&lt;/h1&gt;
&lt;h2 id=&quot;1-问题描述&quot;&gt;1. 问题描述&lt;/h2&gt;
&lt;p&gt;在进行个人博客的搭建工作时，&lt;/p&gt;
&lt;h2 id=&quot;2-解决方案&quot;&gt;2. 解决方案&lt;/h2&gt;
&lt;h3 id=&quot;2-1-修</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>k8s集群搭建常见问题汇总</title>
    <link href="http://example.com/2024/05/04/kubeadm%E6%90%AD%E5%BB%BAKubernetes%E9%9B%86%E7%BE%A4%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2024/05/04/kubeadm%E6%90%AD%E5%BB%BAKubernetes%E9%9B%86%E7%BE%A4%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2024-05-04T05:50:36.000Z</published>
    <updated>2024-05-04T06:29:08.115Z</updated>
    
    <content type="html"><![CDATA[<h1>kubeadm搭建Kubernetes集群问题汇总</h1><h2 id="问题一：kubeadm-init-报错-ERROR-CRI-container-runtime-is-not-running需要使用的解决方法">问题一：kubeadm init 报错 [ERROR CRI]: container runtime is not running需要使用的解决方法</h2><ol><li>kubernetes使用crictl命令管理CRI，查看其配置文件<code>/etc/crictl.yaml</code>。初始情况下没有这个配置文件，这里建议添加这个配置，否则kubeadm init时会报其他错。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#containered做进行时</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br><span class="line">#cri-docker做进行时</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#执行crictl images list命令不报错</span><br><span class="line">crictl images list</span><br></pre></td></tr></table></figure><ol start="2"><li>查看配置文件：/etc/containerd/config.toml</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改 disabled_plugins = [&quot;cri&quot;]为 disabled_plugins = []</span><br></pre></td></tr></table></figure><p>重启containerd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure><h2 id="问题二：ERROR-FileContent–proc-sys-net-bridge-bridge-nf-call-iptables">问题二：ERROR FileContent–proc-sys-net-bridge-bridge-nf-call-iptables</h2><p>报错原因：网桥过滤和地址转发功能不可用</p><p>解决方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/sysctl.d/kubernetes.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 然后执行,生效</span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure><p>如果执行上述命令报/proc/sys/net/bridge/bridge-nf-call-iptables does not exist错误是因为网桥功能未开启，执行下面的命令即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modprobe br_netfilter</span><br></pre></td></tr></table></figure><h2 id="问题三：kubelet报错failed-to-run-Kubelet-running-with-swap-on-is-not-supported">问题三：kubelet报错failed to run Kubelet: running with swap on is not supported</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure><h2 id="问题四：kubeadm-init时报错一些配置文件已存在">问题四：kubeadm init时报错一些配置文件已存在</h2><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset</span><br></pre></td></tr></table></figure><h2 id="问题五：kubeadm-init时，kubelet-报错crictl-runtime-endpoint配置不对">问题五：kubeadm init时，kubelet 报错crictl --runtime-endpoint配置不对</h2><p>从日志看出时crictl命令运行时有问题。unix:///var/run/containerd/containerd.sock不存在。运行crictl命令，发现同样报错。出现报错的原因是crictl下载镜像时使用的是默认端点<code>[unix:///var/run/dockershim.sock unix:///run/containerd/containerd.sock unix:///run/crio/crio.sock unix:///var/run/cri-dockerd.sock]</code>。这些端点废弃了，需要重新指定<code>containerd.sock</code>。后面的报错就是找不到dockershim.sock。</p><p><strong>解决方法：修改crictl文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#containered做进行时</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br><span class="line">#cri-docker做进行时</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">#执行crictl images list命令不报错</span><br><span class="line">crictl images list</span><br></pre></td></tr></table></figure><h2 id="问题六：报Usage-of-CRI-endpoints-without-URL-scheme-is-deprecated-and-can-cause-kubelet-errors-in-the-future-警告">问题六：报Usage of CRI endpoints without URL scheme is deprecated and can cause kubelet errors in the future.警告</h2><p>W0504 10:46:57.238606    6046 initconfiguration.go:120] Usage of CRI endpoints without URL scheme is deprecated and can cause kubelet errors in the future. Automatically prepending scheme “unix” to the “criSocket” with value “/var/run/cri-dockerd.sock”. Please update your configuration!</p><p>如果是contained做进行时就执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo crictl config \</span><br><span class="line">--set runtime-endpoint=unix:///var/run/containerd/containerd.sock \</span><br><span class="line">--set image-endpoint=unix:///var/run/containerd/containerd.sock</span><br><span class="line">#或者</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/containerd/containerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>如果时cri-docker做进行时就执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo crictl config \</span><br><span class="line">--set runtime-endpoint=unix:///var/run/cri-dockerd.sock \</span><br><span class="line">--set image-endpoint=unix:///var/run/cri-dockerd.sock</span><br><span class="line">#或者</span><br><span class="line">cat &gt; /etc/crictl.yaml &lt;&lt;EOF</span><br><span class="line">runtime-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">image-endpoint: unix:///var/run/cri-dockerd.sock</span><br><span class="line">timeout: 0</span><br><span class="line">debug: false</span><br><span class="line">pull-image-on-create: false</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="问题七：报错pause镜像获取失败">问题七：报错pause镜像获取失败</h2><p>通过log提示执行命令<code>crictl --runtime-endpoint unix:///var/run/containerd/containerd.sock ps -a</code> 发现没有容器在运行。查看containerd的日志，有如下报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">journalctl -fu containerd</span><br><span class="line">...</span><br><span class="line">Oct 11 08:35:16 master.k8s containerd[1903]: time=&quot;2023-10-11T08:35:16.760026536+08:00&quot; level=error msg=&quot;RunPodSandbox for &amp;PodSandboxMetadata&#123;Name:kube-apiserver-node,Uid:a5a7c15a42701ab6c9dca630e6523936,Namespace:kube-system,Attempt:0,&#125; failed, error&quot; error=&quot;failed to get sandbox image \&quot;registry.k8s.io/pause:3.6\&quot;: failed to pull image \&quot;registry.k8s.io/pause:3.6\&quot;: failed to pull and unpack image \&quot;registry.k8s.io/pause:3.6\&quot;: failed to resolve reference \&quot;registry.k8s.io/pause:3.6\&quot;: failed to do request: Head \&quot;https://asia-east1-docker.pkg.dev/v2/k8s-artifacts-prod/images/pause/manifests/3.6\&quot;: dial tcp 108.177.125.82:443: connect: connection refused&quot;</span><br><span class="line">Oct 11 08:35:18 master.k8s containerd[1903]: time=&quot;2023-10-11T08:35:18.606581001+08:00&quot; level=info msg=&quot;trying next host&quot; error=&quot;failed to do request: Head \&quot;https://asia-east1-docker.pkg.dev/v2/k8s-artifacts-prod/images/pause/manifests/3.6\&quot;: dial tcp 108.177.125.82:443: connect: connection refused&quot; host=registry.k8s.io</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>报错显示containerd拉去镜像失败。error=&quot;failed to get sandbox image&quot;registry.k8s.io/pause:3.6&quot;</p><p><strong>解决方法：修改containered配置</strong></p><ul><li>运行containerd config dump &gt; /etc/containerd/config.toml 命令，将当前配置导出到文件，并修改sandbox_image配置。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 修改配置文件/etc/containerd/config.toml， 更改sandbox_image配置</span><br><span class="line">[plugins]</span><br><span class="line">  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span><br><span class="line">    sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;</span><br></pre></td></tr></table></figure><ul><li>重启containerd</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart containerd</span><br><span class="line"></span><br><span class="line">#查看containerd当前配置，验证pause镜像是否生效</span><br><span class="line">containerd config dump | grep pause</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;kubeadm搭建Kubernetes集群问题汇总&lt;/h1&gt;
&lt;h2 id=&quot;问题一：kubeadm-init-报错-ERROR-CRI-container-runtime-is-not-running需要使用的解决方法&quot;&gt;问题一：kubeadm init 报错 [ERR</summary>
      
    
    
    
    
    <category term="kubernetes" scheme="http://example.com/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>k8s集群搭建教程（使用cri-docker+flannel）</title>
    <link href="http://example.com/2024/05/04/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <id>http://example.com/2024/05/04/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</id>
    <published>2024-05-04T04:24:36.000Z</published>
    <updated>2024-05-07T08:30:29.143Z</updated>
    
    <content type="html"><![CDATA[<h1>k8s集群搭建教程（使用cri-docker+flannel）</h1><h2 id="1-准备工作（所有节点）">1. 准备工作（所有节点）</h2><h3 id="1-1-系统环境-我是没配置也部署成功了，可以先部署，如果失败了再回来进行系统环境优化">1.1 系统环境(我是没配置也部署成功了，可以先部署，如果失败了再回来进行系统环境优化)</h3><ul><li>系统环境优化配置</li></ul><p>CentOs 7.x系统自带的3.10.x内核存在一些bug，导致运行的docker，kubernetes不稳定，获取源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-4.el7.elrepo.noarch.rpm</span><br></pre></td></tr></table></figure><ul><li>安装内核，装完成后检查 /boot/grub2/grub.cfg中对应内核menuentry中是否包含 initrd16 配置，如果没有，再安装一次！耗时可能会有点久</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=elrepo-kernel install -y kernel-lt </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#查看系统的全部内核</span><br><span class="line">rpm -qa | grep kernel</span><br><span class="line">#kernel-3.10.0-1160.el7.x86_64</span><br><span class="line">#kernel-lt-5.4.271-1.el7.elrepo.x86_64</span><br><span class="line">#kernel-tools-libs-3.10.0-1160.el7.x86_64</span><br><span class="line">#kernel-tools-3.10.0-1160.el7.x86_64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#设置开机从新内核启动</span><br><span class="line">grub2-set-default &#x27;CentoS Linux(5.4.271-1.el7.elrepo.x86_64) 7 (Core)&#x27;</span><br><span class="line">reboot</span><br><span class="line"></span><br><span class="line">#查看正在使用的内核</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure><h3 id="1-2-系统参数设置">1.2 系统参数设置</h3><ul><li>所有节点关闭swap和防火墙</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">#临时关闭swapoff</span><br><span class="line">swapoff -a</span><br><span class="line">#永久关闭swapoff（如果想永久关闭，将下面命令的#去掉）</span><br><span class="line">#sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><ul><li>禁用SELINUX</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br><span class="line">sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config</span><br></pre></td></tr></table></figure><ul><li>所有节点设置主机名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hostnamectl set-hostname  k8s-master</span><br><span class="line">hostnamectl set-hostname  k8s-node1</span><br><span class="line">hostnamectl set-hostname  k8s-node2</span><br></pre></td></tr></table></figure><ul><li>所有节点主机名/IP加入hosts解析</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/hosts</span><br><span class="line"></span><br><span class="line">加入如下内容：</span><br><span class="line">192.168.183.132 k8s-master</span><br><span class="line">192.168.183.133 k8s-node1</span><br><span class="line">192.168.183.134 k8s-node2</span><br></pre></td></tr></table></figure><ul><li>所有节点配置k8s内核</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; kubernetes.conf &lt;&lt;EOF</span><br><span class="line">net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables=1</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">net.ipv4.tcp_tw_recycle=0</span><br><span class="line">vm.swappiness=0 #禁止使用swap空间，只有当系统OOM时才允许使用它</span><br><span class="line">vm.overcommit_memory=1 #不检查物理内存是否够用</span><br><span class="line">vm.panic_on_oom=0 #开启OOM</span><br><span class="line">fs.inotify.max_user_instances=8192</span><br><span class="line">fs.inotify.max_user_watches=1048576</span><br><span class="line">fs.file-max=52706963</span><br><span class="line">fs.nr_open=52706963</span><br><span class="line">net.ipv6.conf.all.disable_ipv6=1</span><br><span class="line">net.netfilter.nf_conntrack_max=2310720</span><br><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br><span class="line">net.ipv4.tcp_keepalive_intvl =15</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 36000</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_max_orphans = 327680</span><br><span class="line">net.ipv4.tcp_orphan_retries = 3</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 16384</span><br><span class="line">net.ipv4.ip_conntrack_max = 65536</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 16384</span><br><span class="line">net.ipv4.tcp_timestamps = 0</span><br><span class="line">net.core.somaxconn = 16384</span><br><span class="line">EOF</span><br><span class="line">cp kubernetes.conf /etc/sysctl.d/kubernetes.conf</span><br><span class="line">sysctl -p /etc/sysctl.d/kubernetes.conf</span><br></pre></td></tr></table></figure><ul><li>limit优化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ulimit -SHn 65535</span><br><span class="line"> </span><br><span class="line">cat &lt;&lt;EOF &gt;&gt; /etc/security/limits.conf</span><br><span class="line">soft nofile 655360</span><br><span class="line">hard nofile 131072</span><br><span class="line">soft nproc 655350</span><br><span class="line">hard nproc 655350</span><br><span class="line">soft memlock unlimited</span><br><span class="line">hard memlock unlimited</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="2-组件安装（所有节点）">2. 组件安装（所有节点）</h2><h3 id="2-1-Docker安装">2.1 Docker安装</h3><p>如果你的系统未安装过Docker，直接按照下面步骤操作即可。如果之前安装过，请先自行百度卸载干净。</p><ul><li>安装软件包并设置存储库</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><ul><li>安装Docker</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><ul><li>启动Docker</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><ul><li>创建 /etc/docker目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/docker</span><br><span class="line"> </span><br><span class="line">#配置daemon</span><br><span class="line">cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">    &quot;exec-opts&quot;:[&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">    &quot;log-driver&quot;:&quot;json-file&quot;,</span><br><span class="line">    &quot;log-opts&quot;:&#123;</span><br><span class="line">        &quot;max-size&quot;:&quot;100m&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line"> </span><br><span class="line">#重启docker服务</span><br><span class="line">systemctl daemon-reload &amp;&amp; systemctl restart docker &amp;&amp; systemctl enable docker</span><br></pre></td></tr></table></figure><ul><li>注意事项</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubernetes 1.24+版本之后，docker必须要加装cir-docker</span><br></pre></td></tr></table></figure><h3 id="2-2-安装cri-docker">2.2 安装cri-docker</h3><p><strong>go安装</strong></p><ul><li>下载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://golang.google.cn/dl/go1.20.12.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#安装go</span><br><span class="line">rm -rf /usr/local/go &amp;&amp; tar -C /usr/local/ -xzvf go1.20.12.linux-amd64.tar.gz </span><br></pre></td></tr></table></figure><ul><li>设置环境变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line">添加以下内容到profile 文件中（gopath应提前创建好，或者配置完成后别忘了创建）</span><br><span class="line">#go setting</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/usr/local/gopath</span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br><span class="line"></span><br><span class="line">#保存退出执行</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>构建cri-dockerd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Mirantis/cri-dockerd.git</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd cri-dockerd</span><br><span class="line">mkdir bin</span><br><span class="line">go build -o bin/cri-dockerd</span><br><span class="line">mkdir -p /usr/local/bin</span><br><span class="line">install -o root -g root -m 0755 bin/cri-dockerd /usr/local/bin/cri-dockerd</span><br><span class="line">cp -a packaging/systemd/* /etc/systemd/system</span><br><span class="line">sed -i -e &#x27;s,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,&#x27; /etc/systemd/system/cri-docker.service</span><br></pre></td></tr></table></figure><p><strong>Kubernetes使用</strong></p><ul><li>编辑：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/cri-docker.service</span><br></pre></td></tr></table></figure><p>在ExecStart后面追加，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/local/bin/cri-dockerd --container-runtime-endpoint fd:// --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9</span><br></pre></td></tr></table></figure><ul><li>创建cri-docker启动文件，然后拷贝到其他节点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/cri-docker.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=CRI Interface for Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.mirantis.com</span><br><span class="line">After=network-online.target firewalld.service docker.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line">Requires=cri-docker.socket</span><br><span class="line"> </span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/bin/cri-dockerd --network-plugin=cni --pod-infra-container-image=registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RestartSec=2</span><br><span class="line">Restart=always</span><br><span class="line"> </span><br><span class="line">StartLimitBurst=3</span><br><span class="line"> </span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"> </span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line"> </span><br><span class="line">TasksMax=infinity</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/cri-docker.socket</span><br><span class="line">[Unit]</span><br><span class="line">Description=CRI Docker Socket for the API</span><br><span class="line">PartOf=cri-docker.service</span><br><span class="line"> </span><br><span class="line">[Socket]</span><br><span class="line">ListenStream=%t/cri-dockerd.sock</span><br><span class="line">SocketMode=0660</span><br><span class="line">SocketUser=root</span><br><span class="line">SocketGroup=docker</span><br><span class="line"> </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=sockets.target</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp /usr/lib/systemd/system/cri-docker.service /usr/lib/systemd/system/cri-docker.socket root@k8s-node1:/usr/lib/systemd/system/</span><br><span class="line"> </span><br><span class="line">scp /usr/lib/systemd/system/cri-docker.service /usr/lib/systemd/system/cri-docker.socket root@k8s-node2:/usr/lib/systemd/system/</span><br></pre></td></tr></table></figure><ul><li>启动cri-docker并设置开机自动启动</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload ; systemctl enable cri-docker --now</span><br><span class="line">#查看状态</span><br><span class="line">systemctl is-active cri-docker</span><br></pre></td></tr></table></figure><h3 id="2-3-所有节点安装-kubeadm，kubelet-和-kubectl">2.3 所有节点安装 kubeadm，kubelet 和 kubectl</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line">setenforce 0</span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure><ul><li>设置kubelet开机自启</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now kubelet.service</span><br></pre></td></tr></table></figure><h2 id="3-搭建k8s集群">3. 搭建k8s集群</h2><h3 id="3-1-k8s初始化">3.1 k8s初始化</h3><ul><li>在master上初始化k8s</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=192.168.183.132 \</span><br><span class="line">--image-repository=registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version=v1.28.2 \</span><br><span class="line">--service-cidr=10.96.0.0/12  \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">--cri-socket=unix:///var/run/cri-dockerd.sock</span><br></pre></td></tr></table></figure><ul><li>按照提示创建kubeconfig文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><ul><li>重新初始化</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubeadm reset --cri-socket /var/run/cri-dockerd.sock</span><br><span class="line"> </span><br><span class="line">rm -rf .kube/</span><br><span class="line">sudo mkdir ~/.kube</span><br><span class="line">sudo cp /etc/kubernetes/admin.conf ~/.kube/</span><br><span class="line">cd ~/.kube</span><br><span class="line">mv admin.conf config</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure><h3 id="3-2-node节点的加入">3.2 node节点的加入</h3><ul><li>加入节点</li></ul><p>在node节点如k8s-node1上执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join kubeadm初始化成功后的token --cri-socket /var/run/cri-dockerd.sock</span><br><span class="line">例如我的kubeadm初始化成功后的token为：</span><br><span class="line">192.168.183.132:6443 --token vib96t.hmkd7hj7ykdigmp1 --discovery-token-ca-cert-hash sha256:c0bb3a82a4642cc4fe253edd0533ad8136b34dc243f274aa3cea27abc46e321f</span><br></pre></td></tr></table></figure><ul><li>查看节点状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line"></span><br><span class="line">此时所有节点的状态为NotReady，这是因为还没有安装flannel网络插件</span><br></pre></td></tr></table></figure><ul><li>网络插件下载并安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#如果网络故障也可直接在网站中下载好文件后上传至虚拟机中（自行翻墙）</span><br><span class="line">wget https://github.com/flannel-io/flannel/releases/download/v0.24.3/kube-flannel.yml</span><br><span class="line">#执行</span><br><span class="line">kubectl apply -f kube-flannel.yml</span><br><span class="line">#或者（两者的结果是一样的，只是执行工作原理不一样，想深究的可以自行查阅资料）</span><br><span class="line">kubectl create -f kube-flannel.yml</span><br></pre></td></tr></table></figure><ul><li>再次查看节点状态全部变为 Ready</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line">#如果查看节点没有变成ready，先等个几分钟，因为网络传输需要一定的时间。等几分钟后如果还是NotReady，再根据报错原因查找解决方案</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;k8s集群搭建教程（使用cri-docker+flannel）&lt;/h1&gt;
&lt;h2 id=&quot;1-准备工作（所有节点）&quot;&gt;1. 准备工作（所有节点）&lt;/h2&gt;
&lt;h3 id=&quot;1-1-系统环境-我是没配置也部署成功了，可以先部署，如果失败了再回来进行系统环境优化&quot;&gt;1.1 系</summary>
      
    
    
    
    
    <category term="kubernetes" scheme="http://example.com/tags/kubernetes/"/>
    
    <category term="go" scheme="http://example.com/tags/go/"/>
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>区块链环境配置教程</title>
    <link href="http://example.com/2024/04/29/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    <id>http://example.com/2024/04/29/%E5%8C%BA%E5%9D%97%E9%93%BE/</id>
    <published>2024-04-29T07:31:07.000Z</published>
    <updated>2024-05-21T05:41:45.913Z</updated>
    
    <content type="html"><![CDATA[<h1>区块链环境配置教程</h1><h2 id="一、安装CentOS">一、安装CentOS</h2><p>本例中采用虚拟化软件VMware Workstation安装CentOS 7.3（最小安装minimal）。实际应用中，单个服务器一般都设定为单一功能，比如Web服务器，数据库服务器，LDAP服务器等，或者多台服务器分布式部署云计算组件如Hadoop等，单个服务器只需要操作系统的基本功能，因此CentOS最小化安装符合需求，如果需要额外的功能，可以在使用过程中增加。云服务提供商（例如阿里云）提供的云服务器操作系统一般是CentOS minimal。</p><p>本例CentOS安装环境如下：</p><p>主机（Host Machine）：CPU 8核，内存16G，操作系统Windows 10专业版64位</p><p>虚拟化软件：VMware Workstation 14 pro</p><p>到 <a class="link"   href="https://www.centos.org/" >https://www.centos.org/<i class="fas fa-external-link-alt"></i></a> 下载安装包，本例是CentOS-7-x86_64-DVD-1804.iso</p><h3 id="1-1-安装前VMware设置">1.1 安装前VMware设置</h3><p>1、在VMware菜单“编辑-首选项”可以设置虚拟机默认放置的目录，应选择有足够空间的硬盘分区。本例中是 D:\MyVM（根据自己喜好设置虚拟机存放的位置）</p><p>2、创建虚拟机采用“自定义(高级)”配置，虚拟机名称(自己设置)。</p><p>3、选择安装来源时，载入CentOS的ISO后，VMware会自动识别出操作系统类型和版本。也可以选择“稍后安装操作系统”不采用简易安装，而采用手动安装。</p><p>4、为虚机分配处理器1个，内核数量2个，2G/4G（根据自己电脑内存大小）内存。本例中的这个虚机作为实验环境，将安装多种应用，因此配置较高。实验用虚机一般1核2G内存即可，可租用的轻量级云服务器一般是1核1G内存。实际应用虚机则根据需要分配资源，计算单元则对CPU要求较高，内容服务器则对内存要求较高。</p><p>5、使用NAT网络（默认选项），虚机没有与主机同级的IP地址。</p><p>桥接，NAT，仅主机模式，三者的简要区别如下：</p><p>（1）桥接：虚机与主机在网络中地位一样，虚机拥有与主机同级的独立IP地址。</p><p>（2）NAT：虚机共享主机的IP地址访问Internet，同一个主机中的各个虚机在同一网段中，可互相访问。外部无法直接访问虚机，但可通过主机的转接访问虚机。</p><p>（3）仅主机模式：同一主机中的各个虚机可互相访问，虚机无法访问Internet，外部也无法访问虚机。</p><p>6、I/O类型：默认LSI Logic，磁盘类型：默认SCSI，选择磁盘：创建新虚拟磁盘。</p><p>7、分配20G虚拟磁盘空间，存为单独文件（非默认选项）。</p><p>8、指定虚机磁盘文件，保持默认。</p><p>9、开始安装时，可能会提示要更改BIOS设置以支持64位操作系统之类的，按照提示修改主机BIOS设置，再回来安装。</p><p>注意：一般新的电脑无需设置自动支持64位虚拟化，有些电脑需要在BIOS里设置以支持64位虚拟化，有些更旧的电脑完全不支持64位虚拟化，则无法在VMware里安装64位的操作系统。</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135320528.8kzwg8l089.jpg"  alt="image-20240509135320528"></p><p>设置完成如上图，点击“完成”开始安装。</p><h3 id="1-2-安装过程">1.2 安装过程</h3><p>注意：安装过程中，鼠标点击虚机界面即可进入虚机操作，组合键ctrl + alt 可使鼠标返回主机。在VMware Workstation窗口的左下角会有提示。</p><p>1、安装过程与在真实裸机上安装一样，初始界面按键“i”选择“Install CentOS”，然后回车进入安装过程。</p><p>2、选择语言：保持默认 English - Englisth (United States)</p><p>3、如下图所示，设置安装选项：</p><p>Date &amp; Time 选到 Asian / Shanghai</p><p>Language Support 可以把中文，简体中文(中国)选上</p><p>Software Selection 保持Minimal Install不变</p><p>Installation Destination 需要点开，默认是自动配置磁盘，不需要修改，直接点“Done”按钮返回即可，黄色的感叹号才会消失，此界面右下角“Begin Installation”按钮才会亮起。</p><p>Network &amp; Hostname 点进去，如果有显示有线网络ens33之类的，打开ON</p><p>KDUMP可以设置为Disabled，保持默认也可以。</p><p>设置完成后，点击右下角“Begin Installation”按钮开始安装。</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135414360.92py4tmdt3.jpg"  alt="image-20240509135414360"></p><p>4、安装的过程中给root用户设置密码（4geT%not），非必需。如果密码太弱，需点击两次确定才能完成操作。</p><p>新建一个用户admin（密码d00r%Key），勾选“Make this user administrator”，今后的常用登录用户。如果密码太弱，需点击两次确定才能完成操作。</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135433610.13ll9r79t4.jpg"  alt="image-20240509135433610"></p><p>安装完成，点击“Reboot”重新启动。</p><p>5、系统是最小化安装，没有GUI，默认以admin登录，安装完成。</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135445611.7awz9x387e.jpg"  alt="image-20240509135445611"></p><p>非必需：虚机屏幕有时候不匹配VMware的窗口，需要拉动窗口的滚动条才能看见全部的虚机屏幕内容。从VMware菜单“电源 - 关闭客户机”，然后再开启此虚机，可解决这个问题。</p><h3 id="1-3-忘记密码">1.3 忘记密码</h3><p><strong>下面是CentOS 7的root密码修改</strong></p><p>开机按esc</p><p>选择CentOS Linux (3.10.0-693…)     按 e 键</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135456058.7i075cpdmy.jpg"  alt="image-20240509135456058"></p><p><code> </code>光标移动到 linux 16 开头的行，找到 ro 改为 rw init=sysroot/bin/sh</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135507355.2krqbibltj.jpg"  alt="image-20240509135507355"></p><p>按 Ctrl+x 执行</p><p>进入后输 chroot /sysroot</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135527785.92py4tml2w.jpg"  alt="image-20240509135527785"></p><p>输入 passwd</p><p>根据提示输入2次新密码</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135545983.8z6c73tid5.jpg"  alt="image-20240509135545983"></p><p>完成后输入  touch /.autorelabel  更新系统信息</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135557209.9kfztenynv.jpg"  alt="image-20240509135557209"></p><p>exit</p><p>reboot 重启</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135609834.7sn0yi4lrw.jpg"  alt="image-20240509135609834"></p><p>重启过程慢，耐心等等</p><p>重启后用新密码登录</p><h2 id="二、基本系统设置">二、基本系统设置</h2><h3 id="2-1-安装后设置">2.1 安装后设置</h3><h4 id="2-1-1-关于用户">2.1.1 关于用户</h4><p>目前系统里有2个用户，root是超级管理员，一般不用此账号登录；admin是常用用户，系统管理员。</p><p>系统提示符为 # 表明用户为root，提示符为$ 表明用户为其他用户。</p><p>每个用户都有自己的主目录，以 ~表示，root用户是 /root，其他用户是 /home/用户名。例如admin输入命令 cd ~ 则会进入其主目录 /home/admin</p><p>admin需要执行root权限的命令时，可以用 sudo 临时获得权限，也可以用 su 切换身份为root。</p><p>使用sudo时，需要输入admin用户自己的密码，使用 su时，需要输入root用户的密码，使用“sudo su”则可以使用admin自己的密码切换到root用户身份，在root用户没有设置密码时，这个方法很好用。</p><p>1、使用sudo不需要输入密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo visudo -f /etc/sudoers</span><br></pre></td></tr></table></figure><p>如下修改内容，在 %wheel ALL=(ALL) ALL 前加注释符#，去掉 %wheel ALL=(ALL) NOPASSWD:ALL 前的注释符。保存退出就行了。</p><p>这是针对wheel这个组的设置，这个组的成员都不需要输入密码就可以使用sudo，admin是wheel组的成员。</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509135652374.8s34bo7cxp.jpg"  alt="image-20240509135652374"></p><p>传统修改方法是在 root ALL=(ALL) ALL 下面增加一行 admin ALL=(ALL) NOPASSWD:ALL 但在这里会被 %wheel ALL=(ALL) ALL 覆盖掉。原因是在安装过程中，创建 admin用户时使其成为管理员，便成为了 wheel组的成员。系统只允许wheel组的用户来执行“su”命令登录为root用户，而让其他组的用户即使执行“su”、输入了正确的root密码，也无法登录为root用户。</p><p>用visudo编辑sudoers文件是正确的做法。有些做法是增加文件sudoers的写权限，用vi修改，再去掉其写权限。可能会出现文件权限错乱，如下恢复sudoers文件的正确属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chmod 0440 /etc/sudoers</span><br></pre></td></tr></table></figure><h4 id="2-2-2-连接网络，更新系统">2.2.2 连接网络，更新系统</h4><p>查找配置网络文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls /etc/sysconfig/network-scripts/</span><br></pre></td></tr></table></figure><p>看到有形如 ifcfg-ens33 或 ifcfg-eth0 这样的文件，修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><p>把 ONBOOT=no 改成 yes 即可，保存退出。</p><p>重启网络服务，应用设置，就可以联网了。安装时选择的是NAT方式，因此是使用主机的IP地址连接到Internet。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart network.service</span><br></pre></td></tr></table></figure><p>更新系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum update</span><br></pre></td></tr></table></figure><p>首先会查询要更新哪些内容，询问是否OK，确认后开始更新。</p><p>安装必备系统组件perl，gcc，kernel-devel，wget，yum-utils，net-tools</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum -y install perl gcc kernel-devel wget</span><br><span class="line"></span><br><span class="line">$ sudo yum -y install yum-utils</span><br><span class="line"></span><br><span class="line">$ sudo yum -y install net-tools</span><br><span class="line"></span><br><span class="line">yum install -y install unzip zip</span><br></pre></td></tr></table></figure><p>更新完毕后，可以重新启动一下系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl reboot</span><br></pre></td></tr></table></figure><h3 id="2-2-网络设置">2.2 网络设置</h3><p>安装net-tools包，以便后续使用ifconfig命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum -y install net-tools</span><br></pre></td></tr></table></figure><h2 id="三、区块链的环境搭建">三、区块链的环境搭建</h2><p>搭建Hyperledger fabric环境</p><p>搭建过程</p><h3 id="3-1-Go安装。（官网地址：https-golang-google-cn-dl-）">3.1 Go安装。（官网地址：<a class="link"   href="https://golang.google.cn/dl/%20" >https://golang.google.cn/dl/ <i class="fas fa-external-link-alt"></i></a>）</h3><ol><li><strong>下载安装包</strong></li></ol><p>箭头所指地址+自己系统所对应的版本。使用wget命令。</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509140638680.8s34bo7cxs.jpg"  alt="image-20240509140638680"></p><p>以我自己安装的为例，图中椭圆框中即为我所安装版本。</p><p>所以下载命令为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://golang.google.cn/dl/go1.18.5.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>解压安装包到指定路径</strong></li></ol><p>将下载的压缩包通过下面命令进行解压，一定注意大小写（否则可能导致安装失败）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf go1.18.5.linux-amd64.tar.gz -C /usr/local/</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>设置环境变量</strong></li></ol><p>使用vi /etc/profile 编辑profile文件。</p><p>添加以下内容到profile 文件中（gopath应提前创建好，或者配置完成后别忘了创建）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#go setting</span><br><span class="line"></span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line"></span><br><span class="line">export GOPATH=/usr/local/gopath</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:$GOROOT/bin</span><br></pre></td></tr></table></figure><p>保存并退出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile 使文件立即生效。</span><br></pre></td></tr></table></figure><p>在gopath路径下使用mkdir创建三个文件，即mkdir src bin pkg。</p><p>其中bin存放编译后的可执行文件；pkg存放编译后的包文件；src存放项目源文件。</p><p>查看是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure><p>编辑hello.go文件测试.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/local/gopath/src/hello.go</span><br></pre></td></tr></table></figure><p>在hello.go中编写如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="string">`    `</span>fmt.Println(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存并退出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run hello.go</span><br></pre></td></tr></table></figure><p>显示Hello world!正确执行。截止到此，安装GO语言环境完成。</p><h3 id="3-2-docker安装">3.2 <a class="link"   href="https://so.csdn.net/so/search?q=docker&amp;spm=1001.2101.3001.7020" >docker<i class="fas fa-external-link-alt"></i></a>安装</h3><p>第一种方式：<strong>curl -fsSL <a class="link"   href="https://get.docker.com/" >https://get.docker.com/<i class="fas fa-external-link-alt"></i></a> | sh 比较快捷，但是可能会因为无法访问国外的镜像而出错。如果不能安装，就是用第二种方式。</strong></p><p><strong>第二种方式（推荐）：</strong></p><p><strong>如果以前安装过docker，请先卸载或删除所有依赖关系。如果没装过跳过此过程。</strong></p><p>yum list installed | grep docker；查看所有安装的docker程序</p><p>yum -y remove+要删除程序的完整名称（如果安装的比较多，这个过程可能有点麻烦）</p><p>rm -rf /var/lib/docker：删除镜像容器。</p><p>输入Docker version出现如下图所示字样，表明已卸载干净。</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509141144124.4n7izka6v5.jpg"  alt="image-20240509141144124"></p><p><strong>然后开始安装docker</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo #安装阿里镜像源</span><br><span class="line"></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin #（默认安装的是最新版的）</span><br></pre></td></tr></table></figure><p>查看版本信息</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509141520528.syrgls8xu.jpg"  alt="image-20240509141520528"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker #启动docker</span><br><span class="line">systemctl enable docker #将docker设置为开机自启，以便后续操作不会出错。</span><br></pre></td></tr></table></figure><p>安装docker-compose</p><p>1.下载docker-compose</p><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -SL https://github.com/docker/compose/releases/download/v2.11.2/docker-compose-linux-x86\_64 -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>也可以下载别的版本，只需将命令行中v2.11.2换成自己想装的版本即可。</p><p>2. 给docker-compose文件添加可执行权限</p><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>3. 添加软连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><p>4.查看版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Docker-compose version</span><br></pre></td></tr></table></figure><h3 id="3-3-nodejs安装">3.3 nodejs安装</h3><p>去这个网站<a class="link"   href="https://nodejs.org/dist/" >https://nodejs.org/dist/<i class="fas fa-external-link-alt"></i></a>找到自己想安装的版本。</p><p>复制整个网址，使用以下命令下载，例如我下载的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Wget https://nodejs.org/dist/v16.14.1/node-v16.14.1-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><p>2.解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf node-v16.14.1-linux-x64.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line">cd /usr/local</span><br><span class="line"></span><br><span class="line">mv node-v10.19.0-linux-x64/ nodejs</span><br></pre></td></tr></table></figure><p>3.vi /etc/profile 增加环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export NODE\_HOME=/usr/local/nodejs</span><br><span class="line"></span><br><span class="line">export PATH=$NODE\_HOME/bin:$PATH</span><br></pre></td></tr></table></figure><p>保存并退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile 使文件立即生效。</span><br></pre></td></tr></table></figure><p>4. 查看版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line"></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><p>5.设置淘宝镜像源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>6.which node、 whereis node   查看有无 node、npm等命令</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509141730932.73trehh2ro.jpg"  alt="image-20240509141730932"></p><p>7. 安装全局 pm2</p><p>npm install -g pm2</p><p>8. 查看 有无 pm2命令 ， pm2 版本</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509141742607.4jnx1uh45h.jpg"  alt="image-20240509141742607"></p><p><strong>下载源代码</strong><br>因为要用到git，所以需要先安装git。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p><strong>下载相关镜像文件。</strong></p><p>在想要安装<a class="link"   href="https://so.csdn.net/so/search?q=fabric&amp;spm=1001.2101.3001.7020" >fabric<i class="fas fa-external-link-alt"></i></a>的目录下运行以下命令来下载fabric （时间可能会有点久）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/hyperledger/fabric.git</span><br></pre></td></tr></table></figure><p>（git clone克隆时出现fatal: unable to access ‘<a class="link"   href="https://github.com/%5C*%5C*%E2%80%98:" >https://github.com/\*\*‘:<i class="fas fa-external-link-alt"></i></a> TCP connection resset by peer）</p><p>解决方法：</p><p>##发生这种情况是git设置了代理，取消代理即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@hya ~]# git config --global --unset http.proxy</span><br><span class="line"></span><br><span class="line">[root@hya ~]# git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>下载完成后会得到一个fabric文件夹，进入fabric/scripts目录可以看到一个bootstrap.sh脚本（注意刚开始是没有fabric-samples这个文件夹的，是执行脚本后生成的）</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509142109592.1seutrv03q.jpg"  alt="image-20240509142109592"></p><p>直接执行bootstrap.sh脚本，就会自动进行fabric相关镜像的下载 （时间有点久，如果出现长时间停顿，可能需要重启虚拟机后重新执行脚本）</p><p>当相关镜像全部下载完成后，会自动罗列出下载的内容</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509142120044.8ad2n35zd4.jpg"  alt="image-20240509142120044"></p><p><strong>构建网络</strong></p><p>Fabric 1.x.x版本的应该是进入fabric/scripts/fabric-samples/first-network/</p><p>Fabric2.x.x版本的进入fabric/scripts/fabric-samples/test-network/</p><p>执行以下命令，开启测试网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./network.sh down</span><br><span class="line"></span><br><span class="line">./network.sh up</span><br></pre></td></tr></table></figure><p>创建信道</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network.sh createChannel</span><br></pre></td></tr></table></figure><p>下载go依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GO111MODULE=on</span><br><span class="line"></span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><p>查看是否切换成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env</span><br></pre></td></tr></table></figure><p>进入链码所在路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/go/fabric/scripts/fabric-samples/asset-transfer-basic/chaincode-go</span><br></pre></td></tr></table></figure><p>下载依赖：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod vendor</span><br></pre></td></tr></table></figure><h2 id="四、在通道上启动链码chaincode（智能合约）">四、在通道上启动链码chaincode（智能合约）</h2><p>切换回 /fabric-samples/test-network 目录：</p><p>./network.sh deployCC -ccn basic -ccp …/asset-transfer-basic/chaincode-go -ccl go</p><p>如果出现下图所示情况：</p><p><img   src="https://dettry.github.io/picx-images-hosting/linux/image-20240509142221121.4jnx1uh45l.jpg"  alt="image-20240509142221121"></p><p>解决方案</p><p><strong>下载并安装EPEL</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh epel-release-latest-7.noarch.rpm</span><br></pre></td></tr></table></figure><p># 检查是否已添加至源列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist</span><br></pre></td></tr></table></figure><p><strong>安装jq</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install jq</span><br></pre></td></tr></table></figure><h2 id="五、与网络交互">五、与网络交互</h2><p>首先确保自己位于test-network目录下。</p><p>进入CLI容器，进行invoke交互，需要几行命令设置CLI的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$&#123;PWD&#125;/../bin:$PATH</span><br><span class="line">export FABRIC\_CFG\_PATH=$PWD/../config/</span><br></pre></td></tr></table></figure><p>先设置为org1的环境变量进行交互：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export CORE\_PEER\_TLS\_ENABLED=true</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_LOCALMSPID=&quot;Org1MSP&quot;</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_TLS\_ROOTCERT\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_ADDRESS=localhost:7051</span><br></pre></td></tr></table></figure><p>用下面的命令初始化账本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot; -c &#x27;&#123;&quot;function&quot;:&quot;InitLedger&quot;,&quot;Args&quot;:[]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>使用下面的命令查找账本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -C mychannel -n basic -c &#x27;&#123;&quot;Args&quot;:[&quot;GetAllAssets&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>通过命令改变一笔资产的所有者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot; -c &#x27;&#123;&quot;function&quot;:&quot;TransferAsset&quot;,&quot;Args&quot;:[&quot;asset6&quot;,&quot;Christopher&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure><h2 id="六、关闭测试网络">六、关闭测试网络</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network.sh down</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;区块链环境配置教程&lt;/h1&gt;
&lt;h2 id=&quot;一、安装CentOS&quot;&gt;一、安装CentOS&lt;/h2&gt;
&lt;p&gt;本例中采用虚拟化软件VMware Workstation安装CentOS 7.3（最小安装minimal）。实际应用中，单个服务器一般都设定为单一功能，比如Web服</summary>
      
    
    
    
    <category term="Linux专题" scheme="http://example.com/categories/Linux%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="区块链" scheme="http://example.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://example.com/2024/03/16/Java_language/"/>
    <id>http://example.com/2024/03/16/Java_language/</id>
    <published>2024-03-16T08:39:36.000Z</published>
    <updated>2024-05-21T05:44:19.668Z</updated>
    
    <content type="html"><![CDATA[<h1>Java语言</h1><h2 id="1-语言基础">1. 语言基础</h2><h3 id="1-1-基础语法">1.1 基础语法</h3><ul><li><strong>数据类型</strong></li></ul><p>数据类型分为两类：基本数据类型、引用数据类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Java中的基本数据类型只有**四类八种**</span><br><span class="line"></span><br><span class="line">整数型：byte、short、int、long</span><br><span class="line"></span><br><span class="line">short占两字节</span><br><span class="line"></span><br><span class="line">int 占用四个字节</span><br><span class="line"></span><br><span class="line">long 占用八个字节</span><br></pre></td></tr></table></figure><ul><li>浮点型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">浮点型有两种：float、double</span><br><span class="line">float占用四位，double占用八位</span><br></pre></td></tr></table></figure><ul><li>字符型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符型为char，char类型是一个单一的16位Unicode字符。</span><br></pre></td></tr></table></figure><ul><li>布尔型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> The boolean data type has only two possible values: true and false. Use this data type for simple flags that track true/false conditions. This data type represents one bit of information, but its &quot;size&quot; isn&#x27;t something that&#x27;s precisely defined.</span><br><span class="line"> </span><br><span class="line">翻译：布尔数据类型只有两种可能的值：true和false。使用这个数据类型用于追踪true/false状况的简单标识。这个数据类型表示1bit的信息，但是它的”大小“没有被精确定义。</span><br></pre></td></tr></table></figure><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20231228151136962.2krqbfmbzc.jpg"  alt="image-20231228151136962"></p><ul><li>引用数据类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只要不是基本数据类型就是引用数据类型。</span><br></pre></td></tr></table></figure><ul><li>自动类型转换（隐式）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">转换规则： 数据范围必须是**从小到大**，即由小的转换成大的，自动转换。</span><br></pre></td></tr></table></figure><ul><li>强制类型转换（显式）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">注意事项：</span><br><span class="line">1. 强制类型转换一般不推荐使用，因为有可能发生精度损失、数据溢出。 </span><br><span class="line">2. byte/short/char这三种类型都可以发生数学运算，例如加法“+”。</span><br><span class="line">3. byte/short/char这三种类型在运算的时候都会首先提升成为int类型，然后再计算。</span><br><span class="line">例：byte+byte-&gt;int+int-&gt;int</span><br><span class="line">4. boolean类型不能发生数据类型转换</span><br></pre></td></tr></table></figure><ul><li>运算符的优先级</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单目（一元）&gt;算术运算符&gt;移位&gt;关系&gt;位&gt;条件(三元)&gt;赋值</span><br></pre></td></tr></table></figure><ul><li><strong>基础语法</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 大小写敏感： Java是大小写敏感的语言，例如Hello和hello是不同的，这其实就是Java的字符串表示方式。</span><br><span class="line">2. 类名：类名使用 UpperCamelCase 风格，但以下情形例外： DO / BO / DTO / VO / AO /</span><br><span class="line">PO / UID 等。</span><br><span class="line">正例： ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion</span><br><span class="line">反例： forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion</span><br><span class="line">3. 包名：包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用</span><br><span class="line">单数形式，但是类名如果有复数含义，类名可以使用复数形式。</span><br><span class="line">正例： 应用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils（此规则参考 spring 的框架结构）</span><br><span class="line">4. 方法名、变量名、参数名：都统一使用 lowerCamelCase 风格</span><br><span class="line">正例： localValue / getHttpMessage() / inputUserId</span><br></pre></td></tr></table></figure><ul><li><strong>方法</strong></li><li>构造方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">作用：用来创建对象的</span><br><span class="line">注意事项：</span><br><span class="line">1. 构造方法的名称必须和所在类的名称完全一样，就连大小写也要一样</span><br><span class="line">2. 构造方法不要写返回值类型，连void都不写</span><br><span class="line">3. 构造方法不能return一个具体的返回值</span><br><span class="line">4. 如果没有编写任何构造方法，那么编译器会默认分配一个构造方法</span><br><span class="line">5. 一旦编写了一个构造方法，那么编译器就不会再分配任何构造方法</span><br></pre></td></tr></table></figure><ul><li>静态方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态方法又叫类方法。</span><br></pre></td></tr></table></figure><ul><li>非静态方法（成员方法）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法之间的调用注意事项：</span><br><span class="line">1. 同类型的方法之间可以直接调用</span><br><span class="line">2. 静态方法调用非静态方法需要先new一个对象，然后通过对象进行调用。</span><br><span class="line">3. 非静态方法可以直接调用静态方法。</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>方法重载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">多个方法的名称相同，但是参数列表不一样。</span><br><span class="line">方法重载与下列因素相关：</span><br><span class="line">1. 参数个数不同</span><br><span class="line">2. 参数类型不同</span><br><span class="line">3. 多参数类型顺序不同</span><br><span class="line">方法重载与下列因素无关：</span><br><span class="line">1. 与参数名称无关</span><br><span class="line">2. 与方法的返回值类型无关</span><br><span class="line">3. </span><br></pre></td></tr></table></figure><ul><li>参数传递机制</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java的参数传递机制都是：值传递</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>数组</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Java的内存划分成为5个部分：</span><br><span class="line">1. 栈内存（stack）：存放的都是方法中的局部变量。  方法的运行一定要在栈中运行。</span><br><span class="line">         局部变量： 方法的参数、方法&#123;&#125;内部的变量</span><br><span class="line">2. 堆内存（heap）: 凡是new出来的东西都在堆当中。</span><br><span class="line">        堆内存里面的东西都有一个地址值：16进制</span><br><span class="line">        堆内存中的数据都有默认值。规则：</span><br><span class="line">                 整数         默认0</span><br><span class="line">                 浮点数       默认0.0</span><br><span class="line">                 字符         默认&#x27;\u0000&#x27;</span><br><span class="line">                 布尔         默认false</span><br><span class="line">                 引用类型      默认null</span><br><span class="line">3. 方法区（）: 存储.class相关信息，包含方法的信息。</span><br><span class="line"></span><br><span class="line">4. 本地方法栈（）： 与操作系统相关</span><br><span class="line">5. 寄存器（）： 与cpu相关</span><br></pre></td></tr></table></figure><h3 id="1-2-面向对象">1.2 面向对象</h3><ul><li><strong>特点</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向对象思想是一种更符合我们思考习惯的思想，它可以将复杂的事情简单化，并将我们从执行者变成指挥者。</span><br></pre></td></tr></table></figure><p><strong>面向对象语言包含三大基本特征：</strong></p><ul><li><p>封装</p><p>就是将一些细节信息隐藏起来，对外界不可见。</p><ol><li>方法就是一种封装</li><li>private关键字也是一种封装</li></ol><p>一旦使用private进行修饰，那么本类当中仍然可以随意访问，但是超出了本类范围之外就不能再直接访问了。</p><p>可以使用getter/setter方法间接访问private成员变量。</p></li><li><p>继承</p></li></ul><p>​        继承是多态的前提，如果没有继承，就没有多态。</p><p>​        继承主要解决的问题就是：<strong>共性抽取</strong></p><pre><code>  **变量重名的解决方法**</code></pre><p>​         局部变量：                    直接写成员变量名</p><p>​         本类的成员变量：          this.成员变量名</p><p>​          父类的成员变量：          super.成员变量名</p><pre><code> **重写（override）**    </code></pre><p>​         概念：在继承关系中，方法的名称一样，参数列表一样。</p><p>​         方法重写（override）：方法名称一样，参数列表也一样。（覆盖重写）</p><p>​         方法重载（overload）：方法名称一样，参数列表不一样。</p><pre><code> **覆盖重写的注意事项：**          1. 必须保证父子类之间的方法名称相同，参数列表也相同。          2. 子类方法的权限必须大于等于父类方法的权限修饰符。</code></pre><p>​         public&gt;protected&gt;(default)&gt;private</p><p>​         备注：（default）不是关键字default，而是什么修饰符也不用。</p><p>​<strong>继承关系中，父子类构造方法的访问特点：</strong></p><pre><code>1. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造</code></pre><p>​注意事项：</p><p>​子类必须调用父类构造方法，不写则默认super（），写了则用写的指定的super调用，super只能有一个，还必须是第一个。</p><p>​<strong>Java继承的三大特点</strong></p><ol><li>Java语言是单继承的，即一个类的直接父类只能有唯一一个。</li><li>Java语言可以多级继承。</li><li>一个子类只能有一个父类，但是一个父类可以有多个子类。</li></ol><p>如果父类当中的方法不确定如何进行{}方法体实现，那么这就应该是一个抽象方法。</p><p>抽象类：抽象方法所在的类必须是抽象类才行。在class之前写上abstract即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="comment">//这是一个抽象方法，代表吃东西，但是具体吃什么不确定。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何使用抽象类和抽象方法</strong></p><ol><li><p>不能直接创建new抽象类对象</p></li><li><p>必须用一个子类来继承抽象父类。</p></li><li><p>子类必须覆盖重写抽象父类当中的所有抽象方法。</p><p>覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号</p><ol start="4"><li>创建子类对象进行使用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>多态</li></ul><p>一个对象拥有多种形态，这个就叫对象的多态性。</p><p><strong>代码当中体现多态性，其实就是一句话，父类引用指向子类对象。</strong></p><p>格式：</p><p>父类名称 对象名 = new 子类名称（）；</p><p>或者</p><p>接口名称 对象名 = new  实现类名称（）；</p><p>访问成员变量和方法的规则：</p><p>访问成员方法：等号右边new的谁，优先用谁，没有则向上找。</p><p>直接通过对象名称访问成员变量：等号左边是谁，优先用谁，没有则向上找。</p><p>间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。</p><p><strong>对象的转型</strong></p><ol><li>对象的向上转型，其实就是多态写法：</li></ol><p>格式：父类名称 对象名 = new 子类名称（）；</p><ol start="2"><li>对象的向下转型，其实是一个【还原】的动作</li></ol><p>格式：子类名称 对象名 = （子类名称） 父类对象</p><p>注意事项：</p><ol><li>必须保证对象本来创建的时候就是A,才能向下转型成为A。</li><li>如果创建的对象本来不是A，非要向下转型为A就会报错。</li></ol><p><strong>四种权限修饰符</strong></p><p><strong>内部类</strong></p><ol><li>成员内部类</li><li>局部内部类（包含匿名内部类）</li></ol><p>成员内部类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">      修饰符 class 内部类名称&#123;</span><br><span class="line">      </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">注意：内用外，随意访问； 外用内，需要内部类对象。</span><br></pre></td></tr></table></figure><p>局部内部类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">      修饰符 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">              class 局部内部类名称&#123;</span><br><span class="line">      </span><br><span class="line">             &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类的定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">接口名称 对象名称 =  <span class="keyword">new</span> 接口名称（）&#123;</span><br><span class="line"> 覆盖重写所有抽象方法</span><br><span class="line">&#125;；</span><br><span class="line">注意事项：</span><br><span class="line">    <span class="number">1.</span> 匿名内部类在创建对象的时候只能使用唯一一次</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li><strong>类和对象</strong></li></ul><p><strong>什么是类</strong></p><ul><li>类：是一组相关属性和行为的集合。</li></ul><p>现实中，描述一类事物：</p><ul><li><p>属性：就是该事物的特征信息。（是什么）（成员变量）</p></li><li><p>行为：就是该事物能够做什么。（成员方法）成员方法不要写static关键字。</p></li></ul><p><strong>什么是对象</strong></p><ul><li>对象：是一类事物的具体体香。对象是类的一个实例。</li></ul><p><strong>类与对象的关系</strong></p><ul><li>类是对一类事物的描述，是抽象的。</li><li>对象是一类事物的实例，是具体的。</li><li>类是对象的模板，对象是类的实体。</li></ul><p><strong>成员变量和局部变量的区别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1. 定义的位置不一样</span><br><span class="line">局部变量：在方法的内部</span><br><span class="line">成员变量：在方法的外部，直接写在类当中。</span><br><span class="line"></span><br><span class="line">2. 作用范围不一样</span><br><span class="line">局部变量：只有方法当中才可以使用</span><br><span class="line">成员变量：整个类全可以通用</span><br><span class="line"></span><br><span class="line">3. 默认值不一样</span><br><span class="line">局部变量：没有默认值，如果要想使用，必须手动赋值</span><br><span class="line">成员变量：如果没有赋值，会有默认值，规则和数组一样。</span><br><span class="line"></span><br><span class="line">4. 内存的位置不一样</span><br><span class="line">局部变量：位于栈内存</span><br><span class="line">成员变量：位于堆内存</span><br><span class="line"></span><br><span class="line">5. 生命周期不一样</span><br><span class="line">局部变量：随着方法进栈而生，随着方法出栈而亡</span><br><span class="line">成员变量：随着对象创建而生，随着对象被垃圾回收而亡。</span><br></pre></td></tr></table></figure><ul><li><strong>对象数组</strong></li></ul><p>数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变。</p><ul><li><strong>字符串</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. 字符串的内容不可变</span><br><span class="line">2. 字符串可以共享使用</span><br><span class="line">3. 字符串效果上相当于char[]字符数组，但是底层原理是byte[]字节数组</span><br><span class="line">在堆内存中有一个字符串常量池。</span><br><span class="line">常用方法：</span><br><span class="line">equals</span><br><span class="line">length()</span><br><span class="line">concat:连接字符串</span><br><span class="line">charAt:</span><br><span class="line">indexOf:</span><br></pre></td></tr></table></figure><p>StringBuilder类：字符串缓冲区，可以提高字符串的效率</p><p>常用方法：</p><p>append</p><p>toString</p><ul><li><strong>静态关键字static</strong></li></ul><p>一旦用了static关键字，那么这样的内容不再属于对象自己，</p><p>而是属于类的，所以凡是本类的对象，都共享同一份。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">一旦使用static修饰成员方法，那么就成为了静态方法，静态方法不属于对象，而是属于类的。</span><br><span class="line"></span><br><span class="line">如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。</span><br><span class="line"></span><br><span class="line">如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。</span><br><span class="line"></span><br><span class="line">无论是成员变量还是方法，如果有了static，都推荐使用类名称进行调用。</span><br><span class="line"></span><br><span class="line">静态变量：类名称.静态变量</span><br><span class="line"></span><br><span class="line">静态方法：类名称.静态方法（）</span><br><span class="line"></span><br><span class="line">注意事项：</span><br><span class="line">1. 静态方法当中不能使用this</span><br></pre></td></tr></table></figure><p><strong>静态代码块</strong></p><p>特点：当第一次用到本类时，静态代码块执行唯一的一次。</p><p>静态内容总是优先于非静态，所以静态代码块比构造方法先执行。</p><p>静态代码块的用途：</p><p>用来一次性的对静态成员变量进行赋值。</p><p><strong>Arrays工具类</strong></p><p>toString(数组)：将参数数组变成字符串（按照默认格式：[元素1，元素2,…]）</p><h3 id="1-3-接口">1.3 接口</h3><p>接口就是多个类的公共规范</p><p>接口是一种引用数据类型，最重要的内容就是其中的：<strong>抽象方法</strong>。</p><p>从Java 8开始，接口 里允许定义默认方法。</p><p>备注：接口当中的默认方法可以解决接口升级的问题。</p><p><strong>什么是接口升级？</strong></p><p>就是已经投入使用的接口，想在其中添加新的方法，这时如果直接添加，会导致所有实现该接口的类报错，但是使用default默认方法可以解决此问题，并且该方法也可以被其他接口实现类覆盖重写。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Java 9 开始，接口中允许定义私有方法。</p><ol><li>普通私有方法，解决多个默认方法之间的重复代码问题</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>静态私有方法：解决多个静态方法之间重复代码问题</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> 返回值类型 方法名称（参数列表）&#123;</span><br><span class="line"></span><br><span class="line">方法体</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口与接口之间是多继承的。</p><ul><li><strong>日期时间类</strong></li></ul><p>date</p><ul><li><strong>DateFormat类</strong></li></ul><p>日期时间格式化类</p><ul><li><strong>包装类</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基本类型             对应的包装类</span><br><span class="line"><span class="type">byte</span>                  Byte</span><br><span class="line"><span class="type">short</span>                 Short</span><br><span class="line"><span class="type">int</span>                   Integer</span><br><span class="line"><span class="type">long</span>                  Long</span><br><span class="line"><span class="type">float</span>                 Float</span><br><span class="line"><span class="type">double</span>                Double</span><br><span class="line"><span class="type">char</span>                  Character</span><br><span class="line"><span class="type">boolean</span>               Boolean</span><br></pre></td></tr></table></figure><p><strong>装箱与拆箱</strong></p><p>装箱：从基本类型转换成对应的包装类对象</p><p>拆箱：从包装类对象转换为对应的基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i= Integer.valueOf(<span class="number">4</span>)<span class="comment">//装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> i.intValue();<span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><h3 id="1-4-容器">1.4 容器</h3><ul><li>collection集合</li></ul><p>**集合：**集合是Java中提供的一种容器，可以用来存储多个数据。</p><p>集合和数组既然都是容器，它们有啥区别？</p><ol><li>数组的长度是固定的，集合的长度是可变的</li><li>数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象，而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。</li></ol><p><strong>常用共性方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>: 添加对象</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>: 清空集合</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(E e)</span>: 把给定对象从当前集合删除</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E e)</span>: 判断当前集合中是否包含给定的对象</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>:</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>: 返回集合中的元素个数</span><br><span class="line"><span class="keyword">public</span> Object[] toArray(): 把集合中的元素，存储到数组中</span><br></pre></td></tr></table></figure><p><strong>List</strong></p><ol><li>有序的集合（存储和取出元素顺序相同）</li><li>允许存储重复的元素</li><li>有索引，可以使用普通的for循环遍历</li></ol><ul><li>ArrayList（查询快，增删慢）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>常用方法：</p><p>add,get,remove,size</p><ul><li>LinkedList（查询慢，增删快）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;E&gt; linked = <span class="keyword">new</span> <span class="title class_">LinkerdList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><strong>Set</strong></p><ol><li>不允许存储重复的元素</li><li>没有索引</li></ol><ul><li>HashSet</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;E&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><ol><li>是一个无序集合</li><li>底层是一个哈希表结构</li></ol><p>哈希值：是一个十进制的整数，由系统随机给出（就是对象的地址值，是一个逻辑i地址，是模拟出来的地址，不是数据实际存储的物理地址）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>:获取对象的哈希码值</span><br></pre></td></tr></table></figure><p>哈希表（查询快）</p><p>哈希表的结构，jdk1.8之后：</p><ol><li>哈希表=数组+链表；</li><li>哈希表=数组+红黑树；</li></ol><ul><li>LInkedHashSet</li></ul><p>LInkedHashSet特点：</p><p>底层是一个哈希表+链表，多了一条链表（记录元素的存储顺序），保证元素有序。</p><p><strong>HashSet存储自定义类型元素</strong></p><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。</p><p><strong>可变参数</strong></p><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（数据类型...变量名）&#123;</span><br><span class="line">&#125;</span><br><span class="line">实例</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>... arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">注意事项</span><br><span class="line">    <span class="number">1.</span> 一个方法的参数列表只能有一个可变参数</span><br><span class="line">    <span class="number">2.</span> 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾。</span><br><span class="line">可变参数的特殊（终极）写法</span><br><span class="line">    实例</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Object...obj)</span>&#123;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Map</strong></p><p>特点</p><ol><li>map集合是一个双列集合，一个元素包含两个值（key:value）</li><li>map集合中的元素，key和value的数据类型可以相同，也可以不同</li><li>map中key是不允许重复的，value可以重复</li><li>map中的key和value一一对应</li></ol><ul><li>HashMap（初始长度16）</li></ul><p>特点：</p><ol><li>HashMap集合底层是哈希表：查询速度特别快</li><li>hashMap是一个无序集合，存储和取出元素的顺序可能不一致</li></ol><ul><li>LinkedHashMap</li></ul><p>特点：</p><ol><li>底层是哈希表+链表（保证迭代的顺序）</li><li>是一个有序的集合，存储和取出元素的顺序是一致的</li></ol><ul><li>TreeMap</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>Collections工具类</p><p>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? <span class="built_in">super</span> T&gt; c, T... elements)</span> ：往集合中添加一些元素</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list)</span> ：打乱集合顺序</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list)</span></span><br><span class="line">：将集合按照默认规则排序</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span>：将集合中元素按照指定规则排序</span><br></pre></td></tr></table></figure><h4 id="1-4-1-Iterator迭代器">1.4.1 Iterator迭代器</h4><p>迭代：Collection集合元素的通用获取方式。</p><p>迭代器的使用案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       Collection&lt;String&gt; coll = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       coll.add(<span class="string">&quot;姚明&quot;</span>);</span><br><span class="line">       coll.add(<span class="string">&quot;科比&quot;</span>);</span><br><span class="line">       coll.add(<span class="string">&quot;詹姆斯&quot;</span>);</span><br><span class="line">       coll.add(<span class="string">&quot;库里&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取一个迭代器对象</span></span><br><span class="line">       Iterator&lt;String&gt; iterator = coll.iterator();</span><br><span class="line">       <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">           <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">           System.out.println(s);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-异常">1.5 异常</h3><p><strong>异常</strong>：指的是程序在执行过程中，出现非正常的情况，最终导致JVM非正常停止。</p><p>Java处理异常的方式是中断处理。</p><p><strong>异常产生的过程解析</strong></p><h4 id="1-5-1-异常的处理">1.5.1 异常的处理</h4><p>Java异常处理的五个关键字：try、catch、finally、throw、throws</p><ol><li>抛出异常throw</li></ol><p>throw作用：</p><p>可以使用throw关键字在指定的方法中抛出指定的异常</p><p>使用格式：</p><p>throw new xxxException（“异常产生的原因”）;</p><p>注意：</p><ol><li>throw关键字必须写在方法的内部</li><li>throw后面new的对象必须是Exception或者Exception的子类对象</li><li>throw抛出指定的异常对象，我们必须处理这个异常对象，要么用throws，要么try…catch</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以后（工作中）我们首先必须对方法传递过来的参数进行合法性校验</span><br><span class="line"></span><br><span class="line">如果参数不合法，那么我们就必须使用抛出异常的方式，告知方法的调用者，传递的参数有问题。</span><br></pre></td></tr></table></figure><ol start="2"><li>声明异常throws（异常处理的第一种方式）</li></ol><p>作用：</p><p>当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象</p><p>可以使用throws处理异常对象，把异常声明抛出给方法的调用者处理（自己不处理，谁调用我让谁处理），最终交给jvm处理–&gt;中断异常</p><p>使用格式：在方法声明时使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数列表） <span class="keyword">throws</span> xxxException,.....&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">xxxException</span>(<span class="string">&quot;产生原因&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">注意</span><br><span class="line">    <span class="number">1.</span> <span class="keyword">throws</span> 必须写在方法声明处</span><br><span class="line">    <span class="number">2.</span> <span class="keyword">throws</span> 后边声明的异常必须是Exception或者其子类</span><br><span class="line">    <span class="number">3.</span> 方法内部如果抛出多个异常，那么<span class="keyword">throws</span>后边也必须声明多个异常</span><br><span class="line">        如果多个异常之间有子父类关系，直接声明父类异常就行</span><br><span class="line">    <span class="number">4.</span> 调用了一个声明抛出异常的方法，我们就必须处理声明的异常</span><br><span class="line">        要么继续使用 <span class="keyword">throws</span> 声明抛出，交给方法的调用者处理，最终交给 JVM</span><br><span class="line">        要么 <span class="keyword">try</span>....<span class="keyword">catch</span> 自己处理。</span><br></pre></td></tr></table></figure><ol start="3"><li>捕获异常try…catch（异常处理的第二种方式）</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">catch</span>(xxxException e)&#123; <span class="comment">//try中抛出什么异常，catch就定义什么异常对象，用来接收这个异常。</span></span><br><span class="line">    一般在工作中，会把异常的信息记录在一个日志中。</span><br><span class="line">&#125;</span><br><span class="line">注意</span><br><span class="line">    <span class="number">1.</span> <span class="keyword">try</span> 可能会抛出多个异常，那么可以使用多个 <span class="keyword">catch</span> 来处理</span><br><span class="line">    <span class="number">2.</span> 如果 <span class="keyword">try</span> 中产生了异常，就会执行 <span class="keyword">catch</span> 中的异常处理逻辑，执行完后，继续执行 <span class="keyword">try</span>...<span class="keyword">catch</span> 后的代码。</span><br><span class="line">    <span class="number">3.</span> 如果 <span class="keyword">try</span> 中没有异常，就不执行 <span class="keyword">catch</span> ，执行完 <span class="keyword">try</span> 后，继续执行 <span class="keyword">try</span>...<span class="keyword">catch</span> 后的代码。</span><br></pre></td></tr></table></figure><h3 id="1-6-泛型">1.6 泛型</h3><p>泛型是一种未知的数据类型，当我们不知道使用什么数据类型的时候，可以使用泛型。</p><p><strong>泛型的数据类型在创建对象的时候确定</strong></p><p>创建集合对象，使用泛型</p><p>好处：</p><ol><li>避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型</li><li>把运行期异常（代码运行之后抛出的异常）提升到了编译期</li></ol><p>弊端：</p><ol><li>泛型是什么类型，只能存储什么类型的数据</li></ol><p><strong>含有泛型的方法</strong></p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表（使用泛型）)&#123;</span><br><span class="line">        方法体;</span><br><span class="line">    &#125;</span><br><span class="line">实例</span><br><span class="line"> <span class="keyword">public</span> &lt;H&gt; <span class="keyword">void</span> <span class="title function_">genericMethod</span><span class="params">(H h)</span>&#123;</span><br><span class="line">        System.out.println(h);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>含有泛型的接口</strong></p><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">第一种使用方式，定义接口的实现类，实现接口并指定接口的泛型</span><br><span class="line">实例</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Scanner</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;String&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">第二种使用方式：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt;&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span>;   </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;&#123;</span><br><span class="line">       <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>泛型通配符</p><p>​？：代表任意的数据类型</p><p>使用方式：</p><p>​不能创建对象使用</p><p>​  只能作为方法的参数使用</p><p><strong>高级使用-受限泛型（要求只要看源码能看懂就行）</strong></p><p>作用：限定数据的使用类型。</p><p>泛型的上限限定：？extends E 代表使用的泛型只能是E类型的子类/本身</p><p>泛型的下限限定：？super E 代表使用的泛型只能是E类型的父类/本身</p><ul><li><strong>数据结构</strong></li></ul><p><strong>红黑树</strong></p><p>特点：</p><ol><li>趋近于平衡树，查询的速度非常快，查询叶子节点最大次数和最小次数不能超过2倍</li></ol><p>约束：</p><ol><li>节点可以是红色或者黑色</li><li>根节点是黑色</li><li>叶子节点（空节点）是黑色</li><li>每个红色的节点的子节点都是黑色</li><li>任何一个节点到其每一个叶子节点所有路径上的黑色节点数相等</li></ol><h3 id="1-7-反射">1.7 反射</h3><p><strong>作用</strong></p><ol><li>基本作用：可以得到一个类的全部成分然后操作</li><li>可以破坏封装性</li><li>最重要的用途是：适合做Java的框架，基本上，主流的框架都会基于反射设计出一些通用的功能。</li></ol><h3 id="1-8-注解">1.8 注解</h3><p>就是Java的特殊标记，作用是：让其他程序根据注解信息来决定怎么执行该程序</p><p><strong>特殊属性名：value</strong></p><p>如果注解只有一个value属性，使用注解时，value名称可以不写。</p><p><strong>元注解</strong></p><p>修饰注解的注解</p><p>常见的元注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="meta">@Target</span></span><br><span class="line">    作用：声明被修饰的注解只能在哪些位置使用</span><br><span class="line">    @<span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line">    <span class="number">1.</span> TYPE,类，接口</span><br><span class="line">    <span class="number">2.</span> FIELD， 成员变量</span><br><span class="line">    <span class="number">3.</span> METHOD，成员方法</span><br><span class="line">    .....</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span> <span class="meta">@Retention</span></span><br><span class="line">    作用：声明注解的保留周期</span><br><span class="line">    <span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">    <span class="number">1.</span> SOURCE</span><br><span class="line">    只作用在源码阶段，字节码文件中不存在</span><br><span class="line">    <span class="number">3.</span>RUNTIME（开发常用）</span><br><span class="line">    一直保留到运行阶段</span><br></pre></td></tr></table></figure><p><strong>注解的解析</strong></p><p>要解析谁上面的注解，就先拿到谁</p><h3 id="1-9-I-O">1.9 I/O</h3><p>重点：记住三个单词</p><p>​          file： 文件</p><p>​          directory：文件夹/目录</p><p>​          path： 路径</p><p><strong>递归</strong>：指在当前方法内部调用自己的这种现象</p><p>递归的分类：</p><ol><li>直接递归</li></ol><p>​        方法自身调用自身</p><ol start="2"><li>间接递归</li></ol><p>​A方法调用B方法，B方法调用C方法，C方法调用A方法。</p><p><strong>Java中的I/O操作主要是指使用Java.io包下的内容，进行输入、输出操作。</strong></p><ol><li>字节流（InputStream/OutputStream）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream </span><br><span class="line">    文件字节输入流</span><br><span class="line">    作用：把硬盘文件中的数据，读取到内存中使用</span><br><span class="line">FileOutputStream</span><br><span class="line">    文件字节输出流</span><br><span class="line">    作用：把内存中的数据写入到硬盘的文件中</span><br></pre></td></tr></table></figure><p>使用字节流读取中文文件容易产生乱码</p><p>一个中文</p><p>​GBK： 占用两个字节</p><pre><code>UTF-8：占用三个字节</code></pre><ol start="2"><li>字符流（reader/writer）</li></ol><p>作用：读取字符信息，一次读取一个字符</p><p>jdk7的新特性</p><p>在try后边可以增加一个()，在括号中可以定义流对象</p><p>那么这个流对象的作用域就在try中有效</p><p>try中的代码执行完毕会自动把流对象释放，不用写finally</p><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(定义流对象；定义流对象...)&#123;</span><br><span class="line">    可能会产生异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类变量 变量名)&#123;</span><br><span class="line">    异常的处理逻辑</span><br><span class="line">&#125;</span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoll</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(<span class="comment">//创建一个字符输出流对象，构造方法绑定需要写入的目的地</span></span><br><span class="line">            <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;test.txt&quot;</span>,<span class="literal">true</span>);) &#123;</span><br><span class="line"><span class="comment">//            //创建一个字符输入流对象，构造方法绑定需要读取的数据源</span></span><br><span class="line"><span class="comment">//            FileReader fr = new FileReader(&quot;test.txt&quot;);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                fw.append(<span class="string">&quot;helloword&quot;</span>+i+<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>缓冲流</li></ol><p>作用：提高文件读写的效率</p><p>字节缓冲流（BufferedInputStream &amp; BufferedOutputStream）</p><p>字符缓冲流（BufferedReader &amp; BufferWriter）</p><ol start="4"><li>转换流(OutputStreamWriter &amp; InputStreamReader)</li></ol><p>作用：能够转换编码</p><ol start="5"><li>序列化流(ObjectOutputStream &amp; ObjectInputStream )</li></ol><p>作用：能够持久化存储对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Serializable 接口也叫标记型接口</span><br><span class="line">    要进行序列化和反序列化的类必须实现 Serializable 接口，就会给类添加一个标记</span><br><span class="line">    当我们进行序列化和反序列化的时候，就会检测是否有这个标记</span><br><span class="line">    有：就可以序列化和反系列化</span><br><span class="line">    没有：就会抛出 NotSerializableException 异常</span><br><span class="line"> <span class="keyword">transient</span>关键字：瞬态关键字</span><br><span class="line">    被 <span class="keyword">transient</span> 修饰的成员变量，不能被序列化</span><br><span class="line">问题：</span><br><span class="line">    每次修改类的定义，都会给class文件生成一个新的序列号，这样在进行序列化与反序列化时就会报invalidClassException异常</span><br><span class="line">解决方法：</span><br><span class="line">    无论是否对类的定义进行修改，都不重新生成新的序列号</span><br><span class="line">    可以手动给类添加一个序列号</span><br><span class="line">  格式：</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">6161825669842708241L</span>;</span><br><span class="line">等号后面的常量可以为任意值，不可改变。</span><br></pre></td></tr></table></figure><p>序列化集合</p><p>当我们想在文件中保存多个对象的时候，可以把多个对象存储到一个集合中，然后对集合进行序列化和反序列化。</p><h2 id="2-JVM">2. JVM</h2><h3 id="2-1-类加载机制">2.1 类加载机制</h3><h3 id="2-2-字节码执行机制">2.2 字节码执行机制</h3><h3 id="2-3-jvm内存模型">2.3 jvm内存模型</h3><h3 id="2-4-gc垃圾回收机制">2.4 gc垃圾回收机制</h3><h3 id="2-5-jvm性能监控和故障定位">2.5 jvm性能监控和故障定位</h3><h3 id="2-6-jvm调优">2.6 jvm调优</h3><h2 id="3-并发-多线程">3. 并发/多线程</h2><h3 id="3-1-并发编程">3.1 并发编程</h3><h3 id="3-2-多线程">3.2 多线程</h3><p>创建线程的步骤：</p><ol><li>声明Thread类的子类</li><li>重写Thread类的run方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置线程任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">创建线程的第二种方式</span><br><span class="line">    <span class="number">1.</span> 创建一个runnable接口的实现类</span><br><span class="line">    <span class="number">2.</span> 在实现类中重写runnable接口的run方法，设置线程任务 </span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableThreadImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//设置线程任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableThreaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多态写法</span></span><br><span class="line">        <span class="comment">//Runnable runnable= new MyRunnableThreadImpl();</span></span><br><span class="line">        MyRunnableThreadImpl runnable= <span class="keyword">new</span> <span class="title class_">MyRunnableThreadImpl</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;---&gt;&quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">使用runnable接口创建多线程的好处：</span><br><span class="line">    <span class="number">1.</span> 避免了单继承的局限性</span><br><span class="line">    <span class="number">2.</span> 增强了程序的扩展性，降低了程序的耦合性（解耦）</span><br></pre></td></tr></table></figure><p><strong>Thread类中的常用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span>：获取；当前线程名</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> ：此线程开始执行，Java虚拟机调用此线程的run方法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span>:使当前线程暂停指定多长时间</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>：线程要执行的任务都在此处编写</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> Thread <span class="title function_">currentThread</span><span class="params">()</span>：返回当前正在执行的线程对象的引用</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p><strong>并发与并行</strong></p><p>并发：指两个或多个事件在同一时间段内发生</p><p>并行：指两个或多个事件在同一时刻发生（同时发生）</p><p><strong>线程与进程</strong></p><p>进程： 是指一个内存中运行的应用程序</p><p>线程： 是指进程中的一个执行单元，负责当前进程中程序的执行，一个进程至少有一个线程。一个进程中是可以有多个线程的，这个应用程序称为<strong>多线程程序</strong>。</p><p><strong>线程调度</strong></p><p>分时调度： 所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间。</p><p>抢占式调度： 优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个（线程随机性），Java使用的为抢占式调度。</p><h4 id="3-2-1-线程安全">3.2.1 线程安全</h4><p><strong>解决线程安全问题</strong></p><ol><li>同步代码块: synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</li></ol><p>使用synchronized关键字容易产生死锁（如何解决，在后续内容中写）</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>（同步锁（锁对象））&#123;</span><br><span class="line">    <span class="comment">//需要同步操作的代码即：可能出现线程安全问题的代码（访问了共享数据的代码）</span></span><br><span class="line">&#125;</span><br><span class="line">同步锁（锁对象）注意事项：</span><br><span class="line">    <span class="number">1.</span> 同步代码块中的锁对象，可以使用任意的对象</span><br><span class="line">    <span class="number">2.</span> 必须保证多个线程使用的锁对象是同一个</span><br><span class="line">    <span class="number">3.</span> 锁对象作用：</span><br><span class="line">             把同步代码块锁住，只让一个线程在同步代码块中执行</span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableThreadImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//同步锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>同步方法</li></ol><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值类型 参数名（参数列表）&#123;</span><br><span class="line">    <span class="comment">//需要同步操作的代码即：可能出现线程安全问题的代码（访问了共享数据的代码）</span></span><br><span class="line">&#125;</span><br><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnableThreadImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                payTicket();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//同步方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">payTicket</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;--&gt;&quot;</span>+ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">**静态同步方法**</span><br><span class="line"></span><br><span class="line">锁对象是谁？</span><br><span class="line"></span><br><span class="line">不能是<span class="built_in">this</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>是创建对象之后产生的，静态方法优先于对象</span><br><span class="line"></span><br><span class="line">静态方法的锁对象是本类的class属性--&gt;class文件对象(反射)</span><br></pre></td></tr></table></figure><ol start="3"><li>Lock锁</li></ol><p>Lock接口中的方法：</p><p>void lock() 获取锁</p><p>void unlock() 释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableImpl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">   <span class="type">Lock</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            l.lock();</span><br><span class="line">            <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    l.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-线程池">3.3 线程池</h3><p>线程池： 其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作。</p><h3 id="3-4-锁">3.4 锁</h3><h3 id="3-5-并发容器">3.5 并发容器</h3><h3 id="3-6-原子类">3.6 原子类</h3><h3 id="3-7-juc并发工具类">3.7 juc并发工具类</h3><h2 id="4-网络编程">4. 网络编程</h2><p>软件结构：c/s，b/s</p><h3 id="4-1-网络通信">4.1 网络通信</h3><p><strong>网络通信协议的分类</strong></p><ol><li>UDP：用户数据报协议</li></ol><p>特点：消耗资源小，通信效率高</p><p>通常用于音频、视频和普通数据的传输例如视频会议都使用udp协议，即使丢一两个数据包，也不会对接受结果产生太大影响。</p><ol start="2"><li>TCP：传输控制协议</li></ol><p>是面向连接的通信协议。在TCP连接中必须要明确客户端与服务器端，每次连接的创建都需要经过“三次握手”。</p><p>特点：传输安全</p><p>网络编程的三要素</p><ol><li>协议</li><li>IP地址</li></ol><ul><li>IPv4：32位的二进制数，通常被分为4个字节，表示a.b.c.d的形式，每个字节的范围都是0~255.</li><li>IPv6：</li></ul><ol start="3"><li>端口号</li></ol><h3 id="4-2-函数式接口">4.2 函数式接口</h3><p>函数式接口：只有一个抽象方法的接口，称之为函数式接口</p><p>当然接口中可以包含其他的方法（默认，静态，私有）</p><p><strong>Lambda表达式</strong></p><p>函数式编程思想：</p><p>​只要能获取到结果，谁去做，怎么做的都不重要，重视的是结果，不重视过程。</p><p>使用前提</p><ol><li>使用Lambda必须具有接口，且要求接口中有且只有一个抽象方法。</li><li>使用Lambda必须具有上下文推断</li></ol><p>有些场景的代码执行后结果不一定被使用，从而造成<strong>性能浪费</strong>。而Lambda表达式是延迟执行的，正好可以作为解决方案，提升性能。</p><p><strong>常用函数式接口</strong></p><ol><li>Supplier接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Supplier:被称为生产型接口，指定接口的泛型是什么类型，那么接口中的get方法就会生产什么类型的数据</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个方法，用于获取int类型数组中元素的最大值，</span></span><br><span class="line"><span class="comment">     * 方法的参数传递Supplier接口，泛型使用Integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sup</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">100</span>,<span class="number">0</span>,-<span class="number">50</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> max= getMax(()-&gt;&#123;</span><br><span class="line">           <span class="type">int</span> temp= arr[<span class="number">0</span>];</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">               <span class="keyword">if</span> (temp&lt;arr[i])&#123;</span><br><span class="line">                   temp=arr[i];</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Consumer接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Consumer:消费型接口，泛型执行什么类型，就可以使用accept方法使用什么类型的数据</span><br><span class="line">至于怎么消费（使用），需要自定义（输出，计算）</span><br><span class="line">默认方法：andThen</span><br><span class="line">作用：将两个Consumer接口连接到一起，然后再对数据进行消费（使用）</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String[] arr, Consumer&lt;String&gt; con1,Consumer&lt;String&gt; con2)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : arr) &#123;</span><br><span class="line">            con1.andThen(con2).accept(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr =  &#123;<span class="string">&quot;迪丽热巴，女&quot;</span>,<span class="string">&quot;古力娜扎，女&quot;</span>,<span class="string">&quot;沈腾，男&quot;</span>&#125;;</span><br><span class="line">        printMessage(arr,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot;姓名：&quot;</span>+s.split(<span class="string">&quot;，&quot;</span>)[<span class="number">0</span>]+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                &#125;,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;性别：&quot;</span>+s.split(<span class="string">&quot;，&quot;</span>)[<span class="number">1</span>]+<span class="string">&quot;。&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ol start="3"><li>Predicate接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">对某种类型的数据进行判断，从而得到一个Boolean值结果。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoPredicate</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个方法，方法的参数传递一个字符串</span></span><br><span class="line"><span class="comment">     * 传递两个Predicate接口</span></span><br><span class="line"><span class="comment">     * 一个用于判断字符串的长度大于5</span></span><br><span class="line"><span class="comment">     * 一个用于判断字符串中是否包含a</span></span><br><span class="line"><span class="comment">     * 两个条件必须同时满足</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2)</span>&#123;</span><br><span class="line">          <span class="comment">// return pre1.test(s) &amp;&amp; pre2.test(s);</span></span><br><span class="line">        <span class="comment">//return pre1.test(s) || pre2.test(s);</span></span><br><span class="line"><span class="comment">//        return pre1.or(pre2).test(s);</span></span><br><span class="line">          <span class="keyword">return</span> pre1.and(pre2).test(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> <span class="string">&quot;Hello world!!&quot;</span>;</span><br><span class="line">       <span class="type">boolean</span> b= checkString(test,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> s.length()&gt;<span class="number">5</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                (s)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> s.contains(<span class="string">&quot;H&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-Stream流">4.3 Stream流</h3><p>IO流和Stream流是两个概念，IO流是用于数据的读写，而Stream流可以用来对集合和数组进行简化操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java语言&lt;/h1&gt;
&lt;h2 id=&quot;1-语言基础&quot;&gt;1. 语言基础&lt;/h2&gt;
&lt;h3 id=&quot;1-1-基础语法&quot;&gt;1.1 基础语法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据类型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据类型分为两类：基本数据类型、引用</summary>
      
    
    
    
    <category term="Java开发专题" scheme="http://example.com/categories/Java%E5%BC%80%E5%8F%91%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>个人博客搭建笔记</title>
    <link href="http://example.com/2023/12/24/my_blog_build_note/"/>
    <id>http://example.com/2023/12/24/my_blog_build_note/</id>
    <published>2023-12-24T11:50:36.000Z</published>
    <updated>2024-05-07T09:03:55.335Z</updated>
    
    <content type="html"><![CDATA[<h1>个人博客搭建笔记</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</span><br></pre></td></tr></table></figure><h2 id="一、环境准备">一、环境准备</h2><h3 id="1-安装node-js">1. 安装node.js</h3><p><a class="link"   href="https://blog.csdn.net/fenijd/article/details/135206205" >node.js的安装与配置教程-CSDN博客<i class="fas fa-external-link-alt"></i></a></p><h3 id="2-安装git">2. 安装git</h3><p><a class="link"   href="https://blog.csdn.net/fenijd/article/details/135226795" >Git 2.43.0的安装教程-CSDN博客<i class="fas fa-external-link-alt"></i></a></p><h2 id="二、搭建博客">二、搭建博客</h2><ol><li>以管理员的身份运行cmd输入命令下载hexo框架</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>出现下图所示样式表示下载成功，因为我已经下载过了，所以没有什么变化。图中的警告先不用管，不影响使用。警告的大致意思是fsevents不支持windows平台。因为它是适用于苹果系统的，但是我们下载框架的时候是全都下载的，所以会出现这个警告。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227150126542.widbihaic.jpg"  alt="image-20231227150126542"></p><p>在自己想要存放博客的文件夹下新建一个文件，名字自拟。从本文件夹直接进入cmd，或者先进入cmd，cd该文件夹下。输入命令初始化一个博客。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>初始化中断，根据提示可以看到是在安装依赖时出了问题。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227151412779.6pnbkt4qr9.jpg"  alt="image-20231227151412779"></p><p>原因是因为国内现在无法百分百概率访问Github，因此npm可能会下载失败；也有可能是因为文件权限的问题。总之按照提示再重新操作一遍以管理员的身份运行cmd并进入新建的博客文件夹下，使用hexo init命令后居然成功了。如下图所示，出现 Start blogging with Hexo 字样代表成功。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227155115602.9nzlobd088.jpg"  alt="image-20231227155115602"></p><p>初始化完成后使用命令就可以访问自己的博客了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>按住ctrl键鼠标左键点击即可跳转到博客网页。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227162536967.2doid9lf8s.jpg"  alt="image-20231227162536967"></p><p>博客网站如下图所示，默认会新建一篇文章。至此，博客的搭建工作告一段落。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227162048417.1lbmvj4tij.jpg"  alt="image20231227162048417"></p><h2 id="三、将博客部署到Github上">三、将博客部署到Github上</h2><p>使用命令安装一键将博客推送至GitHub上的插件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>使用管理员的身份运行cmd输入命令后安装成功。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227163832468.widbihai5.jpg"  alt="image-20231227163832468"></p><p>在Github上创建一个个人仓库用于存放博客，首先登录GitHub，在个人仓库中找到新建仓库点击进入。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227164915105.2yy5zkfvji.jpg"  alt="image-20231227164915105"></p><p><a class="link"   href="http://xn--GitHub-vy7ix4bc60aha959yqwbp5vuz0e7ie5n9c.github.io" >仓库名为自己的GitHub用户名.github.io<i class="fas fa-external-link-alt"></i></a>，如图所示，一定要这样设置，不然会不起作用。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227165146140.6m3pn3bo1b.jpg"  alt="image-20231227165146140"></p><p>描述根据自己需要填写，然后点击创建仓库。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227165414068.39kzspv3ow.jpg"  alt="image-20231227165414068"></p><p>创建完成后会自动跳转到你刚才创建的仓库内，在仓库中找到如下图所示位置，点击复制，后面修改博客的配置文件时会用到。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227165755277.7p3rhtrht.jpg"  alt="image-20231227165755277"></p><p>使用vscode或者记事本打开_config.yml找到deploy修改其中的内容为，保存并退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  repo: <span class="string">&#x27;https://github.com/dettry/dettry.github.io.git&#x27;</span> #为你创建的GitHub个人仓库地址</span><br><span class="line">  branch: <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure><p>进入cmd中cd到博客存放的路径下执行如下命令就可以将博客部署到GitHub上了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>记得在推送之前先开启梯子，然后将代理服务器打开。</p><p>首先右键网络选择网络和Internet设置。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227175624944.5xag32o50z.jpg"  alt="image-20231227175624944"></p><p>找到使用代理服务器，点击编辑将代理服务器打开然后保存。</p><p><img   src="https://dettry.github.io/picx-images-hosting/my_blog_build_note/image-20231227175530411.7i072jlche.jpg"  alt="image-20231227175530411"></p><p>最后推送成功后在地址栏输入dettry.github.io即可访问自己的博客。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;个人博客搭建笔记&lt;/h1&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Linux笔记</title>
    <link href="http://example.com/2023/05/05/Linux_note/"/>
    <id>http://example.com/2023/05/05/Linux_note/</id>
    <published>2023-05-05T06:12:45.000Z</published>
    <updated>2024-05-21T05:45:04.482Z</updated>
    
    <content type="html"><![CDATA[<h1>Linux笔记</h1><h2 id="1-目录结构">1. 目录结构</h2><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20230401113335627.8kzwg6uwmd.jpg"  alt="image-20230401113335627"></p><h2 id="2-常用命令">2. 常用命令</h2><h3 id="2-1-ls">2.1 ls</h3><p>对应英文：list</p><p>作用： 查看当前目录下的内容</p><p>ll 对应 ls -l</p><p>作用： 查看当前目录下的所有内容和每个文件的详细信息。</p><h3 id="2-2-pwd">2.2 pwd</h3><p>对应英文：print work directory</p><p>作用： 查看当前所在目录</p><h3 id="2-3-touch">2.3 touch</h3><p>touch [文件名]</p><p>作用：如果文件不存在，新建文件</p><h3 id="2-4-cd">2.4 cd</h3><p>~表示当前用户的home目录</p><p>.表示当前所在目录</p><p>…表示当前目录位置的上级目录</p><h3 id="2-5-cat">2.5 cat</h3><p>cat [-n] fileName</p><p>-n: 由1开始对所有输出的行数编号</p><p>cat /etc/profile   查看/etc目录下的profile文件内容</p><h3 id="2-6-rmdir">2.6 rmdir</h3><p>作用：删除空目录</p><p>语法：rmdir [-p] dirName</p><p>-p: 当子目录被删除后使父目录为空目录的话，则一并删除</p><p>rm</p><p>作用：删除文件或者目录</p><p>语法：rm [-rf] name</p><p>-r:将目录及目录中的所有文件（目录）逐一删除，即递归删除</p><p>-f: 无需确认直接删除</p><h3 id="2-7-tar">2.7 tar</h3><p>作用：对文件进行打包、解包、压缩、解压</p><p>语法：tar [-zcxvf] fileName [files]</p><p>包文件后缀为.tar表示只是完成了打包，并没有压缩</p><p>包文件后缀为.tar.gz表示打包的同时还进行了压缩</p><p>说明：</p><p>-z: z代表gzip，通过gzip命令处理文件，gzip可以对文件压缩或者解压</p><p>-c: c代表的是create，即创建新的包文件</p><p>-x: x代表的是extract，实现从包文件中还原文件</p><p>-v: v代表的是verbose,显示命令的执行过程</p><p>-f: f代表的是file ,用于指定包文件的名称</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Linux笔记&lt;/h1&gt;
&lt;h2 id=&quot;1-目录结构&quot;&gt;1. 目录结构&lt;/h2&gt;
&lt;p&gt;&lt;img   src=&quot;https://dettry.github.io/picx-images-hosting/Java/image-20230401113335627.8kzwg</summary>
      
    
    
    
    <category term="Linux专题" scheme="http://example.com/categories/Linux%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Java笔记</title>
    <link href="http://example.com/2023/05/05/Java_note/"/>
    <id>http://example.com/2023/05/05/Java_note/</id>
    <published>2023-05-05T06:11:45.000Z</published>
    <updated>2024-05-21T05:44:12.365Z</updated>
    
    <content type="html"><![CDATA[<h1>Java笔记</h1><h2 id="基础篇">基础篇</h2><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221112111329540.1vygre2xdd.jpg"  alt="image-20221112111329540"></p><h3 id="java语言概述">java语言概述</h3><h4 id="整体概述">整体概述</h4><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221115162358155.70a5go2yyo.jpg"  alt="image-20221115162358155"></p><h4 id="java语言的特点">java语言的特点</h4><p>特点一：面向对象</p><p>两概三特：类、对象；封装、继承、多态；</p><p>特点二：健壮性</p><p>去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等）</p><p>特点三：跨平台性</p><p>原理：先安装一个JVM虚拟机，然后由JVM负责JAVA程序在该系统上运行。</p><p>Java核心机制</p><p>Java虚拟机：对于不同的平台有不同的虚拟机；</p><p>垃圾回收机制：</p><h4 id="注释">注释</h4><p>单行和多行注释与c语言注释相同</p><p>文档注释：JAVA所特有</p><p>格式：/**  */</p><p>作用：注释的内容可以被jdk提供的工具javadoc所解析，生成网页形式的程序说明文档。</p><h4 id="java-API文档">java API文档</h4><p>英文版：版本8</p><p>中文版：版本6</p><h3 id="Java基本语法">Java基本语法</h3><h4 id="保留字">保留字</h4><p>goto、const，java没有赋予其特殊含义，但在命名时尽量避开。</p><h4 id="标识符">标识符</h4><p>凡是可以自己起的名字都叫标识符。e.g：变量名、类名等等</p><p>命名规范</p><p>包名：多个单词组成时所有字母都小写</p><p>类名、接口名：多单词组成时，所有单词首字母大写</p><p>变量名、方法名：多单词组成时，第一个单词首字母小写，从第二个单词开始首字母大写。</p><p>常量名：所有字母都大写，多单词时，每个单词用下划线连接。</p><h4 id="变量的类型">变量的类型</h4><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221116165948252.361dxpl4w1.jpg"  alt="image-20221116165948252"></p><h4 id="变量运算规则的两种特殊情况">变量运算规则的两种特殊情况</h4><p>定义long型变量：long len=78899786676l/L;</p><p>定义float型变量：float len=12.3f/F;</p><p>但现实经常使用double型变量，精度更高。</p><p>整型常量默认类型：int</p><p>浮点型常量默认类型：double</p><h4 id="算数运算符">算数运算符</h4><p>+、-、*、/、++、–、%</p><h4 id="赋值运算符">赋值运算符</h4><p>=</p><p>扩展运算符:+=、-=、*=、/+、%=</p><h4 id="比较运算符">比较运算符</h4><p>基本与c语言一样。</p><p>instanceof:检查是否是类的对象。</p><h2 id="进阶篇">进阶篇</h2><h3 id="SpringBoot">SpringBoot</h3><p><strong>开发以后所用技术：mybatis+druid+远程服务器，别使用lombok进行开发</strong>。</p><h4 id="基础篇-2">基础篇</h4><h5 id="1-parent">1. parent</h5><p>将以前spring开发时所需要配置的pom 文件进行整合，方便管理。</p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221125191759218.7ljt2yzuti.jpg"  alt="image-20221125191759218"></p><p><strong>小结</strong></p><ol><li><p>开发springBoot程序要继承spring-boot-starter-parent</p></li><li><p>spring-boot-starter-parent中定义了若干个依赖管理（不是具体的坐标，只是把你要用的版本管理好，而没提供具体的坐标）</p></li><li><p>继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突（做版本的统一化管理)</p></li><li><p>继承parent的形式也可以采用引入依赖的形式实现效果</p></li></ol><h5 id="2-starter">2. starter</h5><p><strong>starter</strong></p><p>​1. SpringBoot中常见项目名称，定义了当前项目使用的所有依赖坐标 ，以达到<strong>减少依赖配置</strong>的目的</p><p><strong>parent</strong></p><pre><code>1. 所有SpringBoot项目要继承的项目，定义了若干个坐标版本号（依赖管理，而非依赖），以达到减少依赖冲突的目的1. spring-boot-starter-parent各版本间存在着诸多坐标版本不同</code></pre><p><strong>实际开发</strong></p><ol><li><p>使用任意坐标时，仅书写GAV中的G和A，V由SpringBoot提供，除非SpringBoot未提供对应版本V</p></li><li><p>如发生坐标错误，再指定Version（要小心版本冲突)</p></li></ol><p><strong>小结</strong></p><ol><li>开发springBoot程序需要导入坐标时通常导入对应的starter</li><li>每个不同的starter根据功能不同，通常包含多个依赖坐标</li><li>使用starter可以实现快速配置的效果，达到简化配置的目的</li></ol><h5 id="3-引导类">3. 引导类</h5><p>下图即为引导类</p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221126100829179.4jnx1qxvc9.jpg"  alt="image-20221126100829179"></p><p>无论是做spring程序还是做springmvc的程序，最后都会运行出来一个spring容器的对象。所有对象都以bean的形式交给spring容器管理。</p><p>SpringBoot的引导类是Boot工程的执行入口，运行main方法就可以启动项目</p><p>SpringBoot工程运行后初始化Spring容器，扫描引导类所在包加载bean</p><p><strong>得到bean的方式有四种：</strong></p><ol><li>以类型的形式（即class）</li><li></li></ol><h5 id="4-辅助功能">4. 辅助功能</h5><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221126135325136.5q78aco423.jpg"  alt="image-20221126135325136"></p><blockquote><p>内置服务器：</p><p>tomcat(默认)</p><p>jetty</p><p>undertow</p></blockquote><p><strong>小结</strong></p><ol><li>内嵌Tomcat服务器是SpringBoot辅助功能之一</li><li>内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理</li><li>变更内嵌服务器思想是去除现有服务器，添加全新的服务器</li></ol><h5 id="5-Rest风格开发入门案例">5. Rest风格开发入门案例</h5><h6 id="1-以前的开发">1.以前的开发</h6><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221127170845847.54xko1u3yh.jpg"  alt="image-20221127170845847"></p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221127171423014.4jnx1r08ol.jpg"  alt="image-20221127171423014"></p><h6 id="2-接受参数的三种方式">2. 接受参数的三种方式</h6><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221127171256707.45hwhnugj.jpg"  alt="image-20221127171256707"></p><h6 id="3-现在的开发">3.现在的开发</h6><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221127203229053.2h84dp1nna.jpg"  alt="image-20221127203229053"></p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221127203519136.41xvd5yv3c.jpg"  alt="image-20221127203519136"></p><h5 id="6-boot配置">6. boot配置</h5><h6 id="6-1-准备工作">6.1 准备工作</h6><p>模板的制作</p><ol><li>在工作空间中复制对应工程，并修改工程名称</li><li>删除与Idea相关配置文件，仅保留src目录与pom. xml文件</li><li>修改pom.xml文件中的artifactId与新工程/模块名相同</li><li>删除name标签（可选)</li><li>保留备份工程供后期使用</li></ol><h6 id="6-2-属性配置">6.2 属性配置</h6><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221128170828876.7i07598i5n.jpg"  alt="image-20221128170828876"></p><ol><li><p>SpringBoot提供了3种配置文件的格式<br>properties (传统格式/默认格式)<br>yml（主流格式)<br>yaml</p></li><li><p>配置文件间的加载优先级<br>properties (最高)</p><p>yml（常用）</p><p>yaml(最低)</p></li><li><p>不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留</p></li></ol><p>yaml或者yml自动提示功能消失解决方案</p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221128172557083.4xucsm8jjk.jpg"  alt="image-20221128172557083"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yaml书写格式：</span><br><span class="line"></span><br><span class="line">注意属性名冒号后面与数据之间有一个空格</span><br></pre></td></tr></table></figure><p>读取数据</p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221128203619298.5q78addq5h.jpg"  alt="image-20221128203619298"></p><h5 id="7-整合第三方技术">7. 整合第三方技术</h5><ol><li><p><strong>整合junit小结</strong></p><ul><li><p>导入测试对应的starter(如果是自己手工创建的话)</p></li><li><p>测试类使用@SpringBootTest修饰</p></li><li><p>使用自动装配的形式添加要测试的对象</p></li><li><p>测试类如果存在于引导类所在包或子包中无需指定引导类</p></li><li><p>测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类</p></li></ul></li><li><p><strong>整合mybatis小结</strong></p><ul><li><p>勾选MyBatis技术，也就是导入MyBatis对应的starter</p></li><li><p>数据库连接相关信息转换成配置</p></li><li><p>数据库sQL映射需要添加@Mapper被容器识别到</p><pre><code>springboot的版本过低导致的问题处理</code></pre></li></ul></li></ol><p>​2.1 MySQL 8.X驱动强制要求设置时区</p><p>​修改url，添加serverTimezone设定</p><p>​修改MySQL数据库配置（略)</p><p>​2.2 驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver</p><blockquote><p>boot整合东西分为三个部分:</p><ol><li>导入对应的start</li><li>做相应的配置</li><li>直接使用对应的技术进行开发</li></ol></blockquote><ol start="3"><li><strong>整合mybatis-plus小结</strong> <img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221130093255881.4uaqux41pj.jpg"  alt="image-20221130093255881"></li></ol><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221130093312809.2ruy6v5go9.jpg"  alt="image-20221130093312809"></p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20221130093423735.ibxndkq6z.jpg"  alt="image-20221130093423735"></p><ol start="4"><li><strong>整合Druid(即数据源)</strong></li></ol><p>​      <img   src="https://dettry.github.io/picx-images-hosting/Java/image-20230222161204003.101zbym3rx.jpg"  alt="image-20230222161204003"></p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20230228145538979.7awz9uaxlq.jpg"  alt="image-20230228145538979"></p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20230228145621901.17577e897l.jpg"  alt="image-20230228145621901"></p><p><img   src="https://dettry.github.io/picx-images-hosting/Java/image-20230228150602825.1aot541bxf.jpg"  alt="image-20230228150602825"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Java笔记&lt;/h1&gt;
&lt;h2 id=&quot;基础篇&quot;&gt;基础篇&lt;/h2&gt;
&lt;p&gt;&lt;img   src=&quot;https://dettry.github.io/picx-images-hosting/Java/image-20221112111329540.1vygre2xdd.jp</summary>
      
    
    
    
    <category term="Java开发专题" scheme="http://example.com/categories/Java%E5%BC%80%E5%8F%91%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Vmware安装Debian 11</title>
    <link href="http://example.com/2022/12/29/Vmware_install_Debian11/"/>
    <id>http://example.com/2022/12/29/Vmware_install_Debian11/</id>
    <published>2022-12-29T01:24:07.000Z</published>
    <updated>2024-05-21T06:08:26.317Z</updated>
    
    <content type="html"><![CDATA[<h1>一、Vmware安装Debian 11</h1><p>本例中采用虚拟化软件VMware Workstation安装Debian 11.5.0（base system安装）。实际应用中，单个服务器一般都设定为单一功能，比如Web服务器，数据库服务器，LDAP服务器等，或者多台服务器分布式部署云计算组件如Hadoop等，单个服务器只需要操作系统的基本功能，因此Debian最小化安装符合需求，如果需要额外的功能，可以在使用过程中增加。</p><p>本例Debian安装环境如下：</p><p>主机（Host Machine）：CPU 20核，内存32G，操作系统Windows 11家庭版64位</p><p>虚拟化软件：VMware Workstation 16 pro</p><p>到 <a class="link"   href="https://www.debian.org/" >https://www.debian.org/<i class="fas fa-external-link-alt"></i></a> 下载安装包，本例是debian-11.5.0-amd64-DVD-1.iso</p><h2 id="1-1-安装前Vmware设置"><strong>1.1 安装前Vmware设置</strong></h2><p>1、在VMware菜单“编辑-首选项”可以设置虚拟机默认放置的目录，应选择有足够空间的硬盘分区。本例中是 D:\MyVM</p><p>2、创建虚拟机采用“自定义(高级)”配置，选择安装来源时，载入Debian的ISO后，Vmware无法识别版本，其识别的版本最高是Debian 10.x。<strong>选择“稍后安装操作系统”不采用简易安装，而采用手动安装</strong>。后面“客户机操作系统”选择Linux，下拉框选择Debian 10.x 64位。</p><p>3、虚拟机名称 deb-min，选择 D:\MyVM\deb-min作为存储位置</p><p>4、为虚机分配处理器1个，内核数量1个，2G内存。本例中这个虚拟机实例是作为干净基准系统，具体的应用虚拟机可以克隆这个虚拟机，不用重新安装。分配的CPU核数，内存数在克隆后可以在Vmware里修改。实验用虚机一般1核2G内存即可，可租用的轻量级云服务器一般是1核1G内存。实际虚机则根据需要分配资源，计算单元则对CPU要求较高，内容服务器则对内存要求较高。</p><p>5、使用NAT网络（默认选项），虚机没有与主机同级的IP地址。</p><p>桥接，NAT，仅主机模式，三者的简要区别如下：</p><p>（1）桥接：虚机与主机在网络中地位一样，虚机拥有与主机同级的独立IP地址。</p><p>（2）<strong>NAT：虚机共享主机的IP地址访问Internet，同一个主机中的各个虚机在同一网段中，可互相访问。外部无法直接访问虚机，但可通过主机的转接访问虚机</strong>。</p><p>（3）仅主机模式：同一主机中的各个虚机可互相访问，虚机无法访问Internet，外部也无法访问虚机。</p><p>6、I/O类型：默认LSI Logic，磁盘类型：默认SCSI，选择磁盘：创建新虚拟磁盘。</p><p>7、分配20G虚拟磁盘空间，存为多个文件（默认选项）。没有勾选“立即分配所有磁盘空间”，会稍微影响虚机的速度。</p><p>8、指定虚机磁盘文件，保持默认（拆分成多个文件）。方便虚拟机的拷贝。</p><p>9、开始安装时，可能会提示要更改BIOS设置以支持64位操作系统之类的，按照提示修改主机BIOS设置，再回来安装。</p><p>注意：一般新的电脑无需设置自动支持64位虚拟化，有些电脑需要在BIOS里设置以支持64位虚拟化，有些更旧的电脑完全不支持64位虚拟化，则无法在VMware里安装64位的操作系统。</p><p>如上完成新建虚拟机设置。会出现该虚拟机配置画面，点击“编辑虚拟机设置”，打开对话框，核对硬件配置。如果CD/DVD是自动检测，则选择“使用ISO印象文件”，并选中Debian的安装镜像文件。</p><p>然后点击上图中的“开启此虚拟机”，开始安装。</p><p>开始安装后，窗口下面会出现“我已完成安装”，不要点，等安装完了再点。</p><h2 id="1-2-安装过程"><strong>1.2 安装过程</strong></h2><p>注意：安装过程中，鼠标点击虚机界面即可进入虚机操作，组合键ctrl + alt 可使鼠标返回主机。在VMware Workstation窗口的左下角会有提示。</p><p>1、安装过程与在真实裸机上安装一样，初始界面选择**“Advanced options” - “Graphical expert Install”，非常重要！！！**，然后回车进入安装过程。选择图形expert模式可以设置静态IP地址，最重要的是可以跳过更新，否则要等很长时间，甚至安装失败。</p><p>2、选择安装过程中的语言（也是安装后系统的默认语言）：选择English (English)，下一步，Location选other - Asia - China，然后locales选“en_US.UTF-8”，下一步Additional locales，勾上zh_CN.UTF-8，下一步System locale保持默认en_US.UTF-8</p><p>3、然后blind person，speech synthesizer跳过，进入keyboard，保持默认American Englis，下一步</p><p>4、进入Detect and mount installation media，保持默认勾选usb-storage，下一步，提示找到了，下一步，Installer components，列在这里的都是可选非必须的，直接下一步，</p><p>5、进入Detect network hardware，下一步Configure the network，是否自动配置网络，<strong>选No</strong>，下一步，IP address填192.168.138.9，下一步，Netmask保持默认255.255.255.0，下一步，Gateway修改为192.168.138.2，下一步，Nameserver，默认和网关一样，确认192.168.138.2，下一步，列出所有网络配置，检查确认Yes，下一步，默认3次，下一步。<strong>注意：先到Vmware“虚拟网络编辑器”里看一下IP段，确认是192.168.x.x之后再设置IP地址，包括掩码（一般都是255.255.255.0）</strong>。</p><p>6、配置Hostname：localhost，下一步，Domain name 填localdomain，下一步</p><p>7、设置用户和密码，下一步，Yes - Enable shadow password，Yes - Allow login as root，下一步，设置root密码：4geT%not，下一步</p><p>8、创建新用户：Yes，下一步，全名zadmin，下一步，用户名zadmin，下一步，设置密码d00r%Key，下一步</p><p>9、设置时钟：Yes - Set the clock using NTP，下一步，保持默认，下一步，保持默认Asia/Shanghai，下一步</p><p>10、检测磁盘 - 磁盘分区，默认Guided - use entire disk，下一步，保持默认，下一步，保持默认All files in one partition，下一步，完成分区并写入，下一步，Yes确认写入，下一步</p><p>11、Install the base system，下一步，Kernel to install 保持默认，下一步，默认generic: include all available drivers，下一步，</p><p>12、Configure the package manager，下一步，默认No - scan extra media，下一步， Yes - use a network mirror，下一步，选择https，下一步，默认manually，下一步</p><p>mirror <a class="link"   href="http://xn--hostnamemirrors-f870a.tuna.tsinghua.edu.cn" >hostname填mirrors.tuna.tsinghua.edu.cn<i class="fas fa-external-link-alt"></i></a></p><p>mirror directory保存默认/debian/，下一步</p><p>HTTP proxy默认留空，下一步，yes - use non-free，下一步，默认Yes - Enable source … in APT，下一步，<strong>默认两项更新勾去掉，啥都不选（非常重要！！！）</strong>，下一步</p><p>13、Select and install software，下一步，默认No automatic updates，下一步，默认No - survey，下一步，只留SSH server和standard system utilities其他都不要，下一步</p><p>14、Install GRUB boot loader，下一步，默认Yes - GRUB to primary drive，下一步，不要选第一项手工输入，选第二项/dev/sda，下一步，默认No - Force GRUB installation to the EFI removable media path，下一步</p><p>15、Finish the installation，下一步，默认Yes - Is the system clock set to UTC，下一步，安装完成，提示移除光盘，下一步</p><p>16、系统没有安装GUI，以root登录，安装完成。</p><p><strong>关闭虚拟机后，可以编辑虚拟机设置。把CD/DVD 改回为自动检测。</strong></p><p><strong>关闭虚机后，可以编辑虚机设置，修改CPU核数，硬盘大小，内存等。</strong></p><p>小技巧：虚机屏幕有时候不匹配VMware的窗口，需要拉动窗口的滚动条才能看见全部的虚机屏幕内容。或者，虚机屏幕太小，Vmware经常自动改变窗口大小去适应虚机。从VMware菜单“编辑 - 首选项 - 显示”，把“自动适应窗口”前的勾去掉（自动适应下面的两个选项都不勾）。然后再开启此虚机，可解决这个问题。</p><h2 id="1-3-安装后设置"><strong>1.3 安装后设置</strong></h2><h3 id="1-3-1-更新数据源"><strong>1.3.1 更新数据源</strong></h3><p>Debian的<strong>编辑器推荐nano</strong>，进入后编辑习惯比较像Windows记事本，下面提示了快捷键，Ctrl + o保存，下面提示保存的文件名，回车即可；Ctrl + x退出。</p><p>1. 首先编辑数据源 nano /etc/apt/sources.list，把第一行 deb cdrom 注释掉，然后加入清华大学的数据源。安装的时候已经指定了清华大学的数据源，所以有两行，删除，将下面的内容复制进去。<strong>复制了文本内容后，在nano界面，从Vmware菜单“编辑”-“粘贴”可以直接将主机中复制的文本粘贴到虚机nano中</strong>。</p><p>deb <a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/debian/" >https://mirrors.tuna.tsinghua.edu.cn/debian/<i class="fas fa-external-link-alt"></i></a> bullseye main contrib non-free</p><p>deb-src <a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/debian/" >https://mirrors.tuna.tsinghua.edu.cn/debian/<i class="fas fa-external-link-alt"></i></a> bullseye main contrib non-free</p><p>deb <a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/debian/" >https://mirrors.tuna.tsinghua.edu.cn/debian/<i class="fas fa-external-link-alt"></i></a> bullseye-updates main contrib non-free</p><p>deb-src <a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/debian/" >https://mirrors.tuna.tsinghua.edu.cn/debian/<i class="fas fa-external-link-alt"></i></a> bullseye-updates main contrib non-free</p><p>deb <a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/debian/" >https://mirrors.tuna.tsinghua.edu.cn/debian/<i class="fas fa-external-link-alt"></i></a> bullseye-backports main contrib non-free</p><p>deb-src <a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/debian/" >https://mirrors.tuna.tsinghua.edu.cn/debian/<i class="fas fa-external-link-alt"></i></a> bullseye-backports main contrib non-free</p><p>deb <a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/debian-security" >https://mirrors.tuna.tsinghua.edu.cn/debian-security<i class="fas fa-external-link-alt"></i></a> bullseye-security main contrib non-free</p><p>deb-src <a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/debian-security" >https://mirrors.tuna.tsinghua.edu.cn/debian-security<i class="fas fa-external-link-alt"></i></a> bullseye-security main contrib non-free</p><p>2. 要增加更多的镜像，可以在/etc/apt/sources.list.d/目录下建立 *.list 文件</p><p>nano /etc/apt/sources.list.d/huawei.list</p><p>deb <a class="link"   href="https://mirrors.huaweicloud.com/debian/" >https://mirrors.huaweicloud.com/debian/<i class="fas fa-external-link-alt"></i></a> bullseye main non-free contrib</p><p>deb-src <a class="link"   href="https://mirrors.huaweicloud.com/debian/" >https://mirrors.huaweicloud.com/debian/<i class="fas fa-external-link-alt"></i></a> bullseye main non-free contrib</p><p>deb <a class="link"   href="https://mirrors.huaweicloud.com/debian-security/" >https://mirrors.huaweicloud.com/debian-security/<i class="fas fa-external-link-alt"></i></a> bullseye-security main</p><p>deb-src <a class="link"   href="https://mirrors.huaweicloud.com/debian-security/" >https://mirrors.huaweicloud.com/debian-security/<i class="fas fa-external-link-alt"></i></a> bullseye-security main</p><p>deb <a class="link"   href="https://mirrors.huaweicloud.com/debian/" >https://mirrors.huaweicloud.com/debian/<i class="fas fa-external-link-alt"></i></a> bullseye-updates main non-free contrib</p><p>deb-src <a class="link"   href="https://mirrors.huaweicloud.com/debian/" >https://mirrors.huaweicloud.com/debian/<i class="fas fa-external-link-alt"></i></a> bullseye-updates main non-free contrib</p><p>deb <a class="link"   href="https://mirrors.huaweicloud.com/debian/" >https://mirrors.huaweicloud.com/debian/<i class="fas fa-external-link-alt"></i></a> bullseye-backports main non-free contrib</p><p>deb-src <a class="link"   href="https://mirrors.huaweicloud.com/debian/" >https://mirrors.huaweicloud.com/debian/<i class="fas fa-external-link-alt"></i></a> bullseye-backports main non-free contrib</p><p>nano /etc/apt/sources.list.d/ustc.list</p><p>deb <a class="link"   href="https://mirrors.ustc.edu.cn/debian/" >https://mirrors.ustc.edu.cn/debian/<i class="fas fa-external-link-alt"></i></a> bullseye main contrib non-free</p><p>deb-src <a class="link"   href="https://mirrors.ustc.edu.cn/debian/" >https://mirrors.ustc.edu.cn/debian/<i class="fas fa-external-link-alt"></i></a> bullseye main contrib non-free</p><p>deb <a class="link"   href="https://mirrors.ustc.edu.cn/debian/" >https://mirrors.ustc.edu.cn/debian/<i class="fas fa-external-link-alt"></i></a> bullseye-updates main contrib non-free</p><p>deb-src <a class="link"   href="https://mirrors.ustc.edu.cn/debian/" >https://mirrors.ustc.edu.cn/debian/<i class="fas fa-external-link-alt"></i></a> bullseye-updates main contrib non-free</p><p>deb <a class="link"   href="https://mirrors.ustc.edu.cn/debian/" >https://mirrors.ustc.edu.cn/debian/<i class="fas fa-external-link-alt"></i></a> bullseye-backports main contrib non-free</p><p>deb-src <a class="link"   href="https://mirrors.ustc.edu.cn/debian/" >https://mirrors.ustc.edu.cn/debian/<i class="fas fa-external-link-alt"></i></a> bullseye-backports main contrib non-free</p><p>deb <a class="link"   href="https://mirrors.ustc.edu.cn/debian-security/" >https://mirrors.ustc.edu.cn/debian-security/<i class="fas fa-external-link-alt"></i></a> bullseye-security main contrib non-free</p><p>deb-src <a class="link"   href="https://mirrors.ustc.edu.cn/debian-security/" >https://mirrors.ustc.edu.cn/debian-security/<i class="fas fa-external-link-alt"></i></a> bullseye-security main contrib non-free</p><p>3. 如上添加了清华，华为，中科大三个镜像，更新数据源apt update，提示有若干可升级，升级apt upgrade</p><p>4. apt与apt-get的区别</p><p>尽快适应并使用apt，广大Linux发行商都在推荐。</p><table><thead><tr><th><strong>apt 命令</strong></th><th><strong>取代的命令</strong></th><th><strong>命令的功能</strong></th></tr></thead><tbody><tr><td>apt install</td><td>apt-get install</td><td>安装软件包</td></tr><tr><td>apt remove</td><td>apt-get remove</td><td>移除软件包</td></tr><tr><td>apt purge</td><td>apt-get purge</td><td>移除软件包及配置文件</td></tr><tr><td>apt update</td><td>apt-get update</td><td>刷新存储库索引</td></tr><tr><td>apt upgrade</td><td>apt-get upgrade</td><td>升级所有可升级的软件包</td></tr><tr><td>apt autoremove</td><td>apt-get autoremove</td><td>自动删除不需要的包</td></tr><tr><td>apt full-upgrade</td><td>apt-get dist-upgrade</td><td>在升级软件包时自动处理依赖关系</td></tr><tr><td>apt search</td><td>apt-cache search</td><td>搜索应用程序</td></tr><tr><td>apt show</td><td>apt-cache show</td><td>显示安装细节</td></tr></tbody></table><table><thead><tr><th><strong>新的apt命令</strong></th><th><strong>命令的功能</strong></th></tr></thead><tbody><tr><td>apt list</td><td>列出包含条件的包（已安装，可升级等）</td></tr><tr><td>apt edit-sources</td><td>编辑源列表</td></tr></tbody></table><p>从这里可以看出，刚才nano /etc/apt/sources.list命令可以用apt edit-sources命令替代，同样是打开nano编辑sources.list文件。</p><h3 id="1-3-2-关于用户"><strong>1.3.2 关于用户</strong></h3><p>目前系统里有2个用户，root是超级管理员；zadmin是系统管理员。</p><p>系统提示符为 # 表明用户为root，提示符为$ 表明用户为其他用户。</p><p>每个用户都有自己的主目录，以 ~表示，root用户是 /root，其他用户是 /home/用户名。例如zadmin输入命令 cd ~ 则会进入其主目录 /home/zadmin</p><p>zadmin需要执行root权限的命令时，可以用 sudo 临时获得权限，也可以用 su 切换身份为root。</p><p>使用sudo时，需要输入admin用户自己的密码，使用 su时，需要输入root用户的密码，使用“sudo su”则可以使用admin自己的密码切换到root用户身份，在root用户没有设置密码时，这个方法很好用。</p><p>1. Debian默认没有安装sudo，安装apt install sudo</p><p>2. 一般修改/etc/sudoers来增加zadmin，使其可以用sudo，打开此文件，首先提示此文件必须！！！由root用visudo命令打开；第二行推荐在/etc/sudoers.d/目录下添加文件的方式代替修改此文件；最后一行显示其包含了/etc/sudoers.d目录；最下面红色提示此文件为只读。可见，用nano修改此文件是不对的，也不要试图修改其只读属性再修改。</p><p>方法1是在/etc/sudoers.d目录下新建一个zadmin的文件，内容为：</p><p>zadmin ALL=(ALL)ALL</p><p>方法2是<strong>将用户加入sudo组</strong>，本例用第2中方法。usermod是修改用户，参数-a是将用户添加到某个组，并且不删除此用户其他组身份，参数-G指定用户的组。</p><p>usermod -aG sudo zadmin</p><p>然后命令cat /etc/group查看各组情况，可以看到sudo组里已经有zadmin了，如果输出太多，一屏放不下，可以用more /etc/group翻页查看，空格显示下一页，或者less。</p><p>然后切换身份su zadmin看看是否可用sudo</p><h3 id="1-3-3-配置静态IP地址"><strong>1.3.3 配置静态IP地址</strong></h3><p><strong>第一步：确认Vmware网络配置</strong></p><p>菜单“编辑”-“虚拟网络编辑器”，这个界面，有很多网络文章说要修改，其实不用。选中列表里的Vmnet8（NAT模式），只需要看一下子网IP 192.168.138.0 及 子网掩码 255.255.255.0 记住就行了。<strong>“使用本地DHCP服务将IP地址分配给虚拟机”前面的勾不用去掉</strong>。</p><p>然后确认一下虚拟机的网络适配器是否是NAT，安装的时候默认就是这项。如果不是，就在虚拟机关机状态下，编辑虚拟机设置，改为NAT。</p><p><strong>在Vmware里只需要确认上述配置就行了，不用做任何修改！</strong></p><p><strong>第二步：在虚拟机设置静态IP</strong></p><p>本例在安装时已经配置了静态IP，下面确认一下配置，以后要修改的时候就知道去哪里修改。nano /etc/network/interfaces</p><p>第一行source /etc/network/interfaces.d/*说明先执行这个目录下的脚本，文件名无所谓，特殊配置就放在这个目录下。</p><p><strong>auto ens33 这一行是新加的，说明随系统启动ens33网卡</strong></p><p>iface ens33 inet static 这里的static说明是静态地址，否则dhcp表示动态分配</p><p>address 192.168.138.9/24 表示IP地址和掩码，24表示前3个8字节都为1，就是255.255.255.0的意思，同理8则表示255.0.0.0</p><p><strong>gateway 192.168.138.2 网关，Vmware下网关一定是 .2 而不是 .1</strong></p><p><strong>dns-nameservers 192.168.138.2 与网关相同，也是 .2</strong></p><p>从上面的注释来看，dns的设置是从resolvconf来的，nano /etc/resolv.conf</p><p>如果要修改dns的话就在这里改，或者增加新的dns。在Vmware局域网情况下，配置dns与网关一样即可，不需要添加任何其他dns，除非有特殊要求。</p><p><strong>第三步：重启网络服务</strong></p><p>本例中做了修改，则重启网络使配置生效</p><p>service networking restart</p><p>第二步里如果没有加auto ens33这一行，就会发现网络起不来（大坑）</p><p>从虚机ping <a class="link"   href="http://www.baidu.com" >www.baidu.com<i class="fas fa-external-link-alt"></i></a>，消息滚动可以Ctrl + C 中断</p><p>从主机ping 192.168.138.9 都OK说明网络配置一切正常。</p><h3 id="1-3-4-安装常用工具"><strong>1.3.4 安装常用工具</strong></h3><p>前提是网络连接没有问题。</p><p>更新数据源：apt update 执行完会提示有多少软件包要更新，如果没有，则不需要执行更新系统的命令。</p><p>更新系统所有软件包：apt upgrade</p><p>**Debian默认没有防火墙！！！**如果要使用的话，可安装ufw，如何使用ufw设置防火墙可以参考：<a class="link"   href="https://zhuanlan.zhihu.com/p/130943659" >https://zhuanlan.zhihu.com/p/130943659<i class="fas fa-external-link-alt"></i></a></p><p>因为是最小化安装，很多工具没有，dpkg -l packagename  可以查询软件包是否已安装，查询发现net-tools，perl，wget已经安装了。其他的安装一下：</p><p>apt install gcc zip unzip</p><p>安装了上面的net-tools以后，就有ifconfig命令了，试一下</p><p>ifconfig</p><p>可以看到自己的静态IP地址</p><p>更新完毕后，可以重新启动一下系统 reboot</p><h3 id="1-3-5-使用vi的问题"><strong>1.3.5 使用vi的问题</strong></h3><p><strong>现象</strong>：在 Debian 下，初次使用 vi 的时候会有点问题，在编辑模式下使用方向键并不会使光标移动，而是在命令行中出现[A [B [C [D之类的字母，而且编辑错误的话也无法使用退格键，只能用 Delete 键来删除。</p><p><strong>原因</strong>：由于 Debian 预安装的是 tiny 版本，会导致我们在使用上产生上述的不便。</p><p><strong>解决方法</strong>：安装了 vim 的 full 版本之后，键盘的所有键在 vi 下就很正常了。</p><p>apt remove vim-common -y</p><p>apt install vim -y</p><h3 id="1-3-6-彩色显示文件夹"><strong>1.3.6 彩色显示文件夹</strong></h3><p>使用ls列出文件夹和文件时，都是同一种颜色，无法区分</p><p>对于某一用户来说，其 ~/.bashrc 里是只针对这个用户的环境变量设置。</p><p>以root用户身份，nano ~/.bashrc</p><p>有提示：如果希望ls有颜色，就将下面的注释去掉</p><p>除了可以让ls有颜色外，还使命令ll表示ls -l，命令l表示ls -lA</p><p>编辑完成，保存退出。然后exit退出系统再登录，就可以看到ls列表有颜色了。灰色表示文件（不同类型文件有不同颜色），深蓝表示目录，浅蓝表示链接目录。</p><h2 id="1-4-用Putty连接虚拟机上传下载文件"><strong>1.4 用Putty连接虚拟机上传下载文件</strong></h2><p><strong>第一步：虚机允许root远程登录</strong></p><p>命令nano /etc/ssh/sshd_config，修改如下，增加了一行PermitRootLogin yes，允许root用户远程登录；然后<strong>顺便把PubkeyAuthentication yes前的注释去掉了</strong>，允许使用密钥的方式远程登录，后面用得到。重启SSH服务service sshd restart</p><p><strong>第二步：下载安装Putty并连接</strong></p><p>到Putty官网<a class="link"   href="https://putty.org/" >https://putty.org/<i class="fas fa-external-link-alt"></i></a>，选第一个Download PuTTY，下面是第三方项目。</p><p>下载64-bit x86版本，形如putty-64bit-0.77-installer.msi的安装文件。</p><p>安装完成后，有多个程序，首先运行Putty，输入IP地址，点open就可以连接。</p><p>连接后以root身份登录，可以看到显示的主机IP是192.168.138.1，命令exit可以退出登录，断开连接。</p><p>然后运行PSFTP，窗口中输入open 192.168.138.11 进行连接，以root登录，可以看到提示当前工作路径是 /root，命令exit可以退出登录，断开连接。</p><p>以后可以在虚拟机开机状态下，关闭Vmware，选择让虚拟机后台运行，然后用Putty连接进行操作，上传下载文件。</p><p>需要在虚拟机里安装JDK，安装文件为主机 D:\software\ jdk-8u341-linux-x64.tar.gz，这个文件是事先从Oracle网站下载来的。打开PSFTP连接，root登录。使用put命令将文件上传到虚拟机 /root 目录下。注意路径分隔符使用 / 而不是Windows风格的 \，然后ls命令查看虚拟机上是否有这个文件了。exit退出，断开连接。</p><h2 id="1-6-密钥方式连接虚机"><strong>1.6 密钥方式连接虚机</strong></h2><p>密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。</p><p><strong>第一步：制作密钥对</strong></p><p>在虚机上制作密钥对。首先用root登录，然后执行以下命令：</p><p>ssh-keygen  &lt;== 建立密钥对</p><p>Generating public/private rsa key pair.</p><p>Enter file in which to save the key (/root/.ssh/id_rsa): &lt;== 回车</p><p>Created directory ‘/root/.ssh’.</p><p>Enter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，或<strong>回车</strong></p><p>Enter same passphrase again: &lt;== 再输入一遍密钥锁码，<strong>回车</strong></p><p>Your identification has been saved in /root/.ssh/id_rsa. &lt;== 私钥</p><p>Your public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 公钥</p><p>The key fingerprint is:</p><p>…</p><p>The key’s randomart image is:</p><p>…</p><p>现在，在 /root 生成了一个 .ssh 的隐藏目录，内含两个密钥文件，id_rsa 为私钥，id_rsa.pub 为公钥。</p><p>密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。本例中没有密钥锁码，方便使用。</p><p><strong>第二步：在虚机上安装公钥</strong></p><p>键入以下命令，在服务器上安装公钥：</p><p>cd .ssh</p><p>cat id_rsa.pub &gt;&gt; authorized_keys</p><p>如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：</p><p>chmod 600 authorized_keys</p><p>chmod 700 ~/.ssh</p><p><strong>第三步：虚机开启密钥登录</strong></p><p>在“<a href="#_1.4_%E7%94%A8putty%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6">1.4用Putty连接虚拟机上传下载文件</a>”中第一步已经开启了密钥登录。</p><p><strong>第三步：用PSFTP下载私钥到主机</strong></p><p>用PSFTP密码登录方式连接虚机，下载id.rsa到本地重命名192.168.138.9.rsa</p><p><strong>第四步：将密钥导入到Putty</strong></p><p>首先打开PuttyGen，点Load按钮，选择文件对话框里的文件类型默认是*.ppk，改为*.*，找到刚才的192.168.138.9.rsa，就导入成功了，提示是旧的pem格式。</p><p>然后点击Save private key，保存为192.168.138.9.ppk，与刚才的文件最好在同一文件夹下，询问是否要个锁码，不理他。</p><p>关闭PuttyGen，打开Putty，左侧选择Session，右边填写Host Name为root@192.168.138.9，这里指定了登录用户为root，如果为其他用户则改为其他用户名。然后下面Saved Sessions空格里填上一个名字deb-192.168.138.9，点右侧Save就保存了。</p><p>然后左侧Connection - SSH - Auth，直接点Auth不用展开，右边Browse找到刚才保存的192.168.138.9.ppk</p><p>回到上一张图的Session，选中deb-192.168.138.9的情况下，点Save，一定要保存，否则下次又要找密钥。然后点下面的Open就连接成功了，不需要输入密码，直接root登录成功。</p><p>今后要连接的时候，打开Putty，选中保存的deb-192.168.138.9，点Load，然后点下面的Open就可以连接上了。</p><p><strong>主机运行Putty组件Pageant，会在Windows右下角出现一个常驻的代理，从中可以快速连接已经保存的session或者进行一些密钥操作</strong>。</p><h2 id="1-7-安装JDK8"><strong>1.7 安装JDK8</strong></h2><p>前面“<a href="#_1.5_%E7%94%A8putty%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6">1.4 用Putty连接虚拟机上传下载文件</a>”已经把JDK安装文件上传到 /root目录下了。创建目录 /usr/java ：mkdir /usr/java</p><p>进入/root：cd /root</p><p>解压文件到 /usr/java：tar -zxvf jdk-8u341-linux-x64.tar.gz -C /usr/java</p><p>cd /usr/java</p><p>看到已经有了一个文件夹jdk1.8.0_341，创建一个软链接，使访问简便。并且有多个版本的jdk存在时，切换只修改修改default的链接就行了，不需要再修改/etc/profile</p><p>ln -s jdk1.8.0_341 default</p><p>在/usr/java/下就生成了文件夹default，实际是jdk1.8.0_341的链接，访问default就和访问jdk1.8.0_341一样。</p><p>修改/etc/profile：nano /etc/profile</p><p>在文件最后添加</p><p>export JAVA_HOME=/usr/java/default</p><p>export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</p><p>export PATH=$PATH:$JAVA_HOME/bin</p><p>注意CLASSPATH=后面是个英文句号，这样设置可以解决很多命令行下运行java程序找不到类的问题。</p><p>保存，退出，更新：source /etc/profile</p><p>执行下面命令验证各变量正确：</p><p>echo $JAVA_HOME</p><p>echo $CLASSPATH</p><p>java -version</p><h1><strong>二、Debian11安装MySQL</strong></h1><h2 id="2-1-克隆虚机"><strong>2.1 克隆虚机</strong></h2><p>上一章已经创建了一个虚机deb-min，更新了系统，安装了常用工具，设置了密钥连接，安装了JDK8，为此虚机创建一个快照。菜单“虚拟机 - 快照 - 拍摄快照”，输入名字和描述就行了。</p><p>菜单“虚拟机 - 管理 - 克隆”，克隆源选择“现有快照”，找到刚才拍摄的快照。</p><p>克隆类型选择“创建完整克隆”</p><p>输入虚机名称deb-mysql，确认保存位置，完成。</p><h2 id="2-2-设置虚机"><strong>2.2 设置虚机</strong></h2><p>开启新的虚机deb-mysql，以root登录，<strong>首先要修改的是静态IP地址</strong>。</p><p>nano /etc/network/interfaces</p><p>将静态IP地址改为192.168.138.21就行了，其他的不用动。</p><p>nano /etc/hosts</p><p>将IP地址改为192.168.138.21就行了，其他的不用动。</p><p>重启网络服务service networking restart</p><p>虚机ping <a class="link"   href="http://www.baidu.com" >www.baidu.com<i class="fas fa-external-link-alt"></i></a>，主机ping 192.168.138.21都OK</p><p>参照“<a href="#_1.6_%E5%AF%86%E9%92%A5%E6%96%B9%E5%BC%8F%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%9C%BA">1.6密钥方式连接虚机</a>”，打开Putty，在Session里新建保存一个名称为mysql-192.168.138.21，连接地址为root@192.168.138.21，左侧Connection - SSH - Auth，直接点Auth不用展开，右边Browse找到刚才保存的192.168.138.9.ppk（<strong>就是这个旧的密钥</strong>，不需要到虚机上创建新的密钥对了，因为是克隆的，所有信息都一样）</p><p>Save，Open 连接成功。</p><p>一般安全起见，新的虚机要创建新的密钥对。本例直接使用了旧的密钥，简便。</p><h2 id="2-3-安装MySQL"><strong>2.3 安装MySQL</strong></h2><h3 id="2-3-1-安装MySQL8"><strong>2.3.1 安装MySQL8</strong></h3><p>到MySQL官网，下载MySQL APT Repository，操作系统是Debian 11，要安装的MySQL8.0，因此下载到的对应版本是mysql-apt-config_0.8.24-1_all.deb</p><p>下载需要登录。注册一个免费的MySQL或Oracle账号即可，以后用得着。</p><p>用PSFTP将文件上传到虚机 /root 目录下。</p><p>参考<a class="link"   href="https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/" >https://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/<i class="fas fa-external-link-alt"></i></a>官网步骤</p><p>先把这个文件换个地方：mv mysql-apt-config_0.8.24-1_all.deb /opt/</p><p>然后进/opt安装，因为有一次报错说_apt用户进不了/root因为权限不够</p><p>安装APT库：apt install ./mysql-apt-config_0.8.24-1_all.deb</p><p>有错误提示，也不管了 …</p><p>升级软件源apt update</p><p>安装MySQL：apt install mysql-server</p><p>中间设置root密码，输入sql=R00T两次，然后关于加密选项，保持默认回车即可。然后居然就安装完了，没有报错。</p><p>查询mysql的状态systemctl status mysql.service，居然是active</p><p>如果是inactive（active是绿色的）则启动之systemctl start mysql.service</p><p>启动完毕再查询状态systemctl status mysql.service，正常</p><p>用安装过程中设置的密码sql=R00T登录mysql，如下命令</p><p>mysql -u root -p</p><p>进入MySQL后，show databases; 正常。命令quit或exit退出MySQL</p><p>Debian没有防火墙，不用管开启3306端口的事。</p><p>重启虚机reboot，查询mysqld的状态systemctl status mysql.service</p><p>发现是active的，说明MySQL服务是随系统启动而启动的，一切正常。</p><p>到此，MySQL安装完毕，初始化配置root密码完毕。关闭虚机，拍摄快照，启动虚机，以后没事就不再安装MySQL了。</p><p>（1）此虚机将作为数据库服务器长期保持运行，关闭Vmware界面时让其后台运行。今后操作MySQL以远程为主，比如用IDEA里的database navigator</p><p>（2）MySQL有其备份方式，定期备份保障数据安全。另外，此虚机也可定期拍摄快照，如遇系统级故障，可以用快照恢复。</p><h3 id="2-3-2-特殊故障"><strong>2.3.2 特殊故障</strong></h3><p>MySQL一段时间不操作则服务停掉。有时几天，有时十几天。</p><p>参考解决方法：<a class="link"   href="https://124654439.iteye.com/blog/2174953" >https://124654439.iteye.com/blog/2174953<i class="fas fa-external-link-alt"></i></a></p><p>注意该文章的后半部分，否则就白看了。关键点是修改参数要带 global</p><p>以root身份连接登录进mysql</p><p>mysql&gt; show global variables like ‘wait_timeout’;</p><p>mysql&gt; set global interactive_timeout= 31536000;</p><p>mysql&gt; set global wait_timeout=31536000;</p><p>在MySQL8.1的版本有这个问题，此方法可以解决。</p><p>如果没这个问题，则略过。</p><h3 id="2-3-3-建立数据库、用户、表、数据"><strong>2.3.3 建立数据库、用户、表、数据</strong></h3><p>数据库服务器建好后，一般远程操作。这里仅展示在服务器上的基本操作。</p><p>本例中建立的库、用户、表、数据是为了配合前面的Spring Boot案例。</p><p>用root登录MySQL，建立一个数据库ssm_db，建立一个用户ssmaster，然后把数据库ssm_db的所有权限赋予ssmaster</p><p>mysql -u root -p</p><p>输入root的密码登录，下面的命令都是MySQL里了（<strong>在MySQL命令行，也可以通过Vmware菜单“编辑”-“粘贴”进行文本粘贴，不需要输入。快捷键Ctrl + v也可以用，注意此时光标不要在虚机输入界面</strong>）</p><p>mysql&gt; create database ssm_db DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;</p><p>mysql&gt; create user ssmaster@‘%’ identified by ‘1gE=M!ka’;</p><p>mysql&gt; create user ssmaster@localhost identified by ‘1gE=M!ka’;</p><p>mysql&gt; grant all on ssm_db.* to ssmaster@‘%’;</p><p>mysql&gt; grant all on ssm_db.* to ssmaster@localhost;</p><p>mysql&gt; quit;</p><p>库和用户都建好了，然后用ssmaster登录MySQL</p><p>mysql -u ssmaster -p</p><p>输入用户ssmaster的密码，下面的命令都是MySQL里了</p><p>mysql&gt; use ssm_db;</p><p>mysql&gt; CREATE TABLE IF NOT EXISTS tbl_book(id INT UNSIGNED AUTO_INCREMENT,type VARCHAR(100) NOT NULL,name VARCHAR(100) NOT NULL,description VARCHAR(200),PRIMARY KEY (id))DEFAULT CHARSET=utf8;</p><p>mysql&gt; INSERT INTO tbl_book(type,name,description) VALUES (‘novel’,’Learning Spring Boot’,’How to coding with Spring Boot.’);</p><p>mysql&gt; select * from tbl_book;</p><p>可以看到表建好了，并且插入了一条数据。id是自增的，不需要输入。</p><p>mysql&gt; quit;</p><h3 id="2-3-4-远程操作数据库"><strong>2.3.4 远程操作数据库</strong></h3><p>IDEA社区版安装Database Navigator插件就可以远程操作数据库了。</p><p>一般工具栏在左侧，点开后，点绿色 + 号新建一个MySQL连接如下。输入Name不一定要与数据库名一致，Description可以留空，Host填写IP地址，确认端口号是3306，Database填上面创建的库ssm_db，下面的用户名密码填上面创建的用户名密码，Driver用内置库。可以先点Test Connection按钮测试一下连接，显示成功。然后点最下面的OK，这个数据库连接就完成了。</p><p>连接建好后，就可以看到ssm_db的整个结构，并可以进行建表，修改数据等操作。</p><p>一般对数据库进行操作，是通过SQL方式。点击Open SQL console按钮打开SQL的控制台，在控制台输入如下，插入一条数据</p><p>insert into tbl_book(type,name,description) VALUES (‘技术’,’大学物理’,’全国通用大学物理教程’);</p><p>点Execute Statement就可以执行这条SQL语句。执行完毕，就生效了，另外两个按钮Commit和Rollback还亮着，说明这条SQL语句还没有正式提交数据库，可以回滚。点击Commit按钮正式提交，然后Commit和Rollback两个按钮就灰了。</p><p>再输入select * from tbl_book; 执行，就可以看到查询出的数据。</p><h2 id="2-4-MySQL-Workbench"><strong>2.4 MySQL Workbench</strong></h2><p>MySQL数据库安装在Linux服务器上，直接在服务器上操作不方便。主流的操作方式是使用客户端进行可视化的远程操作。</p><p>MySQL自己的客户端工具MySQL Workbench是免费的，功能强大。</p><p><a class="link"   href="https://www.mysql.com/products/workbench/" >https://www.mysql.com/products/workbench/<i class="fas fa-external-link-alt"></i></a>去下载，选择Windows 64位操作系统，下载到的msi安装文件形如mysql-workbench-community-8.0.31-winx64.msi</p><p>安装之后，打开的首页按“+”创建一个连接。填上连接的名字，IP地址，确认端口3306，username填root，下面password点开对话框填入root（MySQL的root用户）的密码，然后点test connection，<strong>发现拒绝连接</strong>。</p><p>拒绝连接的原因，“<a href="#_2.3.1_%E5%AE%89%E8%A3%85mysql8">2.3.1 安装MySQL8</a>”的时候只有一个用户 root@localhost，远程连接来自localhost以外的域会认为不是这个用户，就会被拒绝。创建一个新用户root@%并赋予其全部权限即可。注意root@%与root@localhost密码一样，以免混淆。</p><p>解决方法：以root登录服务器CentOS，以MySQL的root用户登录MySQL</p><p>增加用户 create user ‘root’@’%’ identified by ‘sql=R00T’;</p><p>赋予最高权限 grant all on *.* to ‘root’@’%’;</p><p>quit; 退出MySQL</p><p>再打开MySQL workbench就可以正常连接了。左侧窗口选择下面的标签Schemas就可以看到数据库列表，展开ssm_db就可以看到各个表，选中tbl_book，在右侧就能看到这个表里的数据，可以直接修改表数据，修改完后点Apply按钮，就会弹出一个对应你操作的SQL语句，确认OK，修改就生效了。</p><p>SQL Workbench一般用在项目的中后期，运维期等。可以很方便可视化的增删改查数据，如果用户身份是root或者是对应库的管理员，则可以很方便的对库、表、字段、视图、触发器、函数进行可视化的调整，备份或导入数据库，非常方便。</p><h1><strong>附录一、Debian常用命令</strong></h1><h2 id="1-1-apt"><strong>1.1 apt</strong></h2><p>列出所有可更新的软件清单命令：<strong>sudo apt update</strong></p><p>升级软件包：<strong>sudo apt upgrade</strong></p><p>列出可更新的软件包及版本信息：<strong>apt list --upgradeable</strong></p><p>升级软件包，升级前先删除需要更新软件包：<strong>sudo apt full-upgrade</strong></p><p>安装指定的软件命令：<strong>sudo apt install &lt;package_name&gt;</strong></p><p>安装多个软件包：<strong>sudo apt install &lt;package_1&gt; &lt;package_2&gt; &lt;package_3&gt;</strong></p><p>更新指定的软件命令：<strong>sudo apt update &lt;package_name&gt;</strong></p><p>显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：<strong>sudo apt show &lt;package_name&gt;</strong></p><p>删除软件包命令：<strong>sudo apt remove &lt;package_name&gt;</strong></p><p>清理不再使用的依赖和库文件：<strong>sudo apt autoremove</strong></p><p>移除软件包及配置文件：<strong>sudo apt purge &lt;package_name&gt;</strong></p><p>查找软件包命令：<strong>sudo apt search <keyword></strong></p><p>列出所有已安装的包：<strong>apt list --installed</strong></p><p>列出所有已安装的包的版本信息：<strong>apt list --all-versions</strong></p><h2 id="1-2-systemctl"><strong>1.2 systemctl</strong></h2><h3 id="1-2-1-Systemd初体验和Systemctl基础"><strong>1.2.1 Systemd初体验和Systemctl基础</strong></h3><p>1. 首先检查你的系统中是否安装有systemd并确定当前安装的版本</p><p># systemctl --version</p><p>2. 检查systemd和systemctl的二进制文件和库文件的安装位置</p><p># whereis systemd</p><p># whereis systemctl</p><p>3. 检查systemd是否运行</p><p># ps -eaf | grep [s]ystemd</p><p><strong>注意</strong>：systemd是作为父进程（PID=1）运行的。在上面带（-e）参数的ps命令输出中，选择所有进程，（-a）选择除会话前导外的所有进程，并使用（-f）参数输出完整格式列表（即 -eaf）。</p><p>也请注意上例中后随的方括号和例子中剩余部分。方括号表达式是grep的字符类表达式的一部分。</p><p>4. 分析systemd启动进程</p><p># systemd-analyze</p><p>5. 分析启动时各个进程花费的时间</p><p># systemd-analyze blame</p><p>6. 分析启动时的关键链</p><p># systemd-analyze critical-chain</p><p><strong>重要</strong>：Systemctl接受服务（.service），挂载点（.mount），套接口（.socket）和设备（.device）作为单元。</p><p>7. 列出所有可用单元</p><p># systemctl list-unit-files</p><p>8. 列出所有运行中单元</p><p># systemctl list-units</p><p>9. 列出所有失败单元</p><p># systemctl --failed</p><p>10. 检查某个单元（如 cron.service）是否启用</p><p># systemctl is-enabled crond.service</p><p>11. 检查某个单元或服务是否运行</p><p># systemctl status firewalld.service</p><h3 id="1-2-2-使用Systemctl控制并管理服务"><strong>1.2.2 使用Systemctl控制并管理服务</strong></h3><p>12. 列出所有服务（包括启用的和禁用的）</p><p># systemctl list-unit-files --type=service</p><p>13. Linux中如何启动、重启、停止、重载服务以及检查服务（如 httpd.service）状态</p><p># systemctl start httpd.service</p><p># systemctl restart httpd.service</p><p># systemctl stop httpd.service</p><p># systemctl reload httpd.service</p><p># systemctl status httpd.service</p><p><strong>注意</strong>：当我们使用systemctl的start，restart，stop和reload命令时，我们不会从终端获取到任何输出内容，只有status命令可以打印输出。</p><p>14. 如何激活服务并在启动时启用或禁用服务（即系统启动时自动启动服务）</p><p># systemctl is-active httpd.service</p><p># systemctl enable httpd.service</p><p># systemctl disable httpd.service</p><p>15. 如何屏蔽（让它不能启动）或显示服务（如 httpd.service）</p><p># systemctl mask httpd.service</p><p># systemctl unmask httpd.service</p><p>16. 使用systemctl命令杀死服务</p><p># systemctl kill httpd</p><p># systemctl status httpd</p><h3 id="1-2-3-使用Systemctl控制并管理挂载点"><strong>1.2.3 使用Systemctl控制并管理挂载点</strong></h3><p>17. 列出所有系统挂载点</p><p># systemctl list-unit-files --type=mount</p><p>18. 挂载、卸载、重新挂载、重载系统挂载点并检查系统中挂载点状态</p><p># systemctl start tmp.mount</p><p># systemctl stop tmp.mount</p><p># systemctl restart tmp.mount</p><p># systemctl reload tmp.mount</p><p># systemctl status tmp.mount</p><p>19. 在启动时激活、启用或禁用挂载点（系统启动时自动挂载）</p><p># systemctl is-active tmp.mount</p><p># systemctl enable tmp.mount</p><p># systemctl disable  tmp.mount</p><p>20. 在Linux中屏蔽（让它不能启用）或可见挂载点</p><p># systemctl mask tmp.mount</p><p># systemctl unmask tmp.mount</p><h3 id="1-2-4-使用Systemctl控制并管理套接口"><strong>1.2.4 使用Systemctl控制并管理套接口</strong></h3><p>21. 列出所有可用系统套接口</p><p># systemctl list-unit-files --type=socket</p><p>22. 在Linux中启动、重启、停止、重载套接口并检查其状态</p><p># systemctl start cups.socket</p><p># systemctl restart cups.socket</p><p># systemctl stop cups.socket</p><p># systemctl reload cups.socket</p><p># systemctl status cups.socket</p><p>23. 在启动时激活套接口，并启用或禁用它（系统启动时自启动）</p><p># systemctl is-active cups.socket</p><p># systemctl enable cups.socket</p><p># systemctl disable cups.socket</p><p>24. 屏蔽（使它不能启动）或显示套接口</p><p># systemctl mask cups.socket</p><p># systemctl unmask cups.socket</p><h3 id="1-2-5-服务的CPU利用率（分配额）"><strong>1.2.5 服务的CPU利用率（分配额）</strong></h3><p>25. 获取当前某个服务的CPU分配额（如httpd）</p><p># systemctl show -p CPUShares httpd.service</p><p><strong>注意</strong>：各个服务的默认CPU分配份额=1024，你可以增加/减少某个进程的CPU分配份额。</p><p>26. 将某个服务（httpd.service）的CPU分配份额限制为2000 CPUShares/</p><p># systemctl set-property httpd.service CPUShares=2000</p><p># systemctl show -p CPUShares httpd.service</p><p><strong>注意</strong>：当你为某个服务设置CPUShares，会自动创建一个以服务名命名的目录（如 httpd.service），里面包含了一个名为90-CPUShares.conf的文件，该文件含有CPUShare限制信息，你可以通过以下方式查看该文件：</p><p>27. 检查某个服务的所有配置细节</p><p># systemctl show httpd</p><p>28. 分析某个服务（httpd）的关键链</p><p># systemd-analyze critical-chain httpd.service</p><p>29. 获取某个服务（httpd）的依赖性列表</p><p># systemctl list-dependencies httpd.service</p><p>30. 按等级列出控制组</p><p># systemd-cgls</p><p>31. 按CPU、内存、输入和输出列出控制组</p><p># systemd-cgtop</p><h3 id="1-2-6-控制系统运行等级"><strong>1.2.6 控制系统运行等级</strong></h3><p>32. 启动系统救援模式</p><p># systemctl rescue</p><p>33. 进入紧急模式</p><p># systemctl emergency</p><p>34. 列出当前使用的运行等级</p><p># systemctl get-default</p><p>35. 启动运行等级3，即多用户模式（命令行）</p><p># systemctl isolate runlevel3.target</p><p># systemctl isolate multiuser.target</p><p>36. 设置多用户模式或图形模式为默认运行等级</p><p># systemctl set-default runlevel3.target</p><p># systemctl set-default runlevel5.target</p><p>37. 重启、停止、挂起、休眠系统或使系统进入混合睡眠</p><p># systemctl reboot</p><p># systemctl halt</p><p># systemctl suspend</p><p># systemctl hibernate</p><p># systemctl hybrid-sleep</p><p>对于不知运行等级为何物的人，说明如下。</p><ul><li>Runlevel 0 : 关闭系统</li><li>Runlevel 1 : 救援？维护模式</li><li>Runlevel 3 : 多用户，无图形系统</li><li>Runlevel 4 : 多用户，无图形系统</li><li>Runlevel 5 : 多用户，图形化系统</li><li>Runlevel 6 : 关闭并重启机器</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一、Vmware安装Debian 11&lt;/h1&gt;
&lt;p&gt;本例中采用虚拟化软件VMware Workstation安装Debian 11.5.0（base system安装）。实际应用中，单个服务器一般都设定为单一功能，比如Web服务器，数据库服务器，LDAP服务器等，或者</summary>
      
    
    
    
    <category term="Linux专题" scheme="http://example.com/categories/Linux%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Debian11安装HyperledgeFabric</title>
    <link href="http://example.com/2022/12/29/HyperledgeFabric_tutorial/"/>
    <id>http://example.com/2022/12/29/HyperledgeFabric_tutorial/</id>
    <published>2022-12-29T01:23:07.000Z</published>
    <updated>2024-05-21T06:05:09.526Z</updated>
    
    <content type="html"><![CDATA[<p>与我的另一篇文章结合着使用</p><p><a class="link"   href="https://dettry.github.io/2024/05/09/%E5%8C%BA%E5%9D%97%E9%93%BE/" >区块链环境配置教程 | CodeCook (dettry.github.io)<i class="fas fa-external-link-alt"></i></a></p><h1><strong>一、准备</strong></h1><p>在Vmware里有一个干净的Debian 11系统的虚机</p><ul><li>虚机名：deb-hlf  2核，4G内存，已安装JDK8，<strong>没有防火墙</strong></li><li>静态IP：192.168.138.31，网关、DNS：192.168.138.2</li><li>Vmware主机IP：192.168.138.1</li><li>虚机通过主机网关访问外网OK，主机和同网段其他虚机通过IP访问本虚机OK</li><li>主机可通过Putty密码，密钥方式远程连接虚机</li><li>用户<strong>root / 4geT%not</strong>，zadmin / d00r%Key 是sudo组成员</li><li>软件源：清华大学，华为，中科大</li></ul><p>安装Hyperledge Fabric过程参考：<a class="link"   href="https://hyperledger-fabric.readthedocs.io/en/latest/getting_started.html" >https://hyperledger-fabric.readthedocs.io/en/latest/getting_started.html<i class="fas fa-external-link-alt"></i></a></p><p>说明：</p><h2 id="1-1-关于操作系统"><strong>1.1 关于操作系统</strong></h2><p>1. 硬件</p><p>本例中原来分配给虚机的硬件配置是1核2G</p><p>实际运行中发现速度比较快，内存使用率从来没超过60%，但最终还是把硬件配置调成了2核4G，以防万一。</p><p>2. Debian</p><p>本例使用了Debian 11，基础安装，没有GUI，这也是硬件开销非常小的原因。</p><p>CentOS除了安装软件源apt和yum的区别外，其他的linux命令与Debian基本一样。所以后面的内容基于CentOS实现应该没有任何问题。Debian默认没有安装防火墙，如果使用CentOS需要关闭防火墙。</p><p>采用Debian的原因，首先是因为Hyperledge官网的教程是基于Debian的。其次CentOS从版本8之后已经丧失了开源Linux服务器的领导地位，Debian被认为是最好的继任者，其稳定性不弱于CentOS。再次，Debian的基础系统比CentOS最小化安装更节省硬件资源。</p><p>Debian的默认文本编辑器是nano，比vi更容易上手。如果习惯用vi或vim的话，在Debian里需要先删除系统里的vi tiny版，安装完整版。</p><p>apt remove vim-common -y</p><p>apt install vim -y</p><p>最后，Debian里操作软件源，软件安装，建议使用apt而不是apt-get或dpkg</p><h2 id="1-2-关于远程连接虚机"><strong>1.2 关于远程连接虚机</strong></h2><p>建议用Putty远程连接虚机，配置好root密钥连接。</p><p>1. Debian控制台的字体太小，难看，Putty连接的控制台字体看的舒服得多。且Putty终端控制台窗口可以调整大小。Putty控制台窗口可以在命令行输入中文。</p><p>2. Putty控制台有滚动条，大段的输出可以翻看。从Putty控制台鼠标选中大段文字，自动复制到剪贴板，然后可以粘贴到Word或其他Windows编辑工具中。从Word或网页复制的内容，在Putty控制台里点鼠标右键可自动粘贴到光标处，或粘贴到nano里。</p><p>3. Putty可以开启多个root终端连接到同一个虚机。后面的步骤里除了主终端窗口外，还需要开启另一个终端窗口，观察docker运行日志。</p><h1><strong>二、安装前置软件</strong></h1><p>1. 安装Git</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install git -y</span><br></pre></td></tr></table></figure><p>2. 安装curl</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install curl -y</span><br></pre></td></tr></table></figure><p>3. 安装Docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install docker-compose -y</span><br></pre></td></tr></table></figure><p>安装完毕后，确认Docker和Docker Compose的版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line"></span><br><span class="line">docker-compose --version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">启动docker服务：systemctl start docker</span><br><span class="line"></span><br><span class="line">设置docker服务开机启动：systemctl enable docker</span><br><span class="line"></span><br><span class="line">将用户加入docker组：usermod -a -G docker root</span><br><span class="line"></span><br><span class="line">将另一管理员用户加入docker组：usermod -a -G docker zadmin</span><br></pre></td></tr></table></figure><p>建议重启一下，虽然不需要</p><p>4. 安装Go</p><p>5. 安装JQ</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install jq</span><br></pre></td></tr></table></figure><h1><strong>三、安装Fabric</strong></h1><p>参考：<a class="link"   href="https://hyperledger-fabric.readthedocs.io/en/latest/install.html" >https://hyperledger-fabric.readthedocs.io/en/latest/install.html<i class="fas fa-external-link-alt"></i></a></p><p>1. 准备工作目录</p><p>mkdir -p <strong>/opt/go/src/github.com/zlz8x8</strong></p><p>cd /opt/go/src/github.com/zlz8x8</p><p>目录创建在 /opt 下，这里一般是空的。zlz8x8 是我在github 的用户名</p><p>2. 下载安装脚本</p><p>curl -sSLO <a class="link"   href="https://raw.githubusercontent.com/hyperledger/fabric/main/scripts/install-fabric.sh" >https://raw.githubusercontent.com/hyperledger/fabric/main/scripts/install-fabric.sh<i class="fas fa-external-link-alt"></i></a> &amp;&amp; chmod +x <a class="link"   href="http://install-fabric.sh" >install-fabric.sh<i class="fas fa-external-link-alt"></i></a></p><p>3. 执行安装脚本</p><p>./install-fabric.sh</p><p>没有参数，表示默认 docker binary samples，正是我们要的</p><p><strong>主机全程开VPN</strong>，否则无法连接github，大概500M内容，VPN如果有15~30分钟稳定即可完成安装。</p><p>中间如果VPN不稳定，<strong>失败后重新执行脚本</strong>，下载过的内容会跳过，下载没有完成的会继续完成。</p><h1><strong>四、使用Fabric test network</strong></h1><h2 id="4-1-开始之前"><strong>4.1 开始之前</strong></h2><p>参考：<a class="link"   href="https://hyperledger-fabric.readthedocs.io/en/latest/test_network.html" >https://hyperledger-fabric.readthedocs.io/en/latest/test_network.html<i class="fas fa-external-link-alt"></i></a></p><p>使用Fabric test network，包括：</p><ul><li>两个peer orgnazation和一个ordering organization</li><li>为简单化，配置了一个单独节点Raft ordering service</li><li>为简单化，没有部署TLS CA，所有证书由root CA颁发</li><li>这个sample network用Docker Compose部署了一个Fabric网络。因为在Docker Compose network里的所有节点是隔离开（孤立）的，test network没有配置连接其他运行中的Fabric节点。</li></ul><h2 id="4-2-启动test-network"><strong>4.2 启动test network</strong></h2><p>1. 启动test network</p><p>工作目录 /opt/go/src/github.com/zlz8x8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd fabric-samples/test-network</span><br><span class="line">./network.sh up</span><br></pre></td></tr></table></figure><p>就启动了，下面的命令关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network.sh down</span><br></pre></td></tr></table></figure><p>2. 检查test network各组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>输出可以看到fabric-tools，fabric-peer，fabric-orderer，fabric-peer和各自使用的端口。</p><p>peer是Fabric网络的基本组件，peer保存区块链账本并在交易transaction提交到账本前进行验证。peer运行智能合约smart contract（里面包含了商业逻辑business logic），用来管理区块链上的资产asset。</p><p>每个peer必须属于一个organization。在test network里，每个organization只有一个peer。从上面图可看出，<a class="link"   href="http://xn--organizationorg1-c39yddu776c.example.xn--comorg2-bs4l.example.com" >两个organization是org1.example.com和org2.example.com<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="http://xn--peerpeer0-4i6n8b201e0naj74i4fikw5as91d.org1.example.xn--compeer0-1c2n.org2.example.com" >对应的两个peer分别是peer0.org1.example.com和peer0.org2.example.com<i class="fas fa-external-link-alt"></i></a>。</p><p>每个Fabric网络包括一个排序服务ordering service，…</p><p>这个sample network使用了单个节点Raft ordering service，由排序节点orderer的组织来操作，就是上面的 <a class="link"   href="http://orderer.example.com" >orderer.example.com<i class="fas fa-external-link-alt"></i></a></p><h2 id="4-3-创建通道"><strong>4.3 创建通道</strong></h2><p>创建三个通道：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">./network.sh createChannel</span><br><span class="line"></span><br><span class="line">./network.sh createChannel -c channel1</span><br><span class="line"></span><br><span class="line">./network.sh createChannel -c channel2</span><br></pre></td></tr></table></figure><p>第一个通道没有指定名字，默认创建了mychannel，后面用到的。</p><p>上面的命令指定了两个通道的名字。命名规则：ASCII小写字母数字，.，-，小于250字符，开头为字母。如果不指定名字./network.sh createChannel，会自动生成一个名字。</p><p>这三个通道都是org1和org2之间的，并且org1和org2的peer都被邀请进了通道，<strong>每个通道有分开的区块链账本</strong>。</p><h2 id="4-4-在channel中执行chaincode"><strong>4.4 在channel中执行chaincode</strong></h2><p>代码是go代码，执行过程中要下载相关依赖，<strong>要开VPN</strong></p><p>先关机poweroff，做个快照，以防万一</p><p>当前目录：<strong>/opt/go/src/github.com/zlz8x8/fabric-samples/test-network</strong></p><p>经测试发现，当./network.sh down关闭网络之后，再./network.sh up，所有的channel就都没有了。这次起网络和创建channel同时进行 <strong>./network.sh up createChannel</strong></p><p>然后执行chaincode，需要<strong>主机开启VPN，执行过程中要从github和golan.org下载，大概也就5分钟不到</strong>。</p><p>./network.sh deployCC -ccn basic -ccp …/asset-transfer-basic/chaincode-go -ccl go</p><p>从输出看，chaincode在通道上提交了，并在peer0.org1和peer0.org2上都成功</p><h2 id="4-5-与网络交互"><strong>4.5 与网络交互</strong></h2><p>在网络起来后，可以用pear CLI（命令行界面）与网络进行交互。peer CLI可以调用已部署的智能合约，更新通道，或安装并部署新的智能合约。</p><p>工作路径：/opt/go/src/github.com/zlz8x8</p><p>test network路径：<strong>/opt/go/src/github.com/zlz8x8/fabric-samples/test-network</strong></p><p>将此路径定义为 $HLF_TEST_PATH，以下路径以此为基准。</p><p>CLI路径为 $HLF_TEST_PATH/…/bin，这个路径需要放到 $PATH里</p><p>配置文件core.yaml所在路径 $FABRIC_CFG_PATH=$HLF_TEST/…/config/ 需要定义在 /etc/profile 里。</p><p>nano /etc/profile 在文件最后添加如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export HLF\_TEST\_PATH=/opt/go/src/github.com/zlz8x8/fabric-samples/test-network</span><br><span class="line"></span><br><span class="line">export PATH=$HLF\_TEST\_PATH/../bin:$PATH</span><br><span class="line"></span><br><span class="line">export FABRIC\_CFG\_PATH=$HLF\_TEST\_PATH/../config/</span><br></pre></td></tr></table></figure><p>保存后，更新系统变量 source /etc/profile，然后 echo $HLF_TEST_PATH看看系统变量生效没有。</p><p><strong>以下默认在 /opt/go/src/github.com/zlz8x8/fabric-samples/test-network 路径工作，以下的命令都以此路径为基准，下文中出现的 ${PWD} 代表的就是这个路径。</strong></p><p><strong>命令行输入如下命令，设置系统变量，后面的peer命令就是在Org1上运行的了</strong></p><p>这些系统变量没有写在 /etc/profile 里面，是临时的，系统关闭或重启就没有了。可以在该目录下新建一个文件setOrgEnv1，把下面的命令放在里面，需要执行这些命令的时候只需要执行source setOrgEnv1就可以了。</p><p>因此，此时执行 source setOrgEnv1 即可，或执行下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export CORE\_PEER\_TLS\_ENABLED=true</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_LOCALMSPID=&quot;Org1MSP&quot;</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_TLS\_ROOTCERT\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_ADDRESS=localhost:7051</span><br></pre></td></tr></table></figure><p>输入下面命令初始化资产的账本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot; -c &#x27;&#123;&quot;function&quot;:&quot;InitLedger&quot;,&quot;Args&quot;:[]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>命令虽然很长，执行很快，不到1秒，看到输出 status:200 说明成功了</p><p>现在可以通过CLI查询账本，运行下面命令查询添加到通道账本的资产</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -C mychannel -n basic -c &#x27;&#123;&quot;Args&quot;:[&quot;GetAllAssets&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>执行成功，查询结果输出如下：注意asset6的owner是Michel</p><p>当一个网络成员希望转移或更改账本中的某项资产，就可以调用链码chaincode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot; -c &#x27;&#123;&quot;function&quot;:&quot;TransferAsset&quot;,&quot;Args&quot;:[&quot;asset6&quot;,&quot;Christopher&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>执行成功，输出如下 status:200</p><p>因为背书endorsement策略，资产转移 asset-tranfer (basic) 链码需要Org1和Org2的签名，因此链码调用需要用 --peerAddresses 标签指向 <a class="link"   href="http://peer0.org1.example.com" >peer0.org1.example.com<i class="fas fa-external-link-alt"></i></a> 和 <a class="link"   href="http://peer0.org2.example.com" >peer0.org2.example.com<i class="fas fa-external-link-alt"></i></a> 。另外，网络使用了TLS连接，命令需要用 --tlsRootCertFiles 引用TLS证书。</p><p>在上述链码执行后，我们可以用另一个查询取看看这次调用如何改变了账本里的资产。已经使用org1进行了查询，下面使用org2 peer进行查询。</p><p><strong>命令行输入如下命令，设置系统变量，后面的peer命令就是在Org2上运行的了</strong></p><p>可以在该目录下新建一个文件setOrgEnv2，把下面的命令放在里面，需要执行这些命令的时候只需要执行source setOrgEnv2就可以了。</p><p>执行 source setOrgEnv2 即可，或执行下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export CORE\_PEER\_TLS\_ENABLED=true</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_LOCALMSPID=&quot;Org2MSP&quot;</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_TLS\_ROOTCERT\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_ADDRESS=localhost:9051</span><br></pre></td></tr></table></figure><p>相同的系统变量名，不同的值，会覆盖之前的Org1设置。</p><p>然后执行下面命令查询资产转移（跑在peer0.org2.example.com上的basic链码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -C mychannel -n basic -c &#x27;&#123;&quot;Args&quot;:[&quot;ReadAsset&quot;,&quot;asset6&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>执行成功，可以看到asset6的owner已经变成了Christopher</p><h2 id="4-6-关闭网络"><strong>4.6 关闭网络</strong></h2><p>使用下面命令关闭网络。这将停止并移除node和chaincode的容器，删除organization的加密内容，移除链码在Docker Registry里的镜像image，移除之前运行的通道和docker volume。</p><p>./network.sh down</p><h2 id="4-7-启动有CA的网络"><strong>4.7 启动有CA的网络</strong></h2><p>Hyperledge Fabric使用PKI（Public key infrastructure，公钥基础设施）验证所有的网络参与者。每个节点node，网络管理员和用户提交交易都必须提供公钥和私钥进行身份验证。这些证书由CA颁发。</p><p>默认情况下，前面运行的 ./network.sh up 提供了加密工具cryptogen，供开发和测试。观察 ./network.sh up 的输出日志，可以看到加密工具为Org1，Org2和Orderer Org创建了证书和密钥。</p><p>test network也提供了选项在启动网络时使用CA（Certificate Authority，证书中心）。在生产网络production network，每个organization都运行一个CA（称为 中间CA）为其组织颁发证书。这些CA共享一个根信任root trust。虽然使用CA比使用cryptogen花费更多的时间，但分布式生产网络需要CA部署。CA还可以添加新的客户端身份认证和为应用程序创建证书和私钥。</p><p>下面命令启动带CA的网络，第二个命令同时创建通道，第三个命令把执行命令的输出写到文件out.log中，方便查看，加参数 -a 表示末尾添加模式而不是删除重写模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./network.sh up -ca</span><br><span class="line"></span><br><span class="line">./network.sh up createChannel -ca</span><br></pre></td></tr></table></figure><p>如果是用Putty连接虚机，执行命令后可以看到完整输出（窗口有滚动条）。可以看到创建网络后第一件是就是创建了3个CA。</p><p>用下面命令查看Org1的MSP（Membership service provider）文件夹。<strong>执行发现没有tree命令，安装 apt install tree</strong>，然后执行下面命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree organizations/peerOrganizations/org1.example.com/users/Admin**@org1**.example.com/</span><br></pre></td></tr></table></figure><p>可以看到 *.pem 就是密钥文件，keystore里保存的也是密钥。</p><h1><strong>五、向通道部署智能合约</strong></h1><p>首先进入工作路径，启动网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/go/src/github.com/zlz8x8/fabric-samples/test-network</span><br><span class="line"></span><br><span class="line">./network.sh up createChannel</span><br></pre></td></tr></table></figure><p>设置Logspout，可选。</p><p>如果是直接系统登录情况下是无法打开第二个终端窗口的。用Putty连接虚机，进行工作操作，然后再打开一个Putty连接到同一个虚机，就有两个终端窗口了。从第二个终端窗口进入工作目录，开启logspout</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/go/src/github.com/zlz8x8/fabric-samples/test-network</span><br><span class="line"></span><br><span class="line">./monitordocker.sh fabric\_test</span><br></pre></td></tr></table></figure><p>如果是第一次运行，需要拉取相应的image，似乎不需要VPN，很快</p><p><strong>然后光标就停在一长串数字下面了，这是正常的，等待输出</strong>。</p><p>从第一个窗口工作路径下运行 docker stop logspout 就可以停止第二个窗口的等待状态，进入光标。从第二个窗口再次运行 ./monitordocker.sh fabric_test 就再次监视docker的状态，等待输出。</p><h2 id="5-1-打包智能合约"><strong>5.1 打包智能合约</strong></h2><p>本例中的智能合约有三种语言go，javascript，typescript写的代码。go语言的包被用在后面的步骤“向通道安装智能合约”中，javascript语言的包被用在后面的步骤“升级智能合约”中，typescript的包没有使用，要用的话步骤和go和javascript是一样的。</p><h3 id="5-1-1-Go"><strong>5.1.1 Go</strong></h3><p>在工作路径：/opt/go/src/github.com/zlz8x8/fabric-samples/test-network</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ../asset-transfer-basic/chaincode-go</span><br></pre></td></tr></table></figure><p>可以看一下这个目录下 go.mod 的内容，智能合约的部分是如何写的。</p><p>GO111MODULE=on go mod vendor</p><p>开始下载依赖包，编译，<strong>应该需要VPN</strong>，大概1秒钟，生成的模块在vendor目录下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ../../test-network</span><br><span class="line"></span><br><span class="line">peer version</span><br><span class="line"></span><br><span class="line">peer lifecycle chaincode package basic.tar.gz --path ../asset-transfer-basic/chaincode-go/ --lang golang --label basic\_1.0</span><br></pre></td></tr></table></figure><p>在工作路径 /opt/go/src/github.com/zlz8x8/fabric-samples/test-network 下就生成了一个basic.tar.gz包。打包go完成。</p><h3 id="5-1-2-Javascript"><strong>5.1.2 Javascript</strong></h3><p>安装nodejs和npm，大概下载500M，设置了清华源，很快</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install nodejs npm</span><br></pre></td></tr></table></figure><p>设置npm代理，否则运行时会卡死</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>在工作路径：/opt/go/src/github.com/zlz8x8/fabric-samples/test-network</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ../asset-transfer-basic/chaincode-javascript</span><br></pre></td></tr></table></figure><p>可以看一下 lib/assetTransfer.js 的内容，智能合约的部分是如何写的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>会新生成一个node_modules目录，生成的模块在此目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ../../test-network</span><br></pre></td></tr></table></figure><p>不执行打包命令，后面会执行打包命令为升级包2.0。要执行的话，把go的打包命令中的–path …/asset-transfer-basic/chaincode-javascript/ 换了，–lang node 换了，并且要更改包名，否则会覆盖前面生成的 basic.tar.gz</p><h3 id="5-1-3-Typescript"><strong>5.1.3 Typescript</strong></h3><p>在工作路径：/opt/go/src/github.com/zlz8x8/fabric-samples/test-network</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ../asset-transfer-basic/chaincode-typescript</span><br></pre></td></tr></table></figure><p>可以看一下 src/assetTransfer.ts 的内容，智能合约部分是如何写的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>会新生成一个node_modules目录，生成的模块在此目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ../../test-network</span><br></pre></td></tr></table></figure><p>不执行打包命令，要执行的话，把go的打包命令中的–path …/asset-transfer-basic/chaincode-typescript/ 换了，–lang node 换了，并且要更改包名，否则会覆盖前面生成的 basic.tar.gz</p><h2 id="5-2-安装链码包"><strong>5.2 安装链码包</strong></h2><p>在工作路径：/opt/go/src/github.com/zlz8x8/fabric-samples/test-network</p><p>确认目录下有 basic.tar.gz，就是之前打包的go链码。<strong>关闭网络后，这个文件就被删除了</strong>，需要重新执行打包步骤。可以 cp basic.tar.gz basic.tar.gz.bak 留个备份。下次启动网络，可以跳过打包步骤，从备份拷贝回来cp basic.tar.gz.bak basic.tar.gz</p><p>确认网络已启动，管道已创建</p><p>确认有两个命令行窗口，一个是主窗口，另一个运行了./monitordocker.sh fabric_test 在等待输出。</p><p>首先在org1 peer上安装链码，设置系统org1参数。执行 source setOrgEnv1 即可，或执行下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export CORE\_PEER\_TLS\_ENABLED=true</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_LOCALMSPID=&quot;Org1MSP&quot;</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_TLS\_ROOTCERT\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_ADDRESS=localhost:7051</span><br></pre></td></tr></table></figure><p>执行下面命令。可以看到监视窗口有大量输出，可以看到安装链码的是 peer0.org1</p><p>peer lifecycle chaincode install basic.tar.gz</p><p>主窗口只输出结果，和监视窗口最后的输出是一样的。Putty窗口鼠标选中的内容就自动复制到剪贴板了，到这里粘贴如下：</p><p>2022-12-10 21:34:34.245 CST 0001 INFO [cli.lifecycle.chaincode] submitInstallProposal -&gt; Installed remotely:  response:&lt;status:200 payload:“\nJbasic_1.0:56069c8c46fe01a7837a218a6e2ab49a2b6c4a715c95ab2ab321a863b642d021\022\tbasic_1.0” &gt;</p><p>2022-12-10 21:34:34.260 CST 0002 INFO [cli.lifecycle.chaincode] submitInstallProposal -&gt; Chaincode code package identifier: basic_1.0:56069c8c46fe01a7837a218a6e2ab49a2b6c4a715c95ab2ab321a863b642d021</p><p>然后设置org2系统变量，在org2 peer上安装链码。执行 source setOrgEnv2 即可，或执行下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export CORE\_PEER\_LOCALMSPID=&quot;Org2MSP&quot;</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_TLS\_ROOTCERT\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_ADDRESS=localhost:9051</span><br></pre></td></tr></table></figure><p>执行下面命令。可以看到监视窗口有大量输出，主窗口输出和上面一样，安装成功。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode install basic.tar.gz</span><br></pre></td></tr></table></figure><h2 id="5-3-确认链码定义"><strong>5.3 确认链码定义</strong></h2><p>紧跟上面步骤，现在身份是org2，首先查询已安装的链码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode queryinstalled</span><br></pre></td></tr></table></figure><p>输出如下：</p><p>Installed chaincodes on peer:</p><p>Package ID: basic_1.0:56069c8c46fe01a7837a218a6e2ab49a2b6c4a715c95ab2ab321a863b642d021, Label: basic_1.0</p><p>这里的Package ID在确认链码的时候要用，我们用它设置一个系统变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CC\_PACKAGE\_ID=basic\_1.0:56069c8c46fe01a7837a218a6e2ab49a2b6c4a715c95ab2ab321a863b642d021</span><br></pre></td></tr></table></figure><p>设置了这个系统参数，后面org1确认链码的时候也可以用，所以org1在确认的时候就省略这一步了。</p><p>确认链码定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --package-id $CC\_PACKAGE\_ID --sequence 1 --tls --cafile &quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span><br></pre></td></tr></table></figure><p>输出如下：</p><p>2022-12-11 17:04:26.913 CST 0001 INFO [chaincodeCmd] ClientWait -&gt; txid [700a4f809b4baa7b7ae2debf5ffd20626c4a035436b3e7e7e6430c76d27ba4be] committed with status (VALID) at localhost:9051</p><p>上面步骤的解释（未翻译）：</p><p>The command above uses the --package-id flag to include the package identifier in the chaincode definition. The --sequence parameter is an integer that keeps track of the number of times a chaincode has been defined or updated. Because the chaincode is being deployed to the channel for the first time, the sequence number is 1. When the asset-transfer (basic) chaincode is upgraded, the sequence number will be incremented to 2. If you are using the low level APIs provided by the Fabric Chaincode Shim API, you could pass the --init-required flag to the command above to request the execution of the Init function to initialize the chaincode. The first invoke of the chaincode would need to target the Init function and include the --isInit flag before you could use the other functions in the chaincode to interact with the ledger.</p><p>We could have provided a --signature-policy or --channel-config-policy argument to the approveformyorg command to specify a chaincode endorsement policy. The endorsement policy specifies how many peers belonging to different channel members need to validate a transaction against a given chaincode. Because we did not set a policy, the definition of asset-transfer (basic) will use the default endorsement policy, which requires that a transaction be endorsed by a majority of channel members present when the transaction is submitted. This implies that if new organizations are added or removed from the channel, the endorsement policy is updated automatically to require more or fewer endorsements. In this tutorial, the default policy will require a majority of 2 out of 2 and transactions will need to be endorsed by a peer from Org1 and Org2.</p><p>下面用org1来确认链码，执行 source setOrgEnv1 即可，或执行下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export CORE\_PEER\_LOCALMSPID=&quot;Org1MSP&quot;</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_TLS\_ROOTCERT\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_ADDRESS=localhost:7051</span><br></pre></td></tr></table></figure><p>然后用org1确认链码定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --package-id $CC\_PACKAGE\_ID --sequence 1 --tls --cafile &quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span><br></pre></td></tr></table></figure><p>输出如下，跟org2的输出比较一下，最后的端口号不一样了。</p><p>2022-12-11 17:48:34.122 CST 0001 INFO [chaincodeCmd] ClientWait -&gt; txid [f6cd1365d631880f7753a7e4e91d1de34444e17659b6d5dc11869d5a7815e670] committed with status (VALID) at localhost:7051</p><h2 id="5-4-向通道提交链码定义"><strong>5.4 向通道提交链码定义</strong></h2><p>紧跟上述步骤，现在peer身份是org1</p><p>下面命令查询有哪些成员确认了链码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 1.0 --sequence 1 --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; --output json</span><br></pre></td></tr></table></figure><p>输出如下，说明org1和org2已经确认了链码：</p><p>{</p><p><code>      </code>“approvals”: {</p><p><code>              </code>“Org1MSP”: true,</p><p><code>              </code>“Org2MSP”: true</p><p><code>      </code>}</p><p>}</p><p>网络里只有org1和org2，都已经确认，现在链码定义已经可以提交到通道，用下面的命令提交链码定义：从下面的命令可以看出，以org1和org2身份提交了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 1.0 --sequence 1 --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;</span><br></pre></td></tr></table></figure><p>输出如下，说明org1和org2都提交了链码：</p><p>2022-12-11 17:55:17.072 CST 0001 INFO [chaincodeCmd] ClientWait -&gt; txid [2950340b01b19046b2ed345900c6b50a32a947ff529263e728c53eea7247d718] committed with status (VALID) at localhost:9051</p><p>2022-12-11 17:55:17.088 CST 0002 INFO [chaincodeCmd] ClientWait -&gt; txid [2950340b01b19046b2ed345900c6b50a32a947ff529263e728c53eea7247d718] committed with status (VALID) at localhost:7051</p><p>用下面的命令查询已提交的链码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode querycommitted --channelID mychannel --name basic --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span><br></pre></td></tr></table></figure><p>输出如下，包含了已提交的链码的信息：</p><p>Committed chaincode definition for chaincode ‘basic’ on channel ‘mychannel’:</p><p>Version: 1.0, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc, Approvals: [Org1MSP: true, Org2MSP: true]</p><h2 id="5-5-调用链码"><strong>5.5 调用链码</strong></h2><p>链码已经提交到通道，可以被client application调用，并且链码会在各个加入的peer（org1和org2）上运行。</p><p>执行下面命令调用链码，在账本创建一个初始化的资产集。注意调用命令要标的（target）足够多的peer以满足背书策略，现在只有org1和org2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot; -c &#x27;&#123;&quot;function&quot;:&quot;InitLedger&quot;,&quot;Args&quot;:[]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>输出如下，执行成功：</p><p>2022-12-11 18:07:14.083 CST 0001 INFO [chaincodeCmd] chaincodeInvokeOrQuery -&gt; Chaincode invoke successful. result: status:200</p><p>用下面的命令查询刚才创建的资产（cars）集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -C mychannel -n basic -c &#x27;&#123;&quot;Args&quot;:[&quot;GetAllAssets&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>输出如下：</p><p>[{“AppraisedValue”:300,“Color”:“blue”,“ID”:“asset1”,“Owner”:“Tomoko”,“Size”:5},{“AppraisedValue”:400,“Color”:“red”,“ID”:“asset2”,“Owner”:“Brad”,“Size”:5},{“AppraisedValue”:500,“Color”:“green”,“ID”:“asset3”,“Owner”:“Jin Soo”,“Size”:10},{“AppraisedValue”:600,“Color”:“yellow”,“ID”:“asset4”,“Owner”:“Max”,“Size”:10},{“AppraisedValue”:700,“Color”:“black”,“ID”:“asset5”,“Owner”:“Adriana”,“Size”:15},{“AppraisedValue”:800,“Color”:“white”,“ID”:“asset6”,“Owner”:“Michel”,“Size”:15}]</p><h2 id="5-6-升级智能合约"><strong>5.6 升级智能合约</strong></h2><p>前面步骤已经安装、提交、调用了go链码。下面打包javascript链码并安装，对智能合约进行升级。</p><h3 id="5-6-1-打包链码"><strong>5.6.1 打包链码</strong></h3><p>前面没有执行javascript链码打包，现在执行打包命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ../asset-transfer-basic/chaincode-javascript</span><br><span class="line"></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>回到工作路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ../../test-network</span><br></pre></td></tr></table></figure><p>执行系统参数设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$&#123;PWD&#125;/../bin:$PATH</span><br><span class="line"></span><br><span class="line">export FABRIC\_CFG\_PATH=$PWD/../config/</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br></pre></td></tr></table></figure><p>注意：<strong>前两项设置已经在“4.5 与网络交互”写在 /etc/profile 里了，开机已经有了，这里只需要执行第三行</strong>。</p><p>执行打包命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode package basic\_2.tar.gz --path ../asset-transfer-basic/chaincode-javascript/ --lang node --label basic\_2.0</span><br></pre></td></tr></table></figure><p>工作目录下会多一个basic_2.tar.gz，网络关闭后，这个文件会被删除，我们备份一下cp basic_2.tar.gz basic_2.tar.gz.bak，下次重启网络，可以跳过打包步骤，把备份的文件恢复回来就行了cp basic_2.tar.gz.bak basic_2.tar.gz</p><h3 id="5-6-2-安装链码"><strong>5.6.2 安装链码</strong></h3><p>下面用org1来安装链码，执行 source setOrgEnv1 即可，或执行下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export CORE\_PEER\_TLS\_ENABLED=true</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_LOCALMSPID=&quot;Org1MSP&quot;</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_TLS\_ROOTCERT\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_ADDRESS=localhost:7051</span><br></pre></td></tr></table></figure><p>安装链码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode install basic\_2.tar.gz</span><br></pre></td></tr></table></figure><p>查询已安装的链码：</p><p>peer lifecycle chaincode queryinstalled</p><p>输出如下，可以看到已安装了两个链码：</p><p>Installed chaincodes on peer:</p><p>Package ID: basic_2.0:a496470e6e35a564619781f41bc17eef4db685c222aa0b89ed3dfb4b668206f5, Label: basic_2.0</p><p>Package ID: basic_1.0:56069c8c46fe01a7837a218a6e2ab49a2b6c4a715c95ab2ab321a863b642d021, Label: basic_1.0</p><h3 id="5-6-3-确认链码"><strong>5.6.3 确认链码</strong></h3><p>用上面的链码ID设置一个系统变量，<strong>注意这里的ID要和你的查询输出里的一致</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export NEW\_CC\_PACKAGE\_ID=basic\_2.0:a496470e6e35a564619781f41bc17eef4db685c222aa0b89ed3dfb4b668206f5</span><br></pre></td></tr></table></figure><p>现在以org1确认链码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 2.0 --package-id $NEW\_CC\_PACKAGE\_ID --sequence 2 --tls --cafile &quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span><br></pre></td></tr></table></figure><p><strong>下面用org2来安装、确认链码</strong>，执行 source setOrgEnv2 即可，或执行下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export CORE\_PEER\_LOCALMSPID=&quot;Org2MSP&quot;</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_TLS\_ROOTCERT\_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp</span><br><span class="line"></span><br><span class="line">export CORE\_PEER\_ADDRESS=localhost:9051</span><br></pre></td></tr></table></figure><p>安装链码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode install basic\_2.tar.gz</span><br></pre></td></tr></table></figure><p>确认链码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode approveformyorg -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 2.0 --package-id $NEW\_CC\_PACKAGE\_ID --sequence 2 --tls --cafile &quot;$&#123;PWD&#125;/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot;</span><br></pre></td></tr></table></figure><p>org1和org2都安装，确认了链码。检查一下basic_2是否已准备好提交了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode checkcommitreadiness --channelID mychannel --name basic --version 2.0 --sequence 2 --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; --output json</span><br></pre></td></tr></table></figure><p>从输出来看，org1和org2都确认了，可以提交：</p><p>{</p><p><code>      </code>“approvals”: {</p><p><code>              </code>“Org1MSP”: true,</p><p><code>              </code>“Org2MSP”: true</p><p><code>      </code>}</p><p>}</p><h3 id="5-6-4-提交链码"><strong>5.6.4 提交链码</strong></h3><p>提交新的链码，从前面的步骤可知，下面的命令是以org1或org2的身份执行的，都会以两者的身份提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer lifecycle chaincode commit -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --channelID mychannel --name basic --version 2.0 --sequence 2 --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot;</span><br></pre></td></tr></table></figure><p>验证一下新的链码已经在各个peer上运行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>下面输出（部分），可看到，basic_2.0在org1和org2上都有：</p><p>7c2ad4f2b66d   dev-peer0.org2.example.com-basic_2.0-a496470e6e35a564619781f41bc17eef4db685c222aa0b89ed3dfb4b668206f5-a394028e6792b45700d3e09782af3f93d9c18f9bfb8be6f4f761730f94faad53   “docker-entrypoint.s…”   54 seconds ago      Up 53 seconds                                                                               dev-peer0.org2.example.com-basic_2.0-a496470e6e35a564619781f41bc17eef4db685c222aa0b89ed3dfb4b668206f5</p><p>298b812c2dee   dev-peer0.org1.example.com-basic_2.0-a496470e6e35a564619781f41bc17eef4db685c222aa0b89ed3dfb4b668206f5-5113a692e1e282cd0168c26a4ec379486b6a8dfb8fe03e6043a805669c5b2696   “docker-entrypoint.s…”   54 seconds ago      Up 53 seconds                                                                               dev-peer0.org1.example.com-basic_2.0-a496470e6e35a564619781f41bc17eef4db685c222aa0b89ed3dfb4b668206f5</p><h3 id="5-6-5-调用链码"><strong>5.6.5 调用链码</strong></h3><p>如果使用了 --init-required 参数，则需要在使用链码前调用 Init 方法。本例中不需要执行 Init，下面测试创建一个新 car</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode invoke -o localhost:7050 --ordererTLSHostnameOverride orderer.example.com --tls --cafile &quot;$*&#123;PWD&#125;*/organizations/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem&quot; -C mychannel -n basic --peerAddresses localhost:7051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt&quot; --peerAddresses localhost:9051 --tlsRootCertFiles &quot;$*&#123;PWD&#125;*/organizations/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt&quot; -c &#x27;&#123;&quot;function&quot;:&quot;CreateAsset&quot;,&quot;Args&quot;:[&quot;asset8&quot;,&quot;blue&quot;,&quot;16&quot;,&quot;Kelley&quot;,&quot;750&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>输出返回值 status:200 成功了。</p><p>用下面的命令查询资产（cars）集：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">peer chaincode query -C mychannel -n basic -c &#x27;&#123;&quot;Args&quot;:[&quot;GetAllAssets&quot;]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>输出如下，可以看到比“5.5 调用链码”里的输出多了一个asset8</p><p>[{“AppraisedValue”:300,“Color”:“blue”,“ID”:“asset1”,“Owner”:“Tomoko”,“Size”:5},{“AppraisedValue”:400,“Color”:“red”,“ID”:“asset2”,“Owner”:“Brad”,“Size”:5},{“AppraisedValue”:500,“Color”:“green”,“ID”:“asset3”,“Owner”:“Jin Soo”,“Size”:10},{“AppraisedValue”:600,“Color”:“yellow”,“ID”:“asset4”,“Owner”:“Max”,“Size”:10},{“AppraisedValue”:700,“Color”:“black”,“ID”:“asset5”,“Owner”:“Adriana”,“Size”:15},{“AppraisedValue”:800,“Color”:“white”,“ID”:“asset6”,“Owner”:“Michel”,“Size”:15},{“AppraisedValue”:“750”,“Color”:“blue”,“ID”:“asset8”,“Owner”:“Kelley”,“Size”:“16”}]</p><h3 id="5-6-6-清理并关闭网络"><strong>5.6.6 清理并关闭网络</strong></h3><p>如果开了监视窗口，监视窗口无法输入，<strong>在主窗口执行下面命令</strong>停止监视：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker stop logspout</span><br><span class="line"></span><br><span class="line">docker rm logspout</span><br></pre></td></tr></table></figure><p>关闭网络：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./network.sh down</span><br></pre></td></tr></table></figure><p><strong>建议这里把虚拟机拍个快照</strong>。虽然关闭网络把前面在网络里做的事情都清除了，但快照可以保留：tree，nodejs，npm的安装，自己写的文档 setOrgEnv1，setOrgEnv2，链码包的备份，写在 /etc/profile 里长期生效的系统变量。</p><h1><strong>六、运行一个Fabric Application</strong></h1><h1><strong>七、运行外部链码编译器</strong></h1><h1><strong>八、在Fabric里使用私有数据</strong></h1><h1><strong>九、在Fabric里保障资产转移的安全</strong></h1><h1><strong>十、使用CouchDB</strong></h1><h1><strong>十一、创建一个通道</strong></h1><h1><strong>十二、向通道加入Org</strong></h1><h1><strong>十三、更新一个通道的配置</strong></h1><h1><strong>十四、编写第一个链码</strong></h1><h1><strong>十五、在开发模式运行链码</strong></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;与我的另一篇文章结合着使用&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://dettry.github.io/2024/05/09/%E5%8C%BA%E5%9D%97%E9%93%BE/&quot; &gt;区块链环境配置教程 | CodeCook (det</summary>
      
    
    
    
    <category term="Linux专题" scheme="http://example.com/categories/Linux%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="HyperledgeFabric" scheme="http://example.com/tags/HyperledgeFabric/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习笔记</title>
    <link href="http://example.com/2022/11/28/SpringBoot_learning/"/>
    <id>http://example.com/2022/11/28/SpringBoot_learning/</id>
    <published>2022-11-28T01:23:07.000Z</published>
    <updated>2024-05-21T05:41:13.117Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>前言</strong></h1><p>课程视频地址：<a class="link"   href="https://www.bilibili.com/video/BV15b4y1a7yG/" >https://www.bilibili.com/video/BV15b4y1a7yG/<i class="fas fa-external-link-alt"></i></a></p><p>Java环境：JavaSE 1.8.0_351</p><p>开发IDE：IntelliJ IDEA Community Edition 2022.2.3</p><h2 id="0-1-IDEA-Community-Edition设置"><strong>0.1 IDEA Community Edition设置</strong></h2><h3 id="0-1-1-统一设置编码为utf-8编码"><strong>0.1.1 统一设置编码为utf-8编码</strong></h3><p>1、文件和项目编码File -&gt; Settings -&gt; Editor -&gt; File Encodings，其中的Project Encoding和Default encoding for properties files两项，后面Transparent native to ascii convension打勾。</p><p>2、新项目文件编码：File -&gt; New Project Setup -&gt; Settings for New Projects -&gt; Editor -&gt; File Encodings，与上面相同。</p><p>3、File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Compiler -&gt; Java Compiler，设置Additional command line parameters选项为-encoding utf-8</p><p>4、将项目中的**.idea文件夹<strong>中的</strong>encodings.xml**文件中的编码格式改为utf-8，一般来说进行了上述第1步，这个文件中的编码格式自动改为utf-8，不需要手动修改。</p><h3 id="0-1-2-Maven设置"><strong>0.1.2 Maven设置</strong></h3><p>本例中IDEA自带的Maven是3.8.1，一般网上教程要求是Maven 3即可。</p><p><strong>强烈建议在IDEA里安装Maven Helper插件。</strong></p><p>首先准备好自己的maven仓库目录，本例中是 D:\Java\mvn-repository</p><p>准备好自己的一个 settings.xml，如下：</p><?xml version="1.0" encoding="UTF-8"?><p>&lt;settings xmlns=“<a class="link"   href="http://maven.apache.org/SETTINGS/1.0.0" >http://maven.apache.org/SETTINGS/1.0.0<i class="fas fa-external-link-alt"></i></a>”</p><p><code>  </code>xmlns:xsi=“<a class="link"   href="http://www.w3.org/2001/XMLSchema-instance" >http://www.w3.org/2001/XMLSchema-instance<i class="fas fa-external-link-alt"></i></a>”</p><p><code>  </code>xsi:schemaLocation=“<a class="link"   href="http://maven.apache.org/SETTINGS/1.0.0" >http://maven.apache.org/SETTINGS/1.0.0<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="http://maven.apache.org/xsd/settings-1.0.0.xsd" >http://maven.apache.org/xsd/settings-1.0.0.xsd<i class="fas fa-external-link-alt"></i></a>”&gt;</p><p><code>  </code><!-- 定义本地 Maven 仓库地址 --></p><p><code>  </code><localRepository>D:\Java\mvn-repository</localRepository></p><p><code>  </code><mirrors></p><p><code>      </code><!-- 定义阿里云 Maven 镜像地址 --></p><p><code>      </code><mirror></p><p><code>          </code><id>aliyunMaven</id></p><p><code>          </code><mirrorOf>*</mirrorOf></p><p><code>          </code><name>Aliyun Maven Mirror</name></p><p><code>          </code><url><a class="link"   href="https://maven.aliyun.com/repository/public" >https://maven.aliyun.com/repository/public<i class="fas fa-external-link-alt"></i></a></url></p><p><code>      </code></mirror></p><p><code>  </code></mirrors></p><p><code>  </code><!--根据环境参数来调整构建配置的列表。settings.xml中的profile元素是pom.xml中profile元素的裁剪版本。 --></p><p><code>  </code><profiles></p><p><code>      </code><!-- 定义阿里云的 Spring 仓库 --></p><p><code>      </code><profile></p><p><code>          </code><id>aliyunSpring</id></p><p><code>          </code><repositories></p><p><code>              </code><repository></p><p><code>                  </code><id>spring</id></p><p><code>                  </code><url><a class="link"   href="https://maven.aliyun.com/repository/spring" >https://maven.aliyun.com/repository/spring<i class="fas fa-external-link-alt"></i></a></url></p><p><code>                  </code><!--如何处理远程仓库里发布版本的下载 --></p><p><code>                  </code><releases></p><p><code>                      </code><enabled>true</enabled></p><p><code>                      </code><updatePolicy /></p><p><code>                      </code><checksumPolicy /></p><p><code>                  </code></releases></p><p><code>                  </code><!--如何处理远程仓库里快照版本的下载 --></p><p><code>                  </code><snapshots></p><p><code>                      </code><enabled /></p><p><code>                      </code><updatePolicy /></p><p><code>                      </code><checksumPolicy /></p><p><code>                  </code></snapshots></p><p><code>              </code></repository></p><p><code>          </code></repositories></p><p><code>      </code></profile></p><p><code>  </code></profiles></p><p><code>  </code><!-- 手动激活profiles的列表，按照profile被应用的顺序定义activeProfile。 --></p><p><code>  </code><!-- 该元素包含了一组activeProfile元素，每个activeProfile都含有一个profile id。 --></p><p><code>  </code><!-- 任何在activeProfile中定义的profile id，不论环境设置如何，其对应的 profile都会被激活。 --></p><p><code>  </code><!-- 如果没有匹配的profile，则什么都不会发生。 --></p><p><code>  </code><!-- 如果运行过程中找不到这样一个profile，Maven则会像往常一样运行。 --></p><p><code>  </code><activeProfiles></p><p><code>      </code><activeProfile>aliyunSpring</activeProfile></p><p><code>  </code></activeProfiles></p></settings><p>这个settings.xml里<localRepository>指定了自定义的仓库目录位置。后面定义了阿里云的spring仓库位置。</p><p>菜单File -&gt; Settings -&gt; Build, … -&gt; Build Tools -&gt; Maven，将两个Override都勾上，在User settings file里打开自己的settings.xml，点下面的“Apply”，就行了。</p><h3 id="0-1-3-代码提示"><strong>0.1.3 代码提示</strong></h3><p>格式化代码快捷键：Ctrl + Alt + L</p><p>不希望格式化代码时格式化注释：File -&gt; Settings -&gt; Editor -&gt; Code Style -&gt; Java，右边选择Javadoc将下面的Enable Javadoc formatting勾勾去掉。</p><p>不要提示Dangling Javadoc comment：File -&gt; Settings -&gt; Editor -&gt; Inspections -&gt;Java -&gt; Javadoc把对应项后面的勾勾去掉。在自动生成Javadoc时不写入悬空的注释。</p><p>不要Duplicated code提示：File -&gt; Settings -&gt; Editor -&gt; Inspections -&gt; General -&gt; Duplicated Code fragement把勾勾去掉。社区版好像没有这一项。</p><p>不要拼写检查：File -&gt; Settings -&gt; Editor -&gt; Inspections -&gt; Proofreading勾勾去掉，就没有拼写和语法检查了。</p><p>鼠标在类、方法、参数上悬停时出现相应说明信息：File -&gt; Settings -&gt; Editor -&gt; Code Editing右边把Show quick documentation on mouse hover打上勾。默认是有的。</p><p>经常会警告（黄色标签）声明，或者方法没有被使用。File -&gt; Settings -&gt; Editor -&gt; Inspections -&gt; Java -&gt; Declaration redundancy -&gt; Unused declaration去掉勾。或者搜索unused就可以找到。</p><h3 id="0-1-4-设置Java代码文件头"><strong>0.1.4 设置Java代码文件头</strong></h3><p>菜单File -&gt; Settings -&gt; Editor -&gt; File and Code Templates右边Includes -&gt; File Header，如下图所示输入作者信息，则新建Java Class文件时会自动加到头上。</p><h1><strong>一、基础篇</strong></h1><p><strong>前置知识：</strong></p><ul><li>Java基础语法</li><li>Spring与SpringMVC，知道Spring是用来管理bean，能够基于Restful实现页面请求交互功能</li><li>Mybatis与MyBatis-Plus，基于MyBatis和Mybatis-Plus能够开发出包含基础CRUD功能的Dao模块</li><li>数据库MySQL，能够读懂基础CRUD功能的SQL语句</li><li>服务器，知道服务器与Web工程的关系，熟悉Web服务器的配置</li><li>Maven，知道Maven的依赖关系，知道什么是依赖范围，依赖传递，排除依赖，可选依赖，继承</li><li>Web技术（含Vue，ElementUI），知道Vue如何发送ajax请求，如何获取响应数据，如何进行数据模型双向绑定</li></ul><p><strong>学习目标：</strong></p><ul><li>能够创建SpringBoot工程</li><li>基于SpringBoot实现ssm整合</li></ul><h2 id="1-1-快速上手SpringBoot"><strong>1.1 快速上手SpringBoot</strong></h2><p>在IDEA里新建一个Project，类型为Empty Project，名字为Springboot。IDEA里的Project相当于Eclipse里面的Work Space，只是一个容器或框架。后续的各个案例都将作为Module模块放在这个空的Project里面。</p><h3 id="1-1-1-IDEA联网版入门案例"><strong>1.1.1 IDEA联网版入门案例</strong></h3><p>需要用到Spring Intilalizr，社区版里没有。之前有Spring Assistant插件可以用，现在该插件已被Spring Boot Helper取代，激活收费$15。</p><p>略。</p><h3 id="1-1-2-官网创建版案例"><strong>1.1.2 官网创建版案例</strong></h3><p>到Spring官网<a class="link"   href="https://spring.io/" >https://spring.io/<i class="fas fa-external-link-alt"></i></a>，顶部的Projects里找到Spring Boot</p><p>或者直接<a class="link"   href="https://spring.io/projects/spring-boot" >https://spring.io/projects/spring-boot<i class="fas fa-external-link-alt"></i></a>进入，到最下面看到如下图标和链接</p><p>点击Spring Initializr进入定制页面，或者直接<a class="link"   href="https://start.spring.io/" >https://start.spring.io/<i class="fas fa-external-link-alt"></i></a>进入如下：</p><p>1、选择Maven Project</p><p>2、语言选择Java</p><p>3、Spring Boot的版本为当前最新版2.7.5</p><p>4、项目的元数据自定义，最后一项包名自动包含了项目名称，可以修改为短的</p><p>5、右侧Dependencies选择增加Spring Web</p><p>点击下方GENERATE按钮，会自动生成一个springboot_01_02_quickstart.zip压缩包并自动下载。解压缩后生成同名文件夹，把文件夹springboot_01_02_quickstart整个拷贝到项目文件夹（D:\id-space\Springboot）下。</p><p>在IDEA菜单File -&gt; Project Structure 看看JDK设置好没有</p><p>然后在下面Modules里面点击“+”Import Module添加一个模块，选中刚才拷贝过来的文件夹</p><p>中间注意要选中Maven类型</p><p>然后IDEA开始导入模块，如果是第一次，则开始下载Maven相关依赖包，插件等，需要几分钟。如“<a href="#_0.1.2_maven%E8%AE%BE%E7%BD%AE">0.1.2 Maven设置</a>”中的settings.xml中设置的是阿里云下载点，下载速度会很快。</p><p>Maven更新完成后，pom.xml文件可能会报错“spring-boot-maven-plugin not found”，如下增加一行版本号，与Initializr里使用的Spring Boot版本号一致。如果IDEA里安装了Maven Helper，则在这个文件上右键Maven -&gt; reimport更新即可。</p><p>在src/main/java/cn/zlz8x8下新建一个包controller，下面新建一个类BookControllerr如下。如果前面步骤都正常的话，在写上面代码时应正常出现代码补全的提示，并会自动根据代码在import载入相应的包。</p><p>package cn.zlz8x8.controller;</p><p>import org.springframework.web.bind.annotation.GetMapping;</p><p>import org.springframework.web.bind.annotation.RequestMapping;</p><p>import org.springframework.web.bind.annotation.RestController;</p><p>//Rest模式</p><p>@RestController</p><p>@RequestMapping(“/books”)</p><p>public class BookController {</p><p><code>  </code>@GetMapping</p><p><code>  </code>public String getById() {</p><p><code>      </code>System.out.println(“springboot is running …”);</p><p><code>      </code>return “springboot is running …”;</p><p><code>  </code>}</p><p>}</p><p>运行Springboot0102QuickstartApplication.java，文件上右键run，或者打开这个文件，工具栏上自动会有run的图标。</p><p>控制台会显示如上输出，最后一行springboot is running并没有。</p><p>打开浏览器，输入<a class="link"   href="http://localhost:8080/books" >http://localhost:8080/books<i class="fas fa-external-link-alt"></i></a>，则会看到浏览器的输出，同时上面控制台也会输出最后一行springboot is running</p><p>工具栏上红色方块停止按钮可以停止运行。</p><h3 id="1-1-3-阿里云版案例"><strong>1.1.3 阿里云版案例</strong></h3><p>仍然要用到Spring Initializr，IDAE社区版没有。只是把Initailizr里的创建地址<a class="link"   href="https://start.spring.io" >https://start.spring.io<i class="fas fa-external-link-alt"></i></a>换成了<a class="link"   href="https://start.aliyun.com" >https://start.aliyun.com<i class="fas fa-external-link-alt"></i></a>而已。</p><p>进入<a class="link"   href="https://start.aliyun.com/bootstrap.html" >https://start.aliyun.com/bootstrap.html<i class="fas fa-external-link-alt"></i></a>可以看到与Spring官网类似的在线生成器，但是Spring Boot的版本过低。但依赖包比官网多一些，比如有MyBatis-Plus</p><p>这部分略过。</p><h3 id="1-1-4-手工制作版案例"><strong>1.1.4 手工制作版案例</strong></h3><p>在项目Springboot下新建一个Module，Build system选择Maven，需要修改的是Name和GroupId，其他的会自动生成。点击按钮Create就可以创建一个Maven模块。</p><p>修改pom.xml，参照“<a href="#_1.1.2_%E5%AE%98%E7%BD%91%E5%88%9B%E5%BB%BA%E7%89%88%E6%A1%88%E4%BE%8B">1.1.2 官网创建版案例</a>”拷贝有用的部分，主要是<parent>，<dependencies>和<build>的内容，<properties>里的内容可以保持不变。最终如下：</p><p>如果安装了Maven Helper插件，文件上会出现一个悬浮刷新按钮，修改完点击刷新，没有报错即可。</p><?xml version="1.0" encoding="UTF-8"?><p>&lt;project xmlns=“<a class="link"   href="http://maven.apache.org/POM/4.0.0" >http://maven.apache.org/POM/4.0.0<i class="fas fa-external-link-alt"></i></a>”</p><p><code>       </code>xmlns:xsi=“<a class="link"   href="http://www.w3.org/2001/XMLSchema-instance" >http://www.w3.org/2001/XMLSchema-instance<i class="fas fa-external-link-alt"></i></a>”</p><p><code>       </code>xsi:schemaLocation=“<a class="link"   href="http://maven.apache.org/POM/4.0.0" >http://maven.apache.org/POM/4.0.0<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="http://maven.apache.org/xsd/maven-4.0.0.xsd" >http://maven.apache.org/xsd/maven-4.0.0.xsd<i class="fas fa-external-link-alt"></i></a>”&gt;</p><p><code>  </code><modelVersion>4.0.0</modelVersion></p><p><code>  </code><parent></p><p><code>      </code><groupId>org.springframework.boot</groupId></p><p><code>      </code><artifactId>spring-boot-starter-parent</artifactId></p><p><code>      </code><version>2.7.5</version></p><p><code>      </code><relativePath/> <!-- lookup parent from repository --></p><p><code>  </code></parent></p><p><code>  </code><groupId>cn.zlz8x8</groupId></p><p><code>  </code><artifactId>springboot_01_04_quickstart</artifactId></p><p><code>  </code><version>1.0-SNAPSHOT</version></p><p><code>  </code><properties></p><p><code>      </code>&lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;</p><p><code>      </code>&lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;</p><p><code>      </code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</p><p><code>  </code></properties></p><p><code>  </code><dependencies></p><p><code>      </code><dependency></p><p><code>          </code><groupId>org.springframework.boot</groupId></p><p><code>          </code><artifactId>spring-boot-starter-web</artifactId></p><p><code>      </code></dependency></p><p><code>      </code><dependency></p><p><code>          </code><groupId>org.springframework.boot</groupId></p><p><code>          </code><artifactId>spring-boot-starter-test</artifactId></p><p><code>          </code><scope>test</scope></p><p><code>      </code></dependency></p><p><code>  </code></dependencies></p><p><code>  </code><build></p><p><code>      </code><plugins></p><p><code>          </code><plugin></p><p><code>              </code><groupId>org.springframework.boot</groupId></p><p><code>              </code><artifactId>spring-boot-maven-plugin</artifactId></p><p><code>          </code></plugin></p><p><code>      </code></plugins></p><p><code>  </code></build></p></project><p>前面创建Module时，Add sample code打了勾，因此已经有一个cn.zlz8x8.Main文件，同样参照“<a href="#_1.1.2_%E5%AE%98%E7%BD%91%E5%88%9B%E5%BB%BA%E7%89%88%E6%A1%88%E4%BE%8B">1.1.2 官网创建版案例</a>”修改如下：</p><p>package cn.zlz8x8;</p><p>import org.springframework.boot.SpringApplication;</p><p>import org.springframework.boot.autoconfigure.SpringBootApplication;</p><p>@SpringBootApplication</p><p>public class Main {</p><p><code>  </code>public static void main(String[] args) {</p><p><code>      </code>SpringApplication.run(Main.class, args);</p><p><code>  </code>}</p><p>}</p><p>同样参照“<a href="#_1.1.2_%E5%AE%98%E7%BD%91%E5%88%9B%E5%BB%BA%E7%89%88%E6%A1%88%E4%BE%8B">1.1.2 官网创建版案例</a>”，新建一个包cn.zlz8x8.controller，把之前的BookController.java拷贝到这个包里，可以稍微修改一下输出，如下：</p><p>package cn.zlz8x8.controller;</p><p>import org.springframework.web.bind.annotation.GetMapping;</p><p>import org.springframework.web.bind.annotation.RequestMapping;</p><p>import org.springframework.web.bind.annotation.RestController;</p><p>//Rest模式</p><p>@RestController</p><p>@RequestMapping(“/books”)</p><p>public class BookController {</p><p><code>  </code>@GetMapping</p><p><code>  </code>public String getById() {</p><p><code>      </code>System.out.println(“控制台: springboot is running … 4”);</p><p><code>      </code>return “页面: springboot is running … 4”;</p><p><code>  </code>}</p><p>}</p><p>然后运行Main，看控制台和浏览器输出（中文显示正常） … 停止。</p><h3 id="1-1-5-IDEA隐藏文件"><strong>1.1.5 IDEA隐藏文件</strong></h3><p>对比上面1.1.2和1.1.4会发现，手工创建的Module清爽很多。</p><p>可以把多余的文件删除，又担心会出什么问题，那么就可以把这些文件或目录隐藏。</p><p>菜单File -&gt; Settings -&gt; Editor -&gt; File Types，右边标签页，点“+”将需要隐藏的文件名添加进去即可。例如.mvn，.gitignore，HELP.md等，可以用通配符 * ，使用通配符时注意别把需要的文件隐藏了。</p><h3 id="1-1-6-入门案例解析：parent、starter"><strong>1.1.6 入门案例解析：parent、starter</strong></h3><p><strong>Spring Boot的目的是用来简化Spring应用的初始搭建及开发过程。</strong></p><p>关键的pom.xml中可以看出，parent里定义的版本号2.7.5实际上就已经包含了几乎所有依赖包的版本号，经过测试，相互之间没有冲突。更改parent里的版本号，实际上相当于更换了了所有依赖包的版本号集合。</p><p>后面<depandencies>里面根据需要引入依赖包，不用版本号。在IDEA里点击编辑器左边的小按钮可以直达相应引用处，看到依赖包定义的版本号。</p><p>后面<plugins>里面也不需要版本号，也都在parent里定义了。“<a href="#_1.1.2_%E5%AE%98%E7%BD%91%E5%88%9B%E5%BB%BA%E7%89%88%E6%A1%88%E4%BE%8B">1.1.2官网创建版案例</a>”里提到：pom.xml文件可能会报错“spring-boot-maven-plugin not found”，需增加一行版本号，这种情况不常见。</p><p>Maven会根据pom.xml定义的依赖，将相应依赖包的正确版本下载到本地Maven Repository里，因此第一次创建的时候会需要几分钟。如果后续再创建Spring Boot项目，只要主版本号没变，则不联网也可以创建成功。</p><p>其中最重要的是<depandencies>下面的spring-boot-starter-web，点击左侧按钮，直达引用处，可以看到包含了spring-boot-starter、srping-boot-starter-tomcat、spring-web等包，这些也不是最终的依赖包，也是一系列依赖包的集合，向下层层扩展，形成了一个依赖包树形结构，最终用spring-boot-starter-web一行就解决了，不用自己手工罗列，也不用管版本之间的兼容和冲突。</p><p><strong>总结</strong>：parent定义了所有Spring Boot项目要继承的依赖包版本号，主要是进行依赖管理，达到减少依赖冲突的目的。而starter定义了当前项目使用的所有依赖包，以达到减少依赖配置工作量的目的。</p><h3 id="1-1-7-入门案例解析：引导类"><strong>1.1.7 入门案例解析：引导类</strong></h3><p>以“<a href="#_1.1.4_%E6%89%8B%E5%B7%A5%E5%88%B6%E4%BD%9C%E7%89%88%E6%A1%88%E4%BE%8B">1.1.4 手工制作版案例</a>”生成的项目为例。将cn.zlz8x8.Main改写为如下：</p><p>package cn.zlz8x8;</p><p>import cn.zlz8x8.controller.BookController;</p><p>import org.springframework.boot.SpringApplication;</p><p>import org.springframework.boot.autoconfigure.SpringBootApplication;</p><p>import org.springframework.context.ConfigurableApplicationContext;</p><p>@SpringBootApplication</p><p>public class Main {</p><p><code>  </code>public static void main(String[] args) {</p><p><code>      </code>ConfigurableApplicationContext ctx = SpringApplication.run(Main.class, args);</p><p><code>      </code>//SpringApplicaiton.run 实际上是生成了一个Spring容器，也就是上下文Context</p><p><code>      </code>//项目里的其他 类（对象） 都是 bean 被放到了Spring容器里，如下</p><p><code>      </code>BookController beanBookController = ctx.getBean(BookController.class);</p><p><code>      </code>System.out.println(“这是一个Bean：” + beanBookController);</p><p><code>      </code>DemoUser beanDemoUser = ctx.getBean(DemoUser.class);</p><p><code>      </code>System.out.println(“这又是一个 bean：” + beanDemoUser);</p><p><code>  </code>}</p><p>}</p><p>为了上面代码最后两行正确执行，新建一个cn.zlz8x8.DemoUser类如下，空的，不需要执行任何功能，注意@Component不能少。</p><p>package cn.zlz8x8;</p><p>import org.springframework.stereotype.Component;</p><p>@Component</p><p>public class DemoUser {</p><p>}</p><p>然后执行Main看输出。可知引导类SpringApplication.run生成了一个Spring容器。</p><h3 id="1-1-8-内嵌Tomcat"><strong>1.1.8 内嵌Tomcat</strong></h3><p>从自己的pom.xml里<artifactId>spring-boot-starter-web</artifactId>处点左边小按钮，或者快捷键Ctrl + B，就可以打开 spring-boot-dependencies-2.7.5.pom，然后在<artifactId>spring-boot-starter-web</artifactId>同样快捷键Ctrl + B，就可以打开spring-boot-starter-web-2.7.5.pom，可以看到如下<artifactId>spring-boot-starter-tomcat</artifactId>一行，还可以继续扩展看这里面都有什么。正是有了这一行，我们的Spring Boot程序里自带了内嵌的Tomcat。</p><p>如果不想用内嵌的Tomcat，或者想换成Jetty，则在我们自己的pom.xml里如下处理：</p><p>改为如上内容后，右侧Maven工具栏展开，点刷新，可以看到很快就下载了jetty包。</p><h3 id="1-1-9-RESTful快速开发"><strong>1.1.9 RESTful快速开发</strong></h3><p><strong>第一步：REST简介</strong></p><p>REST = Representational State Transfer</p><p>特点：隐藏接口的访问行为，无法通过地址得知对接口的操作；书写简化</p><p>根据REST风格对接口（资源）进行访问称为RESTful</p><p>传统风格访问接口描述形式：</p><p><a class="link"   href="http://localhost/user/getById?=1" >http://localhost/user/getById?=1<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="http://localhost/user/saveUser" >http://localhost/user/saveUser<i class="fas fa-external-link-alt"></i></a></p><p>REST风格接口描述形式：</p><table><thead><tr><th><a class="link"   href="http://localhost/users" >http://localhost/users<i class="fas fa-external-link-alt"></i></a></th><th>查询全部用户信息</th><th>GET（查询）</th></tr></thead><tbody><tr><td><a class="link"   href="http://localhost/users/1" >http://localhost/users/1<i class="fas fa-external-link-alt"></i></a></td><td>查询全部指定信息</td><td>GET（查询）</td></tr><tr><td><a class="link"   href="http://localhost/users" >http://localhost/users<i class="fas fa-external-link-alt"></i></a></td><td>添加用户信息</td><td>POST（新增/保存）</td></tr><tr><td><a class="link"   href="http://localhost/users" >http://localhost/users<i class="fas fa-external-link-alt"></i></a></td><td>修改用户信息</td><td>PUT（修改/更新）</td></tr><tr><td><a class="link"   href="http://localhost/users/1" >http://localhost/users/1<i class="fas fa-external-link-alt"></i></a></td><td>删除用户信息</td><td>DELETE（删除）</td></tr></tbody></table><p>用postman可以看到对接口有多种动作，Spring Boot支持的包括上述等8种。</p><p>到<a class="link"   href="https://www.postman.com/" >https://www.postman.com/<i class="fas fa-external-link-alt"></i></a>注册一个免费用户，激活注册用的邮箱。就可以开始使用postman了。使用方式主要有三种：（1）在postman官网在线使用；（2）利用Chrome的插件在线使用；（3）下载postman的桌面程序在线使用。这三种方式都要求在线使用。本例下载了postman的Windows桌面程序，安装之后登录、在线使用。</p><p><strong>第二步：RESTful入门案例</strong></p><p>首先，采用复制的方式新建一个Module，如“<a href="#_1.2.1_%E6%A8%A1%E5%9D%97module%E5%A4%8D%E5%88%B6">1.2.1 模块Module复制</a>”，名称为Springboot_01_06_rest，在其中新建一个类cn.zlz8x8.controller.UserController如下。</p><p>可以看出一个API主要有两部分：</p><p>@RequestMapping 首先指定API调用的路径，跟着是参数的调用形式。然后是调用的动作，POST、PUT、DELETE等。调用路径 /users/{userName} 对应的真实调用路径为<a class="link"   href="http://localhost:8080/users/Tom%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BD%BF%E7%94%A8%E7%9A%84%E5%86%85%E7%BD%AETomcat%EF%BC%8C%E9%BB%98%E8%AE%A4%E7%AB%AF%E5%8F%A3%E6%98%AF8080%EF%BC%8C%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8F%82%E6%95%B0%E5%B0%B1%E6%98%AFTom%E3%80%82" >http://localhost:8080/users/Tom，因为使用的内置Tomcat，默认端口是8080，对应的参数就是Tom。<i class="fas fa-external-link-alt"></i></a></p><p>@ResponseBogy 里面的方法就是获得API传参后如何处理，下面都只做了简单输出，实际项目则可以进行希望的操作。里面的@PathVariable指明参数取自路径后面的哪部分。</p><p>package cn.zlz8x8.controller;</p><p>import org.springframework.stereotype.Controller;</p><p>import org.springframework.web.bind.annotation.PathVariable;</p><p>import org.springframework.web.bind.annotation.RequestMapping;</p><p>import org.springframework.web.bind.annotation.RequestMethod;</p><p>import org.springframework.web.bind.annotation.ResponseBody;</p><p>@Controller</p><p>public class UserController {</p><p><code>  </code>@RequestMapping(value = “/users/{userName}”, method = RequestMethod.POST)</p><p><code>  </code>@ResponseBody</p><p><code>  </code>public String save(@PathVariable String userName){</p><p><code>      </code>System.out.println(“user save …” + userName);</p><p><code>      </code>return “{‘module’: ‘user save’}”;</p><p><code>  </code>}</p><p><code>  </code>@RequestMapping(value = “/users/{id}”, method = RequestMethod.DELETE)</p><p><code>  </code>@ResponseBody</p><p><code>  </code>public String delete(@PathVariable Integer id){</p><p><code>      </code>System.out.println(“user delete …” + id);</p><p><code>      </code>return “{‘module’: ‘user delete’}”;</p><p><code>  </code>}</p><p><code>  </code>@RequestMapping(value = “/users/{userName}”, method = RequestMethod.PUT)</p><p><code>  </code>@ResponseBody</p><p><code>  </code>public String update(@PathVariable String userName){</p><p><code>      </code>System.out.println(“user update …” + userName);</p><p><code>      </code>return “{‘module’: ‘user update’}”;</p><p><code>  </code>}</p><p><code>  </code>@RequestMapping(value = “/users/{id}”, method = RequestMethod.GET)</p><p><code>  </code>@ResponseBody</p><p><code>  </code>public String getById(@PathVariable Integer id){</p><p><code>      </code>System.out.println(“user getById …” + id);</p><p><code>      </code>return “{‘module’: ‘user getById’}”;</p><p><code>  </code>}</p><p><code>  </code>@RequestMapping(value = “/users”, method = RequestMethod.GET)</p><p><code>  </code>@ResponseBody</p><p><code>  </code>public String getAll(){</p><p><code>      </code>System.out.println(“user getAll …”);</p><p><code>      </code>return “{‘module’: ‘user getAll’}”;</p><p><code>  </code>}</p><p>}</p><p>将这个模块运行起来。打开postman，可以发送不同的请求看结果以及IDEA控制台的输出。可以将若干个请求保存到一个collection里面，今后不需要重复输入，直接可以测试。本例中将对应上面5个API的请求保存到了一个名为Springboot_01_06_rest的集合里。</p><p><strong>注意：</strong></p><ul><li>后期开发中，参数超过1个，以json格式为主，@RequestBody应用较广，用于接收json数据。</li><li>如果发送非json格式参数，选用@RequestParam接收参数，用于url地址传参或表单传参。</li><li>采用RESTful进行开发，如果参数较少，可以采用@PathVariable接收路径参数。</li></ul><p><strong>第三步：简化开发</strong></p><p>复制生成的Springboot_01_06_rest里有一个cn.8x8.controller.BookController几乎是空的，将其改写如下，与上面的UserController进行对比。API的功能和调用方式完全一样，但是代码简洁了许多。</p><p>1、原来类名上有个@Controller，方法名上有个@ResponseBody，将所有方法名上的@ResponseBody合并提升到类名上。然后再将@Controller和@ResponseBody合并成了@RestController</p><p>2、原来方法名上相同的@RequestMapping(value = “/books” 合并提升到了类名上。剩下的方法动作 method = … 简化成了对应的@PostMapping、@DeleteMapping、@PutMapping和@GetMapping，里面的参数简化了相同路径部分（合并到了类名上面）。</p><p>package cn.zlz8x8.controller;</p><p>import org.springframework.web.bind.annotation.*;</p><p>@RestController</p><p>@RequestMapping(“/books”)</p><p>public class BookController {</p><p><code>  </code>@PostMapping(“/{userName}”)</p><p><code>  </code>public String save(@PathVariable String userName){</p><p><code>      </code>System.out.println(“book save …” + userName);</p><p><code>      </code>return “{‘module’: ‘book save’}”;</p><p><code>  </code>}</p><p><code>  </code>@DeleteMapping(“/{id}”)</p><p><code>  </code>public String delete(@PathVariable Integer id){</p><p><code>      </code>System.out.println(“book delete …” + id);</p><p><code>      </code>return “{‘module’: ‘book delete’}”;</p><p><code>  </code>}</p><p><code>  </code>@PutMapping(“/{userName}”)</p><p><code>  </code>public String update(@PathVariable String userName){</p><p><code>      </code>System.out.println(“book update …” + userName);</p><p><code>      </code>return “{‘module’: ‘book update’}”;</p><p><code>  </code>}</p><p><code>  </code>@GetMapping(“/{id}”)</p><p><code>  </code>public String getById(@PathVariable Integer id){</p><p><code>      </code>System.out.println(“book getById …” + id);</p><p><code>      </code>return “{‘module’: ‘book getById’}”;</p><p><code>  </code>}</p><p><code>  </code>@GetMapping</p><p><code>  </code>public String getAll(){</p><p><code>      </code>System.out.println(“book getAll …”);</p><p><code>      </code>return “{‘module’: ‘book getAll’}”;</p><p><code>  </code>}</p><p>}</p><p>在postman里测试，在原来的测试集下建两个目录，对应Users和Books，然后将不同的请求保存到对应的目录里，方便今后测试，不用重复输入。</p><h2 id="1-2-SpringBoot基础配置"><strong>1.2 SpringBoot基础配置</strong></h2><h3 id="1-2-1-模块Module复制"><strong>1.2.1 模块Module复制</strong></h3><p><strong>第一步：选定要复制的Module并简化</strong></p><p>“<a href="#_1.1.2_%E5%AE%98%E7%BD%91%E5%88%9B%E5%BB%BA%E7%89%88%E6%A1%88%E4%BE%8B">1.1.2 官网创建版</a>”里创建的springboot_01_02_quickstart是用官网Initializr创建的，把它作为要复制的目标。首先进行简化。</p><p>将pom.xml修改简化如下。主要修改的内容：</p><p>1、删除了<name>和<description>，这样在IDEA显示的时候找不到<name>就以<artifactId>显示。今后导入Module的时候只需要修改<artifactId>就行了。</p><p>2、保留了<dependecies>里面的spring-boot-starter-test，以后用得着。</p><p>3、插件<plugin>里面删除了版本号。本来就是不需要，在starter里已定义了。</p><?xml version="1.0" encoding="UTF-8"?><p>&lt;project xmlns=“<a class="link"   href="http://maven.apache.org/POM/4.0.0" >http://maven.apache.org/POM/4.0.0<i class="fas fa-external-link-alt"></i></a>” xmlns:xsi=“<a class="link"   href="http://www.w3.org/2001/XMLSchema-instance" >http://www.w3.org/2001/XMLSchema-instance<i class="fas fa-external-link-alt"></i></a>”</p><p><code></code>xsi:schemaLocation=“<a class="link"   href="http://maven.apache.org/POM/4.0.0" >http://maven.apache.org/POM/4.0.0<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://maven.apache.org/xsd/maven-4.0.0.xsd" >https://maven.apache.org/xsd/maven-4.0.0.xsd<i class="fas fa-external-link-alt"></i></a>”&gt;</p><p><code></code><modelVersion>4.0.0</modelVersion></p><p><code></code><parent></p><p><code></code><groupId>org.springframework.boot</groupId></p><p><code></code><artifactId>spring-boot-starter-parent</artifactId></p><p><code></code><version>2.7.5</version></p><p><code></code></parent></p><p><code></code><groupId>cn.zlz8x8</groupId></p><p><code></code><artifactId>springboot_01_02_quickstart</artifactId></p><p><code></code><version>0.0.1-SNAPSHOT</version></p><p><code></code><properties></p><p><code></code>&lt;java.version&gt;1.8&lt;/java.version&gt;</p><p><code></code></properties></p><p><code></code><dependencies></p><p><code></code><dependency></p><p><code></code><groupId>org.springframework.boot</groupId></p><p><code></code><artifactId>spring-boot-starter-web</artifactId></p><p><code></code></dependency></p><p><code></code><dependency></p><p><code></code><groupId>org.springframework.boot</groupId></p><p><code></code><artifactId>spring-boot-starter-test</artifactId></p><p><code></code><scope>test</scope></p><p><code></code></dependency></p><p><code></code></dependencies></p><p><code></code><build></p><p><code></code><plugins></p><p><code></code><plugin></p><p><code></code><groupId>org.springframework.boot</groupId></p><p><code></code><artifactId>spring-boot-maven-plugin</artifactId></p><p><code></code></plugin></p><p><code></code></plugins></p><p><code></code></build></p></project><p>springboot_01_02_quickstart里面的代码文件cn.zlz8x8.Springboot0102QuickstartApplication.java和cn.zlz8x8.controller.BookController只有几行基础代码，不需要修改。非常长的名字可以在复制之后修改。</p><p>至此，要复制的Module就准备好了，这个Module以后就不动了，专门用来复制成新的模块。当然，每次从官网创建也可以。</p><p><strong>第二步：复制</strong></p><p>到IDEA工作空间的Springboot项目下，本例是D:\id-space\Springboot</p><p>复制文件夹springboot_01_02_quickstart到同一个目录，形成副本，然后将文件夹名称改为新的模块名称，springboot_01_06_rest，进入这个文件夹。</p><p>删除目录下的子目录.mvn，删除子目录target，删除除pom.xml之外的其他文件，最后只剩文件夹src和文件pom.xml，如下：</p><p>用其他文本编辑器，如VSCode等打开pom.xml，修改<artifactId>里面的值为springboot_01_06_rest，与模块名一致。</p><p><strong>第三步，IDEA导入</strong></p><p>IDEA菜单File -&gt; Project Structure，在下面Modules里面点击“+”Import Module添加一个模块，选中刚才复制生成的springboot_01_06_rest文件夹，弹出对话框注意要选中Maven类型。然后就完事了，导入顺利，没有报错。</p><p>此时主文件还是cn.zlz8x8.Springboot0102QuickstartApplication.java，在此文件上右键Refactor -&gt; rename …，将名称改为Springboot0106RestApplication，就自动将文件里的类名等都相应更改了，如果项目里其他地方有引用，也一并改了。今后改类名、方法名、变量名都用Refactor，不要手工改。运行此文件，看效果。</p><p><strong>模块复制完成。今后只用从第二步开始。</strong></p><h3 id="1-2-2-属性配置方式"><strong>1.2.2 属性配置方式</strong></h3><p>默认内置的Tomcat端口是8080，比较麻烦。修改resources目录下的application.properties文件，打开看到是空的，添加server.port=80如下设置，启动项目，日志看到端口已变更为80，然后到postman修改调用url把8080端口号去掉，测试。</p><p><strong>IDEA社区版修改application.properties没有高亮颜色、代码提示和补全，几个插件用了也没效果，关系不大。以后用yml配置，就有提示和代码补全了。需要安装插件Spring Boot Assistant，这跟之前的插件Spring Assistant不一样（这个插件现在已经没有了，改成了收费插件）。不同IDEA版本现象不一样，网上搜解决方法。</strong></p><h3 id="1-2-3-基础配置"><strong>1.2.3 基础配置</strong></h3><p>上面的application.properties文件再加一行 spring.main.banner-mode=off</p><p>启动程序，发现控制台的Spring的字符画就没有了。也可以进行一些其他设置。</p><p>设置项非常多。到官网 <a class="link"   href="https://spring.io/projects/spring-boot#learn" >https://spring.io/projects/spring-boot#learn<i class="fas fa-external-link-alt"></i></a> 下面的Documentation，找到与正在用的版本最接近的版本，点右侧的Reference Doc</p><p>下一个页面找到下面附件中 Application Properties点进去就可以看到所有配置参数、解释、默认值等。</p><h3 id="1-2-4-配置文件类型"><strong>1.2.4 配置文件类型</strong></h3><p>application.properties</p><p>server.port=80</p><p>application.yml</p><p>server:</p><p><code>  </code>port: 80</p><p>application.yaml</p><p>server:</p><p><code>  </code>port: 80</p><p><strong>Spring Boot配置文件的加载有先后顺序：yaml，yml，properties</strong>，后加载的会把先加载的覆盖。因此使用yml时，要先把properties移走。</p><p>上一小节中的resources目录下新建一个目录bak，把application.properties文件移进去，然后再新建一个application.yml文件。按前面格式设定端口，编辑时有代码提示和补全，运行，发现有效。</p><p>同样把yml移到bak目录，新建一个application.yaml，内容如上。测试。</p><p><strong>今后的开发中，主要用yml格式进行配置。</strong></p><h3 id="1-2-5-yaml数据格式"><strong>1.2.5 yaml数据格式</strong></h3><p>Yaml优点：容易阅读，容易与脚本语言交互，以数据为中心，重数据轻格式。</p><p>扩展名：yml 或 yaml</p><p>Yaml语法规则：</p><ul><li>大小写敏感</li><li>属性层级关系用多行，属性名（key）和属性值（value）之间用“<strong>冒号+空格</strong>”</li><li>使用缩进表示层级关系，同层级左侧对齐，缩进只能用空格不能用Tab</li><li>注释用#</li></ul><p>对象与数组的格式与json类似，不赘述。下一小节有示例。</p><h3 id="1-2-6-读取yml数据"><strong>1.2.6 读取yml数据</strong></h3><p>下面的综合实例展示了：</p><ol><li>读取单一属性数据</li><li>读取二级属性数据</li><li>读取数组元素数据</li><li>读取数组元素二级数据</li><li>读取引用数据</li><li>用env读取全部属性数据</li><li>使用类封装yml数据</li></ol><p><strong>步骤一：准备application.yml文件</strong></p><p>server:</p><p><code>  </code>port: 80</p><p>spring:</p><p><code>  </code>main:</p><p><code>  </code>banner-mode: off</p><p># 以下是自定义属性</p><p>country: China</p><p>province: 湖北</p><p>city: Wuhan</p><p>user1:</p><p><code>  </code>name: cat</p><p><code>  </code>age: 29</p><p><code>  </code>married: true</p><p>user2:</p><p><code>  </code>name: dog</p><p><code>  </code>age: 20</p><p># 数组，其中有数据引用，与顺序无关</p><p>hobbies:</p><p><code>  </code>- video ${habbits[0]}</p><p><code>  </code>- basketball</p><p><code>  </code>- swiming</p><p># 数组简单形式，双引号内可解析转义字符</p><p>habbits: [game, “mu\t\nsic”, sleep]</p><p># 对象数组</p><p>users1:</p><p><code>  </code>- name: Alton John</p><p><code>  </code>age: 65</p><p><code>  </code>birthday: 1949-10-01</p><p><code>  </code>- name: Poppy Alex</p><p><code>  </code>age: 19</p><p># 对象数组简单形式</p><p>users2: [{name: Tylor Swift, age: 24, birthday: 2000-11-11}, {name: 李小龙, age: 46}]</p><p><strong>步骤二：准备User1.java封装yml结构化数据</strong></p><p>首先定义类的变量，然后可以用IDEA自动生成get，set，toString方法的代码。</p><p>package cn.zlz8x8.controller;</p><p>import org.springframework.boot.context.properties.ConfigurationProperties;</p><p>import org.springframework.stereotype.Component;</p><p>/* 定义User1类封装yml文件中对应的结构化数据</p><p><code> </code>* 定义User1类为Spring管理的bean，头上加@Component</p><p><code> </code>* 指定加载的数据，@ConfigureationProperties</p><p><code> </code>*/</p><p>@Component</p><p>@ConfigurationProperties(prefix = “user1”)</p><p>public class User1 {</p><p><code>  </code>private String name;</p><p><code>  </code>private int age;</p><p><code>  </code>private Boolean married;</p><p><code>  </code>@Override</p><p><code>  </code>public String toString() {</p><p><code>      </code>return “User1{” +</p><p><code>              </code>“name='” + name + ‘'’ +</p><p><code>              </code>“, age=” + age +</p><p><code>              </code>“, married=” + married +</p><p><code>              </code>‘}’;</p><p><code>  </code>}</p><p><code>  </code>public String getName() {</p><p><code>      </code>return name;</p><p><code>  </code>}</p><p><code>  </code>public void setName(String name) {</p><p><code>      </code><a class="link"   href="http://this.name" >this.name<i class="fas fa-external-link-alt"></i></a> = name;</p><p><code>  </code>}</p><p><code>  </code>public int getAge() {</p><p><code>      </code>return age;</p><p><code>  </code>}</p><p><code>  </code>public void setAge(int age) {</p><p><code>      </code>this.age = age;</p><p><code>  </code>}</p><p><code>  </code>public Boolean getMarried() {</p><p><code>      </code>return married;</p><p><code>  </code>}</p><p><code>  </code>public void setMarried(Boolean married) {</p><p><code>      </code>this.married = married;</p><p><code>  </code>}</p><p>}</p><p><strong>步骤三：改写BookController.java</strong></p><p>package cn.zlz8x8.controller;</p><p>import org.springframework.beans.factory.annotation.Autowired;</p><p>import org.springframework.beans.factory.annotation.Value;</p><p>import org.springframework.core.env.Environment;</p><p>import org.springframework.web.bind.annotation.*;</p><p>@RestController</p><p>@RequestMapping(“/books”)</p><p>public class BookController {</p><p><code>  </code>//读取yml数据</p><p><code>  </code>@Value(“${province}”)</p><p><code>  </code>private String country; // 上面定义的属性名不需要与变量名一致，数据为中文“湖北”</p><p><code>  </code>@Value(“${user1.age}”)</p><p><code>  </code>private int age;</p><p><code>  </code>@Value(“${habbits[1]}”)</p><p><code>  </code>private String hab1;</p><p><code>  </code>@Value(“${users1[0].birthday}”)</p><p><code>  </code>private String user1birth;</p><p><code>  </code>@Value(“${hobbies[0]}”)</p><p><code>  </code>private String hob1;</p><p><code>  </code>//使用自动装配，将所有yml里的数据读取到env中</p><p><code>  </code>//注意有多个Environment类，选择 org.springframework.core.env</p><p><code>  </code>@Autowired</p><p><code>  </code>private Environment env;</p><p><code>  </code>// 使用类封装yml数据，使用自动装配@Autowired</p><p><code>  </code>@Autowired</p><p><code>  </code>private User1 myUser1;</p><p><code>  </code>@GetMapping</p><p><code>  </code>public String getAll(){</p><p><code>      </code>System.out.println(“book getAll …”);</p><p><code>      </code>System.out.println(&quot;从yml文件中读取的单一属性数据：country ====&gt; &quot; + this.country);</p><p><code>      </code>System.out.println(&quot;从yml文件中读取的二级属性数据：user1.age ====&gt; &quot; + this.age);</p><p><code>      </code>System.out.println(&quot;从yml文件中读取的数组元素数据：habbits[1] ====&gt; &quot; + this.hab1);</p><p><code>      </code>System.out.println(&quot;从yml文件中读取的数组元素二级数据：users1[0].birthday ====&gt; &quot; + this.user1birth);</p><p><code>      </code>System.out.println(&quot;从yml文件中读取的引用数据：hobbies[0] ====&gt; &quot; + this.hob1);</p><p><code>      </code>System.out.println(&quot;用env读取全部数据并取出users2[1].name ====&gt; &quot; + env.getProperty(“users2[1].name”));</p><p><code>      </code>System.out.println(&quot;使用类封装的yml数据：User1 ====&gt; &quot; + myUser1.toString());</p><p><code>      </code>return “{‘module’: ‘book getAll’}”;</p><p><code>  </code>}</p><p><code>  </code>@PostMapping(“/{userName}”)</p><p><code>  </code>public String save(@PathVariable String userName){</p><p><code>      </code>System.out.println(“book save …” + userName);</p><p><code>      </code>return “{‘module’: ‘book save’}”;</p><p><code>  </code>}</p><p><code>  </code>@DeleteMapping(“/{id}”)</p><p><code>  </code>public String delete(@PathVariable Integer id){</p><p><code>      </code>System.out.println(“book delete …” + id);</p><p><code>      </code>return “{‘module’: ‘book delete’}”;</p><p><code>  </code>}</p><p><code>  </code>@PutMapping(“/{userName}”)</p><p><code>  </code>public String update(@PathVariable String userName){</p><p><code>      </code>System.out.println(“book update …” + userName);</p><p><code>      </code>return “{‘module’: ‘book update’}”;</p><p><code>  </code>}</p><p><code>  </code>@GetMapping(“/{id}”)</p><p><code>  </code>public String getById(@PathVariable Integer id){</p><p><code>      </code>System.out.println(“book getById …” + id);</p><p><code>      </code>return “{‘module’: ‘book getById’}”;</p><p><code>  </code>}</p><p>}</p><p>然后运行，看控制台输出。</p><h2 id="1-3-基于SpringBoot实现SSM整合"><strong>1.3 基于SpringBoot实现SSM整合</strong></h2><h3 id="a-name-1-3-1-官网创建新模块-a-1-3-1-官网创建新模块"><a name="_1.3.1_官网创建新模块"></a><strong>1.3.1 官网创建新模块</strong></h3><p>本小节内容可选。</p><p>从官网创建新模块的目的是为后面的内容生成一个干净的基准模块。</p><p>如下图所示，Spring Boot版本已经升到了2.7.6，另外除了基本Spring Web的依赖包，还选择了Spring Boot Dev Tools包和Spring Configuration Processor包。</p><p>选择后两个包的目的是想试一下Dev Tools好不好用，另外application.properties会不会出现代码提示和补全。结果不理想。又从pom里把这两个包删除了。</p><p>不过从这里可以看出，生成模块时选择依赖包是没关系的，今后可以很方便地在pom增加或删除依赖包。</p><p>生成的springboot_base_quickstart模块导入IDEA，然后小修改一下：</p><ul><li>在pom里删除项目的name和description，这样IDEA就只认artifactId了</li><li>在pom里删除不需要的包，只留下最基本的starter-web和starter-test</li><li>把application.properties改名（用refactor -&gt; rename）为application.yml，这样配置文件里的代码提示和补全就有了。</li></ul><p>模块里除了main和test里各有一个类，其他类都没有，很干净。</p><p>新模块导入IDEA后，Maven开始下载依赖包，大概几分钟。然后把之前的模块在pom里把parent的版本号改为2.7.6，很快就行了，因为2.7.6的依赖包已经下载。并且之前的2.7.5的包就都没有了。如果项目里各模块的Spring Boot主版本不一样，那么各个版本对应的依赖包都会下载到Maven本地库里。</p><h3 id="1-3-2-整合Junit"><strong>1.3.2 整合Junit</strong></h3><p>首先复制一个模块备用。</p><p>在IDEA工作目录把上一节中的springboot_base_quickstart目录复制到同一个目录，改名为springboot_04_junit，然后进入该目录，除了src文件夹和pom.xml，其他都删除。然后修改pom.xml的artifactId为springboot_04_junit，在IDEA导入该模块。</p><p>用Refactor -&gt; rename改名SpringbootBaseQuickstartApplication.java为Springboot04JunitApplication.java，弹出对话框询问是否更改对应的test主类，把test主类勾上，然后点确定按钮，这样两个主类的名称都改了。</p><p>通过改名发现Junit其实已经集成到Spring Boot里了，用就行了。</p><p><strong>第一步：新建要测试的对象和方法</strong></p><p>新建cn.zlz8x8.dao.BookDao.java，对话框里选interface而不是class，然后手写一个方法save，并不执行任何操作。生成的文件如下：</p><p>package cn.zlz8x8.dao;</p><p>public interface BookDao {</p><p><code>  </code>public void save();</p><p>}</p><p>新建cn.zlz8x8.dao.impl.BookDaoImpl.java，这次是选class，然后实现上面接口的方法，在控制台打印一句话。注意类头上加@Repository，表明这是一个受Spring管理的bean，生成的文件如下：</p><p>package cn.zlz8x8.dao.impl;</p><p>import cn.zlz8x8.dao.BookDao;</p><p>import org.springframework.stereotype.Repository;</p><p>@Repository</p><p>public class BookDaoImpl implements BookDao {</p><p><code>  </code>@Override</p><p><code>  </code>public void save() {</p><p><code>      </code>System.out.println(“Message from BookDaoImpl …”);</p><p><code>  </code>}</p><p>}</p><p><strong>第二步，改写test主类</strong></p><p>改写test主类Springboot04JunitApplicationTests.java，如下。注意导入要测试对象时，头上加@Autowired表示<strong>自动装配</strong>。注意主类头上的@SpringBootTest，表明这是一个Spring Boot的测试类。注意import的包，就包括了org.junit</p><p>package cn.zlz8x8;</p><p>import cn.zlz8x8.dao.BookDao;</p><p>import org.junit.jupiter.api.Test;</p><p>import org.springframework.beans.factory.annotation.Autowired;</p><p>import org.springframework.boot.test.context.SpringBootTest;</p><p>@SpringBootTest</p><p>class Springboot04JunitApplicationTests {</p><p><code></code>// 1.注入要测试的对象</p><p><code></code>@Autowired</p><p><code></code>private BookDao bookDao;</p><p><code></code>@Test</p><p><code></code>void contextLoads() {</p><p><code></code>// 2.执行要测试的对象的方法</p><p><code></code>bookDao.save();</p><p><code></code>}</p><p>}</p><p>类名、方法contextLoads()旁边都有运行按钮，随便哪一个。运行后控制台显示相应的消息，并且会显示Tests passed 测试通过。与之前运行Spring Boot主类不同，不需要停止或重启，测试运行后自动就停止了。</p><p><strong>第三步，关于classes属性</strong></p><p>将测试主类Springboot04JunitApplicationTests.java拷贝到cn包下，在原主类（位于cn.zlz8x8下）上右键Refactor -&gt; copy class … 弹出对话框中将包修改为cn</p><p>运行新拷贝的测试类，发现报错。修改代码如下，就OK了。</p><p>报错的原因是测试类在test下的同级包中找哪个类头上有@SpringBootApplication，显然原来的测试类在cn.zlz8x8下，与main下的主类Springboot04JunitApplication在同级包下，可以找到。拷贝后的测试类提升了一级就找不到了，则需要如下指定。指定的方法有两种，如下注释，第二种方法两行@与第一种方法效果一样。</p><p>package cn;</p><p>import cn.zlz8x8.Springboot04JunitApplication;</p><p>import cn.zlz8x8.dao.BookDao;</p><p>import org.junit.jupiter.api.Test;</p><p>import org.springframework.beans.factory.annotation.Autowired;</p><p>import org.springframework.boot.test.context.SpringBootTest;</p><p>@SpringBootTest(classes = Springboot04JunitApplication.class)</p><p>// @SpringBootTest</p><p>// @ContextConfiguration(classes = Springboot04JunitApplication.class)</p><p>class Springboot04JunitApplicationTests {</p><p><code></code>// 1.注入要测试的对象</p><p><code></code>@Autowired</p><p><code></code>private BookDao bookDao;</p><p><code></code>@Test</p><p><code></code>void contextLoads() {</p><p><code></code>// 2.执行要测试的对象的方法</p><p><code></code>bookDao.save();</p><p><code></code>}</p><p>}</p><h3 id="1-3-3-整合MyBatis"><strong>1.3.3 整合MyBatis</strong></h3><p>本节内容涉及MySQL数据库，先按顺序看完并实现“<a href="#_%E9%99%84%E5%BD%95%E4%B8%80%E3%80%81vmware%E5%AE%89%E8%A3%85centos_7">附录一、Vmware安装CentOS7</a>”和“<a href="#_%E9%99%84%E5%BD%95%E4%BA%8C%E3%80%81centos7%E5%AE%89%E8%A3%85mysql">附录二、CentOS7安装MySQL</a>”就有了一个MySQL数据库服务器。</p><p>数据库类型：MySQL 8.0</p><p>数据库连接：mysql://192.168.138.21:3306/ssm_db</p><p>用户名：ssmaster</p><p>密码：1gE=M!ka</p><p>数据表：tbl_book，字段id（主键，自增，不需要值），type（字符串），name（字符串），description（字符串）。已经有2条数据。</p><p><strong>第一步：复制导入新模块</strong></p><p>从“<a href="#_1.3.1_%E5%AE%98%E7%BD%91%E5%88%9B%E5%BB%BA%E6%96%B0%E6%A8%A1%E5%9D%97">1.3.1官网创建新模块</a>”springboot_base_quickstart复制出一个新模块springboot_05_mybatis，只保留src文件夹和pom.xml，并将pom.xml中artifactId修改为springboot_05_mybatis，在IDEA中导入。Refactor修改主类方法名为Springboot05MybatisApplication，并勾选自动修改测试主类方法名。</p><p><strong>第二步：引入相关依赖包</strong></p><p>修改pom.xml如下，增加了mybatis和mysql driver依赖。刷新一下Maven，就会自动分析并下载相应的依赖包。<strong>注意mybatis版本号与视频课里不一样</strong>。</p><?xml version="1.0" encoding="UTF-8"?><p>&lt;project xmlns=“<a class="link"   href="http://maven.apache.org/POM/4.0.0" >http://maven.apache.org/POM/4.0.0<i class="fas fa-external-link-alt"></i></a>” xmlns:xsi=“<a class="link"   href="http://www.w3.org/2001/XMLSchema-instance" >http://www.w3.org/2001/XMLSchema-instance<i class="fas fa-external-link-alt"></i></a>”</p><p><code></code>xsi:schemaLocation=“<a class="link"   href="http://maven.apache.org/POM/4.0.0" >http://maven.apache.org/POM/4.0.0<i class="fas fa-external-link-alt"></i></a> <a class="link"   href="https://maven.apache.org/xsd/maven-4.0.0.xsd" >https://maven.apache.org/xsd/maven-4.0.0.xsd<i class="fas fa-external-link-alt"></i></a>”&gt;</p><p><code></code><modelVersion>4.0.0</modelVersion></p><p><code></code><parent></p><p><code></code><groupId>org.springframework.boot</groupId></p><p><code></code><artifactId>spring-boot-starter-parent</artifactId></p><p><code></code><version>2.7.6</version></p><p><code></code><relativePath/> <!-- lookup parent from repository --></p><p><code></code></parent></p><p><code></code><groupId>cn.zlz8x8</groupId></p><p><code></code><artifactId>springboot_05_mybatis</artifactId></p><p><code></code><version>0.0.1-SNAPSHOT</version></p><p><code></code><properties></p><p><code></code>&lt;java.version&gt;1.8&lt;/java.version&gt;</p><p><code></code></properties></p><p><code></code><dependencies></p><p><code></code><dependency></p><p><code></code><groupId>org.mybatis.spring.boot</groupId></p><p><code></code><artifactId>mybatis-spring-boot-starter</artifactId></p><p><code></code><version>2.2.2</version></p><p><code></code></dependency></p><p><code></code><dependency></p><p><code></code><groupId>mysql</groupId></p><p><code></code><artifactId>mysql-connector-java</artifactId></p><p><code></code><scope>runtime</scope></p><p><code></code></dependency></p><p><code></code><dependency></p><p><code></code><groupId>org.springframework.boot</groupId></p><p><code></code><artifactId>spring-boot-starter-web</artifactId></p><p><code></code></dependency></p><p><code></code><dependency></p><p><code></code><groupId>org.springframework.boot</groupId></p><p><code></code><artifactId>spring-boot-starter-test</artifactId></p><p><code></code><scope>test</scope></p><p><code></code></dependency></p><p><code></code></dependencies></p><p><code></code><build></p><p><code></code><plugins></p><p><code></code><plugin></p><p><code></code><groupId>org.springframework.boot</groupId></p><p><code></code><artifactId>spring-boot-maven-plugin</artifactId></p><p><code></code></plugin></p><p><code></code></plugins></p><p><code></code></build></p></project><p>自己手工怎么知道如何写mybatis和mysql的依赖？</p><p>（1）IDEA正式版中用Spring Initializr生成模块的时候，勾选上mybatis和mysql driver依赖，生成的pom.xml里就有了。</p><p>（2）使用官网Initializr生成模块，也勾选上mybatis和mysql driver</p><p>手工写的时候，可以参考上面两种方式生成的pom.xml</p><p><strong>第三步：配置相关信息</strong></p><p>修改application.yml如下，可以看到，多了spring.datasource一段。<strong>其中driver-class-name的值与视频课里讲的不一样，mysql-connector 8开始就用如下这样的驱动了</strong>。</p><p>server:</p><p><code>  </code>port: 80</p><p>spring:</p><p><code>  </code>datasource:</p><p><code>  </code>driver-class-name: com.mysql.cj.jdbc.Driver</p><p><code>  </code>url: jdbc:mysql://192.168.138.21:3306/ssm_db</p><p><code>  </code>username: ssmaster</p><p><code>  </code>password: 1gE=M!ka</p><p><strong>第四步：编写测试代码</strong></p><p>（1）新建一个实体类cn.zlz8x8.domain.Book，只需要定义出与数据库tbl_book表中字段对应的四个属性就可以，后面的toString和setter，getter代码都可以自动生成。</p><p>package cn.zlz8x8.domain;</p><p>public class Book {</p><p><code>  </code>private Integer id;</p><p><code>  </code>private String type;</p><p><code>  </code>private String name;</p><p><code>  </code>private String description;</p><p><code>  </code>@Override</p><p><code>  </code>public String toString() {</p><p><code>      </code>return “Book{” +</p><p><code>              </code>“id=” + id +</p><p><code>              </code>“, type='” + type + ‘'’ +</p><p><code>              </code>“, name='” + name + ‘'’ +</p><p><code>              </code>“, description='” + description + ‘'’ +</p><p><code>              </code>‘}’;</p><p><code>  </code>}</p><p><code>  </code>public Integer getId() {</p><p><code>      </code>return id;</p><p><code>  </code>}</p><p><code>  </code>public void setId(Integer id) {</p><p><code>      </code><a class="link"   href="http://this.id" >this.id<i class="fas fa-external-link-alt"></i></a> = id;</p><p><code>  </code>}</p><p><code>  </code>public String getType() {</p><p><code>      </code>return type;</p><p><code>  </code>}</p><p><code>  </code>public void setType(String type) {</p><p><code>      </code>this.type = type;</p><p><code>  </code>}</p><p><code>  </code>public String getName() {</p><p><code>      </code>return name;</p><p><code>  </code>}</p><p><code>  </code>public void setName(String name) {</p><p><code>      </code><a class="link"   href="http://this.name" >this.name<i class="fas fa-external-link-alt"></i></a> = name;</p><p><code>  </code>}</p><p><code>  </code>public String getDescription() {</p><p><code>      </code>return description;</p><p><code>  </code>}</p><p><code>  </code>public void setDescription(String description) {</p><p><code>      </code>this.description = description;</p><p><code>  </code>}</p><p>}</p><p>（2）新建一个接口类cn.zlz8x8.dao.BookDao，注意接口类头上的@Mapper和方法名上的@Select，方法并没有方法体，通过@Select里面的SQL查询语句实现了。</p><p>package cn.zlz8x8.dao;</p><p>import cn.zlz8x8.domain.Book;</p><p>import org.apache.ibatis.annotations.Mapper;</p><p>import org.apache.ibatis.annotations.Select;</p><p>@Mapper</p><p>public interface BookDao {</p><p><code>  </code>@Select(“select * from tbl_book where id = #{id}”)</p><p><code>  </code>Book getById(Integer id);</p><p>}</p><p>（3）改写测试类，运行测试</p><p>package cn.zlz8x8;</p><p>import cn.zlz8x8.dao.BookDao;</p><p>import org.junit.jupiter.api.Test;</p><p>import org.springframework.beans.factory.annotation.Autowired;</p><p>import org.springframework.boot.test.context.SpringBootTest;</p><p>@SpringBootTest</p><p>class Springboot05MybatisApplicationTests {</p><p><code></code>@Autowired</p><p><code></code>private BookDao bookDao;</p><p><code></code>@Test</p><p><code></code>void contextLoads() {</p><p><code></code>System.out.println(bookDao.getById(2));</p><p><code></code>}</p><p>}</p><p>代码编辑器左边点击运行按钮，运行这个测试类。看结果</p><p>到此整合MyBatis的实例完成。回过头看，没有用到spring-boot-starter-web依赖，也没有用到application.yml里的server.port=80的配置，这两项都可以删掉，留着也行。</p><h3 id="1-3-4-整合MyBatis常见问题"><strong>1.3.4 整合MyBatis常见问题</strong></h3><p>主要讲的是在设置数据源时</p><p>com.mysql.jdbc.Driver 是MySQL connector 5 的写法</p><p>com.mysql.cj.jdbc.Driver 是MySQL connector 8的写法，本例中就是这样写的</p><p>第二个问题，是使用了8的驱动，会出现没有设置时区的报错，解决方法是在url里加上时区设置：</p><p>url: jdbc:mysql://192.168.138.21:3306/ssm_db?serverTimezone=UTC</p><p>url: jdbc:mysql://192.168.138.21:3306/ssm_db?serverTimezone=Asia/Shanghai</p><p>本例中没有设置时区，并没有报错。</p><h3 id="1-3-5-整合MyBatisPlus"><strong>1.3.5 整合MyBatisPlus</strong></h3><p>MyBatis-Plus与MyBatis的区别：导入依赖不同，数据层实现简化</p><p>Spring官方并没有把MyBatis-Plus纳入其主要可选依赖，在定义pom依赖的时候，可以从阿里云Initializr里导入MyBatis-Plus依赖，然后看其pom里是怎么写的。</p><p>另外：<a class="link"   href="https://mvnrepository.com/" >**https://mvnrepository.com/<i class="fas fa-external-link-alt"></i></a> <strong>是Maven库的大本营，可以去查！！！</strong></p><h1><strong>二、实用篇</strong></h1><p><strong>前置知识：</strong></p><ul><li>Linux（CentOS 7），熟悉常用Linux基础命令，熟悉Linux系统目录结构</li><li>使用开发技术：缓存：redis、MongoDB；消息中间件：RocketMQ、RabbitMQ</li></ul><h2 id="2-1-运维实用篇"><strong>2.1 运维实用篇</strong></h2><p><strong>学习目标：</strong></p><ul><li>能够掌握SpringBoot程序多环境开发</li><li>能够基于Linux系统发布SpringBoot工程</li><li>能够解决线上灵活配置SpringBoot工程的需求</li></ul><h2 id="2-2-开发实用篇"><strong>2.2 开发实用篇</strong></h2><p><strong>学习目标：</strong></p><ul><li>能够基于SpringBoot整合任意第三方技术</li></ul><h1><strong>三、原理篇</strong></h1><p><strong>前置知识：</strong></p><ul><li>了解Spring加载bean的各种方式</li><li>知道Spring容器底层工作原理，能够阅读简单的Spring底层源码</li></ul><p><strong>学习目标：</strong></p><ul><li>掌握SpringBoot内部工作流程</li><li>理解SpringBoot整合第三方技术的原理</li><li>实现自定义开发整合第三方技术的组件</li></ul><h1><strong>附录一、Vmware安装CentOS 7</strong></h1><p>本例中采用虚拟化软件VMware Workstation安装CentOS 7-2009（最小安装minimal）。实际应用中，单个服务器一般都设定为单一功能，比如Web服务器，数据库服务器，LDAP服务器等，或者多台服务器分布式部署云计算组件如Hadoop等，单个服务器只需要操作系统的基本功能，因此CentOS最小化安装符合需求，如果需要额外的功能，可以在使用过程中增加。云服务提供商（例如阿里云）提供的云服务器操作系统一般是CentOS minimal。</p><p>本例CentOS安装环境如下：</p><p>主机（Host Machine）：CPU 20核，内存32G，操作系统Windows 11家庭版64位</p><p>虚拟化软件：VMware Workstation 16 pro</p><p>到 <a class="link"   href="https://www.centos.org/" >https://www.centos.org/<i class="fas fa-external-link-alt"></i></a> 下载安装包，本例是CentOS-7-x86_64-DVD-2009.iso</p><h2 id="1-1-安装前Vmware设置"><strong>1.1 安装前Vmware设置</strong></h2><p>1、在VMware菜单“编辑-首选项”可以设置虚拟机默认放置的目录，应选择有足够空间的硬盘分区。本例中是 D:\MyVM</p><p>2、创建虚拟机采用“自定义(高级)”配置，选择安装来源时，载入CentOS的ISO后，VMware会自动识别出操作系统类型和版本。<strong>选择“稍后安装操作系统”不采用简易安装，而采用手动安装</strong>。后面“客户机操作系统”选择Linux，下拉框选择CentOS 7 64位。</p><p>3、虚拟机名称 CentOS7-min，选择 D:\MyVM\CentOS7-min作为存储位置</p><p>4、为虚机分配处理器1个，内核数量1个，2G内存。本例中这个虚拟机实例是作为干净基准系统，具体的应用虚拟机可以克隆这个虚拟机，不用重新安装。分配的CPU核数，内存数在克隆后可以在Vmware里修改。实验用虚机一般1核2G内存即可，可租用的轻量级云服务器一般是1核1G内存。实际应用虚机则根据需要分配资源，计算单元则对CPU要求较高，内容服务器则对内存要求较高。</p><p>5、使用NAT网络（默认选项），虚机没有与主机同级的IP地址。</p><p>桥接，NAT，仅主机模式，三者的简要区别如下：</p><p>（1）桥接：虚机与主机在网络中地位一样，虚机拥有与主机同级的独立IP地址。</p><p>（2）<strong>NAT：虚机共享主机的IP地址访问Internet，同一个主机中的各个虚机在同一网段中，可互相访问。外部无法直接访问虚机，但可通过主机的转接访问虚机</strong>。</p><p>（3）仅主机模式：同一主机中的各个虚机可互相访问，虚机无法访问Internet，外部也无法访问虚机。</p><p>6、I/O类型：默认LSI Logic，磁盘类型：默认SCSI，选择磁盘：创建新虚拟磁盘。</p><p>7、分配20G虚拟磁盘空间，存为多个文件（默认选项）。没有勾选“立即分配所有磁盘空间”，会稍微影响虚机的速度。</p><p>8、指定虚机磁盘文件，保持默认（拆分成多个文件）。方便虚拟机的拷贝。</p><p>9、开始安装时，可能会提示要更改BIOS设置以支持64位操作系统之类的，按照提示修改主机BIOS设置，再回来安装。</p><p>注意：一般新的电脑无需设置自动支持64位虚拟化，有些电脑需要在BIOS里设置以支持64位虚拟化，有些更旧的电脑完全不支持64位虚拟化，则无法在VMware里安装64位的操作系统。</p><p>如上完成新建虚拟机设置。会出现该虚拟机配置画面，点击“编辑虚拟机设置”，打开对话框，核对硬件配置。如果CD/DVD是自动检测，则选择“使用ISO印象文件”，并选中CentOS的安装镜像文件。</p><p>然后点击上图中的“开启此虚拟机”，开始安装。</p><p>开始安装后，窗口下面会出现“我已完成安装”，不要点，等安装完了再点。</p><h2 id="1-2-安装过程"><strong>1.2 安装过程</strong></h2><p>注意：安装过程中，鼠标点击虚机界面即可进入虚机操作，组合键ctrl + alt 可使鼠标返回主机。在VMware Workstation窗口的左下角会有提示。</p><p>1、安装过程与在真实裸机上安装一样，初始界面按键“i”选择“Install CentOS”，然后回车进入安装过程。</p><p>2、选择安装过程中的语言：保持默认 English - Englisth (United States)</p><p>3、如下图所示，设置安装选项：</p><p>Date &amp; Time 选到 Asia / Shanghai</p><p>Language Support 可以把中文，简体中文(中国)选上</p><p>Software Selection 保持Minimal Install不变</p><p>Installation Destination 需要点开，默认是自动配置磁盘，不需要修改，直接点“Done”按钮返回即可，黄色的感叹号才会消失，此界面右下角“Begin Installation”按钮才会亮起。</p><p>Network &amp; Hostname 点进去，如果有显示有线网络ens33之类的，打开ON</p><p>KDUMP可以设置为Disabled，保持默认也可以。</p><p>设置完成后，点击右下角“Begin Installation”按钮开始安装。</p><p>4、安装的过程中给root用户设置密码（4geT%not），如果密码太弱，需点击两次确定才能完成操作。</p><p>新建一个用户admin（密码d00r%Key），勾选“Make this user administrator”，今后的系统管理员用户。如果密码太弱，需点击两次确定才能完成操作。</p><p>安装完成，点击“Reboot”重新启动。</p><p>5、系统是最小化安装，没有GUI，以root登录，安装完成。</p><p><strong>关闭虚拟机后，可以编辑虚拟机设置。把CD/DVD 改回为自动检测。</strong></p><p><strong>关闭虚机后，可以编辑虚机设置，修改CPU核数，硬盘大小，内存等。</strong></p><p>小技巧：虚机屏幕有时候不匹配VMware的窗口，需要拉动窗口的滚动条才能看见全部的虚机屏幕内容。或者，虚机屏幕太小，Vmware经常自动改变窗口大小去适应虚机。从VMware菜单“编辑 - 首选项 - 显示”，把“自动适应窗口”前的勾去掉（自动适应下面的两个选项都不勾）。然后再开启此虚机，可解决这个问题。</p><h2 id="1-3-忘记root密码"><strong>1.3 忘记root密码</strong></h2><p><strong>下面是CentOS 7的root密码修改，一般情况可略过。</strong></p><p>开机按ESC</p><p>选择CentOS Linux (3.10.0-693…)  按 e键</p><p>光标移动到 linux 16开头的行，找到 ro改为 rw init=sysroot/bin/sh</p><p>按 Ctrl+x执行</p><p>进入后输 chroot /sysroot</p><p>输入 passwd</p><p>根据提示输入2次新密码</p><p>完成后输入  touch /.autorelabel  更新系统信息</p><p>exit</p><p>reboot重启</p><p>重启过程慢，耐心等等</p><p>重启后用新密码登录</p><h2 id="1-4-安装后设置"><strong>1.4 安装后设置</strong></h2><h3 id="1-4-1-关于用户"><strong>1.4.1 关于用户</strong></h3><p>目前系统里有2个用户，root是超级管理员；admin是系统管理员。</p><p>系统提示符为 # 表明用户为root，提示符为$ 表明用户为其他用户。</p><p>每个用户都有自己的主目录，以 ~表示，root用户是 /root，其他用户是 /home/用户名。例如admin输入命令 cd ~ 则会进入其主目录 /home/admin</p><p>admin需要执行root权限的命令时，可以用 sudo 临时获得权限，也可以用 su 切换身份为root。</p><p>使用sudo时，需要输入admin用户自己的密码，使用 su时，需要输入root用户的密码，使用“sudo su”则可以使用admin自己的密码切换到root用户身份，在root用户没有设置密码时，这个方法很好用。</p><p>1、使用sudo不需要输入密码</p><p>$ sudo visudo -f /etc/sudoers</p><p><strong>文件编辑的方式与vi一样，进入界面后，按i进入编辑（insert）模式，左下角会有INSERT提示。移动光标修改内容。修改完毕后按ESC进入命令模式，输入 :w 回车，就保存，再输入 :q 回车就退出。或者输入 :wq 一次性保存退出。</strong></p><p>如下修改内容，在 %wheel ALL=(ALL) ALL 前加注释符#，去掉 %wheel ALL=(ALL) NOPASSWD:ALL 前的注释符。保存退出就行了。用户admin 命令exit退出，然后再登录，就发现已经生效，使用sudo不需要输入密码了。</p><p>这是针对wheel这个组的设置，这个组的成员都不需要输入密码就可以使用sudo，admin是wheel组的成员。</p><p>传统修改方法是在 root ALL=(ALL) ALL 下面增加一行 admin ALL=(ALL) NOPASSWD:ALL 但在这里会被后面的 %wheel ALL=(ALL) ALL 覆盖掉。原因是在安装过程中，创建 admin用户时使其成为管理员，便成为了 wheel组的成员。系统只允许wheel组的用户来执行“su”命令登录为root用户，而让其他组的用户即使执行“su”、输入了正确的root密码，也无法登录为root用户。</p><p>用visudo编辑sudoers文件是正确的做法。有些做法是增加文件sudoers的写权限，用vi修改，再去掉其写权限。可能会出现文件权限错乱，如下恢复sudoers文件的正确属性：</p><p>$ sudo chmod 0440 /etc/sudoers</p><h3 id="1-4-2-配置静态IP地址"><strong>1.4.2 配置静态IP地址</strong></h3><p><strong>第一步：在Vmware里确认网络配置</strong></p><p>菜单“编辑”-“虚拟网络编辑器”，这个界面，有很多网络文章说要修改，其实不用。选中列表里的Vmnet8（NAT模式），只需要看一下子网IP 192.168.138.0 及 子网掩码 255.255.255.0 记住就行了。<strong>“使用本地DHCP服务将IP地址分配给虚拟机”前面的勾不用去掉</strong>。</p><p>然后确认一下虚拟机的网络适配器是否是NAT，安装的时候默认就是这项。如果不是，就在虚拟机关机状态下，编辑虚拟机设置，改为NAT。</p><p><strong>在Vmware里只需要确认上述配置就行了，不用做任何修改！</strong></p><p><strong>第二步：在虚拟机设置静态IP</strong></p><p>以root用户登录虚拟机，<strong>下面的命令都不带sudo了</strong>。</p><p>vi /etc/sysconfig/network-scripts/ifcfg-ens33</p><p>因为是虚拟机，所以配置脚本文件是ens33这样的，如果是在物理机上的CentOS，则会是eth0这样的，可以先到目录里看一下是否有这个文件，再编辑。</p><p>如下修改文件，保存退出。首先将BOOTPROTO改为static，然后增加下面的内容，设置静态IP，网关，DNS，注意要和上面的Vmware里的一致。</p><p><strong>这里设置的网关是 192.168.138.2</strong> 而不是习惯上的 192.168.138.1 这是Vmware的内外网隔离措施。而 192.168.138.1 是从虚拟机角度看到的主机的IP地址。</p><p>重启网络服务 service network restart</p><p>测试网络是否通了 ping <a class="link"   href="http://www.baidu.com" >www.baidu.com<i class="fas fa-external-link-alt"></i></a> 信息滚动过程中可以用Ctrl + C中断</p><p>然后从主机开一个命令行窗口 ping 192.168.138.11 能通，就说明双向OK了。</p><h3 id="1-4-3-安装常用工具"><strong>1.4.3 安装常用工具</strong></h3><p>前提是网络连接没有问题。</p><p>更新系统（可选）：yum update</p><p>没想到新下载的CentOS7-2009，更新居然有255M，现在比较智能，会找最快的镜像站点，大概更新用了5分钟。</p><p>因为是最小化安装，很多工具没有，安装常用工具：</p><p>yum -y install perl gcc kernel-devel wget</p><p>yum -y install yum-utils</p><p>yum -y install net-tools</p><p>yum -y install unzip zip</p><p>安装了上面的net-tools以后，就有ifconfig命令了，试一下</p><p>ifconfig</p><p>可以看到自己的静态IP地址</p><p>更新完毕后，可以重新启动一下系统 systemctl reboot</p><h2 id="1-5-用Putty连接虚拟机上传下载文件"><strong>1.5 用Putty连接虚拟机上传下载文件</strong></h2><p>到Putty官网<a class="link"   href="https://putty.org/" >https://putty.org/<i class="fas fa-external-link-alt"></i></a>，选第一个Download PuTTY，下面是第三方项目。</p><p>下载64-bit x86版本，形如putty-64bit-0.77-installer.msi的安装文件。</p><p>安装完成后，有多个程序，首先运行Putty，输入IP地址，点open就可以连接。</p><p>连接后以root身份登录，可以看到显示的主机IP是192.168.138.1，命令exit可以退出登录，断开连接。</p><p>然后运行PSFTP，窗口中输入open 192.168.138.11 进行连接，以root登录，可以看到提示当前工作路径是 /root，命令exit可以退出登录，断开连接。</p><p>以后可以在虚拟机开机状态下，关闭Vmware，选择让虚拟机后台运行，然后用Putty连接进行操作，上传下载文件。</p><p>需要在虚拟机里安装JDK，安装文件为主机 D:\software\jdk-8u351-linux-x64.rpm，这个文件是事先从Oracle网站下载来的。打开PSFTP连接，root登录。使用put命令将文件上传到虚拟机 /root 目录下。注意路径分隔符使用 / 而不是Windows风格的 \，然后ls命令查看虚拟机上是否有这个文件了。exit退出，断开连接。</p><h2 id="1-6-密钥方式连接虚机"><strong>1.6 密钥方式连接虚机</strong></h2><p>密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。</p><p><strong>第一步：制作密钥对</strong></p><p>在虚机上制作密钥对。首先用root登录，然后执行以下命令：</p><p>ssh-keygen  &lt;== 建立密钥对</p><p>Generating public/private rsa key pair.</p><p>Enter file in which to save the key (/root/.ssh/id_rsa): &lt;== 回车</p><p>Created directory ‘/root/.ssh’.</p><p>Enter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，或<strong>回车</strong></p><p>Enter same passphrase again: &lt;== 再输入一遍密钥锁码，<strong>回车</strong></p><p>Your identification has been saved in /root/.ssh/id_rsa. &lt;== 私钥</p><p>Your public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 公钥</p><p>The key fingerprint is:</p><p>…</p><p>The key’s randomart image is:</p><p>…</p><p>现在，在 /root 生成了一个 .ssh 的隐藏目录，内含两个密钥文件，id_rsa 为私钥，id_rsa.pub 为公钥。</p><p>密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。本例中没有密钥锁码，方便使用。</p><p><strong>第二步：在虚机上安装公钥</strong></p><p>键入以下命令，在服务器上安装公钥：</p><p>cd .ssh</p><p>cat id_rsa.pub &gt;&gt; authorized_keys</p><p>如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：</p><p>chmod 600 authorized_keys</p><p>chmod 700 ~/.ssh</p><p><strong>第三步：虚机开启密钥登录</strong></p><p>执行命令vi /etc/ssh/sshd_config，如下找到PubkeyAuthentication yes这一项，把前面的注释符号去掉。如果要禁用密码登录方式，则把下面的PasswordAuthentication改为no，本例中没有改，保留了密码登录方式。</p><p>保存，退出编辑。重启ssh服务systemctl restart sshd</p><p><strong>第三步：用PSFTP下载私钥到主机</strong></p><p>用PSFTP密码登录方式连接虚机，下载id.rsa到本地重命名192.168.138.11.rsa</p><p><strong>第四步：将密钥导入到Putty</strong></p><p>首先打开PuttyGen，点Load按钮，选择文件对话框里的文件类型默认是*.ppk，改为*.*，找到刚才的192.168.138.11.rsa，就导入成功了，提示是旧的pem格式。</p><p>然后点击Save private key，保存为192.168.138.11.ppk，与刚才的文件最好在同一文件夹下，询问是否要个锁码，不理他。</p><p>关闭PuttyGen，打开Putty，左侧选择Session，右边填写Host Name为root@192.168.138.11，这里指定了登录用户为root，如果为其他用户则改为其他用户名。然后下面Saved Sessions空格里填上一个名字vm-192.168.138.11，点右侧Save就保存了。</p><p>然后左侧Connection - SSH - Auth，直接点Auth不用展开，右边Browse找到刚才保存的192.168.138.11.ppk</p><p>回到上一张图的Session，选中vm-192.168.138.11的情况下，点Save，一定要保存，否则下次又要找密钥。然后点下面的Open就连接成功了，不需要输入密码，直接root登录成功。</p><p>今后要连接的时候，打开Putty，选中保存的vm-192.168.138.11，点Load，然后点下面的Open就可以连接上了。</p><p><strong>主机运行Putty组件Pageant，会在Windows右下角出现一个常驻的代理，从中可以快速连接已经保存的session或者进行一些密钥操作</strong>。</p><h2 id="1-7-安装JDK8"><strong>1.7 安装JDK8</strong></h2><p>前面“<a href="#_1.5_%E7%94%A8putty%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6">1.5 用Putty连接虚拟机上传下载文件</a>”已经把JDK安装文件上传到 /root目录下了，执行 rpm -ivh jdk-8u351-linux-x64.rpm就可以安装JDK了。</p><p>完成后执行java -version看到版本号就说明OK了</p><p>命令alternatives --config java可以看到系统里有几个JDK，并设置默认JDK，本例只有一个，回车保持默认。</p><p>vi /etc/profile</p><p>在文件最后添加</p><p>export JAVA_HOME=/usr/java/default</p><p>export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</p><p>注意CLASSPATH=后面是个英文句号，这样设置可以解决很多命令行下运行java程序找不到类的问题。</p><p>Oracle JDK安装后，在安装目录 /usr/java/ 下会生成3个目录。其中一个是真实的目录jdk1.8.0_351-amd64、目录链接latest表示最新版本、目录链接default表示默认版本。当前latest 指向真实的目录，default 指向 latest。上面的 JAVA_HOME 使用了 default目录，今后如果有多个版本，默认版本有变化，只需要修改default的指向就可以了，不需要修改系统变量。</p><p>注销当前用户，重新登录，执行下面命令验证各变量正确：</p><p>echo $JAVA_HOME</p><p>echo $CLASSPATH</p><p>java -version</p><h1><strong>附录二、CentOS7安装MySQL</strong></h1><h2 id="2-1-克隆虚机"><strong>2.1 克隆虚机</strong></h2><p>上一章已经创建了一个虚机CentOS7-min，更新了系统，安装了常用工具，设置了密钥连接，安装了JDK8，为此虚机创建一个快照。菜单“虚拟机 - 快照 - 拍摄快照”，输入名字和描述就行了。</p><p>菜单“虚拟机 - 管理 - 克隆”，克隆源选择“现有快照”，找到刚才拍摄的快照。</p><p>克隆类型选择“创建完整克隆”</p><p>输入虚机名称CentOS7-mysql，确认保存位置，完成。</p><h2 id="2-2-设置虚机"><strong>2.2 设置虚机</strong></h2><p>开启新的虚机CentOS7-mysql，以root登录，<strong>首先要修改的是静态IP地址</strong>。</p><p>vi /etc/sysconfig/network-scripts/ifcfg-ens33</p><p>将静态IP地址改为192.168.138.21就行了，其他的不用动。</p><p>重启网络服务service network restart</p><p>虚机ping <a class="link"   href="http://www.baidu.com" >www.baidu.com<i class="fas fa-external-link-alt"></i></a>，主机ping 192.168.138.21都OK</p><p>参照“<a href="#_1.6_%E5%AF%86%E9%92%A5%E6%96%B9%E5%BC%8F%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%9C%BA">1.6密钥方式连接虚机</a>”，打开Putty，在Session里新建保存一个名称为db-192.168.138.21，连接地址为root@192.168.138.21，左侧Connection - SSH - Auth，直接点Auth不用展开，右边Browse找到刚才保存的192.168.138.11.ppk（<strong>就是这个旧的密钥</strong>，不需要到虚机上创建新的密钥对了，因为是克隆的，所有信息都一样）</p><p>Save，Open 连接成功。</p><p>一般安全起见，新的虚机要创建新的密钥对。本例直接使用了旧的密钥，简便。</p><h2 id="2-3-安装MySQL"><strong>2.3 安装MySQL</strong></h2><h3 id="2-3-1-安装MySQL8"><strong>2.3.1 安装MySQL8</strong></h3><p>到MySQL官网，下载MySQL Yum Repository，操作系统是CentOS7，要安装的MySQL8.0，因此下载到的对应版本是mysql80-community-release-el7-7.noarch.rpm</p><p>下载需要登录。注册一个免费的MySQL或Oracle账号即可，以后用得着。</p><p>用PSFTP将文件上传到虚机 /root 目录下。</p><p>安装yum库：rpm -Uvh mysql80-community-release-el7-7.noarch.rpm</p><p>安装MySQL：yum install mysql-community-server</p><p>中间可能有几个需要确认的地方，输入y回车即可。这个版本只有80M左右，非常快，不到1分钟就安装完毕。</p><p>查询mysqld的状态systemctl status mysqld.service</p><p>如果是inactive（active是绿色的）则启动之systemctl start mysqld.service</p><p>启动完毕再查询状态systemctl status mysqld.service，正常</p><p>查看安装过程中生成的随机密码，并以此密码登录mysql</p><p>grep ‘temporary password’ /var/log/mysqld.log</p><p>可以看到下面的z6iv!b7Q8Zjt就是临时密码</p><p>以临时密码登录MySQL，如下命令，提示输入密码时输入临时密码</p><p>mysql -u root -p</p><p>进入MySQL后，修改root（这个root用户是MySQL的用户）密码，大小写，数字，符号，8位，否则提示密码不合要求</p><p>alter user ‘root’@’localhost’ identified by ‘sql=R00T’;</p><p>命令quit或exit退出MySQL，然后用新密码登录MySQL成功。</p><p><strong>开启3306端口</strong>：firewall-cmd --zone=public --add-port=3306/tcp --permanent</p><p><strong>配置立即生效</strong>：firewall-cmd --reload</p><p>以后会用到的其他防火墙命令：</p><p>关闭端口firewall-cmd --zone=public --remove-port=5672/tcp --permanent</p><p>查看所有开放端口firewall-cmd --zone=public --list-ports</p><p>查看防火墙状态firewall-cmd --state</p><p>关闭防火墙systemctl stop firewalld.service</p><p>查看所有监听端口netstat -lnpt</p><p>重启虚机reboot，查询mysqld的状态systemctl status mysqld.service</p><p>发现是active的，说明MySQL服务是随系统启动而启动的，一切正常。</p><p>到此，MySQL安装完毕，初始化配置root密码完毕。关闭虚机，拍摄快照，启动虚机，以后没事就不再安装MySQL了。</p><p>（1）此虚机将作为数据库服务器长期保持运行，关闭Vmware界面时让其后台运行。今后操作MySQL以远程为主，比如用IDEA里的database navigator</p><p>（2）MySQL有其备份方式，定期备份保障数据安全。另外，此虚机也可定期拍摄快照，如遇系统级故障，可以用快照恢复。</p><h3 id="2-3-2-特殊故障"><strong>2.3.2 特殊故障</strong></h3><p>MySQL一段时间不操作则服务停掉。有时几天，有时十几天。</p><p>参考解决方法：<a class="link"   href="https://124654439.iteye.com/blog/2174953" >https://124654439.iteye.com/blog/2174953<i class="fas fa-external-link-alt"></i></a></p><p>注意该文章的后半部分，否则就白看了。关键点是修改参数要带 global</p><p>以root身份连接登录进mysql</p><p>mysql&gt; show global variables like ‘wait_timeout’;</p><p>mysql&gt; set global interactive_timeout= 31536000;</p><p>mysql&gt; set global wait_timeout=31536000;</p><p>在MySQL8.1的版本有这个问题，此方法可以解决。</p><p>如果没这个问题，则略过。</p><h3 id="2-3-3-建立数据库、用户、表、数据"><strong>2.3.3 建立数据库、用户、表、数据</strong></h3><p>数据库服务器建好后，一般远程操作。这里仅展示在服务器上的基本操作。</p><p>本例中建立的库、用户、表、数据是为了配合前面的Spring Boot案例。</p><p>用root登录MySQL，建立一个数据库ssm_db，建立一个用户ssmaster，然后把数据库ssm_db的所有权限赋予ssmaster</p><p>mysql -u root -p</p><p>输入root的密码登录，下面的命令都是MySQL里了</p><p>mysql&gt; create database ssm_db DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;</p><p>mysql&gt; create user ssmaster@‘%’ identified by ‘1gE=M!ka’;</p><p>mysql&gt; create user ssmaster@localhost identified by ‘1gE=M!ka’;</p><p>mysql&gt; grant all on ssm_db.* to ssmaster@‘%’;</p><p>mysql&gt; grant all on ssm_db.* to ssmaster@localhost;</p><p>mysql&gt; quit;</p><p>库和用户都建好了，然后用ssmaster登录MySQL</p><p>mysql -u ssmaster -p</p><p>输入用户ssmaster的密码，下面的命令都是MySQL里了</p><p>mysql&gt; use ssm_db;</p><p>mysql&gt; CREATE TABLE IF NOT EXISTS tbl_book(id INT UNSIGNED AUTO_INCREMENT,type VARCHAR(100) NOT NULL,name VARCHAR(100) NOT NULL,description VARCHAR(200),PRIMARY KEY (id))DEFAULT CHARSET=utf8;</p><p>mysql&gt; INSERT INTO tbl_book(type,name,description) VALUES (‘novel’,’Learning Spring Boot’,’How to coding with Spring Boot.’);</p><p>mysql&gt; select * from tbl_book;</p><p>可以看到表建好了，并且插入了一条数据。id是自增的，不需要输入。</p><p>mysql&gt; quit;</p><h3 id="2-3-4-远程操作数据库"><strong>2.3.4 远程操作数据库</strong></h3><p>IDEA社区版安装Database Navigator插件就可以远程操作数据库了。</p><p>一般工具栏在左侧，点开后，点绿色 + 号新建一个MySQL连接如下。输入Name不一定要与数据库名一致，Description可以留空，Host填写IP地址，确认端口号是3306，Database填上面创建的库ssm_db，下面的用户名密码填上面创建的用户名密码，Driver用内置库。可以先点Test Connection按钮测试一下连接，显示成功。然后点最下面的OK，这个数据库连接就完成了。</p><p>连接建好后，就可以看到ssm_db的整个结构，并可以进行建表，修改数据等操作。</p><p>一般对数据库进行操作，是通过SQL方式。点击Open SQL console按钮打开SQL的控制台，在控制台输入如下，插入一条数据</p><p>insert into tbl_book(type,name,description) VALUES (‘技术’,’大学物理’,’全国通用大学物理教程’);</p><p>点Execute Statement就可以执行这条SQL语句。执行完毕，就生效了，另外两个按钮Commit和Rollback还亮着，说明这条SQL语句还没有正式提交数据库，可以回滚。点击Commit按钮正式提交，然后Commit和Rollback两个按钮就灰了。</p><p>再输入select * from tbl_book; 执行，就可以看到查询出的数据。</p><p>完结撒花！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;课程视频地址：&lt;a class=&quot;link&quot;   href=&quot;https://www.bilibili.com/video/BV15b4y1a7yG/&quot; &gt;https://www.bilibili.com/video</summary>
      
    
    
    
    <category term="Java开发专题" scheme="http://example.com/categories/Java%E5%BC%80%E5%8F%91%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Spring Boot" scheme="http://example.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7学习笔记</title>
    <link href="http://example.com/2022/10/06/CentOS7_note/"/>
    <id>http://example.com/2022/10/06/CentOS7_note/</id>
    <published>2022-10-06T10:28:07.000Z</published>
    <updated>2024-05-21T06:08:17.217Z</updated>
    
    <content type="html"><![CDATA[<h1><strong>一、安装CentOS</strong></h1><h1><strong>二、基本系统设置</strong></h1><p>一二详细步骤参考我的另一篇文章：</p><p><a class="link"   href="https://dettry.github.io/2024/05/09/%E5%8C%BA%E5%9D%97%E9%93%BE/" >区块链环境配置教程 | CodeCook (dettry.github.io)<i class="fas fa-external-link-alt"></i></a></p><h1><strong>三、远程SSH登录</strong></h1><h2 id="3-1-使用账号密码登录"><strong>3.1 使用账号密码登录</strong></h2><h2 id="3-2-设置SSH通过密钥登录"><strong>3.2 设置SSH通过密钥登录</strong></h2><p>我们一般使用 PuTTY 等 SSH 客户端来远程管理 Linux 服务器。但是，一般的密码方式登录，容易有密码被暴力破解的问题。所以，一般我们会将 SSH 的端口设置为默认的 22 以外的端口，或者禁用 root 账户登录。其实，有一个更好的办法来保证安全，而且让你可以放心地用 root 账户从远程登录——那就是通过密钥方式登录。</p><p>密钥形式登录的原理是：利用密钥生成器制作一对密钥——一只公钥和一只私钥。将公钥添加到服务器的某个账户上，然后在客户端利用私钥即可完成认证并登录。这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机，利用私钥也可以登录。</p><p>下面来讲解如何在 Linux 服务器上制作密钥对，将公钥添加给账户，设置 SSH，最后通过客户端登录。</p><h3 id="3-2-1-制作密钥对"><strong>3.2.1 制作密钥对</strong></h3><p>首先在服务器上制作密钥对。首先用密码登录到你打算使用密钥登录的账户，然后执行以下命令：</p><p>[root@host ~]$ ssh-keygen  &lt;== 建立密钥对</p><p>Generating public/private rsa key pair.</p><p>Enter file in which to save the key (/root/.ssh/id_rsa): &lt;== 按 Enter</p><p>Created directory ‘/root/.ssh’.</p><p>Enter passphrase (empty for no passphrase): &lt;== 输入密钥锁码，或直接按 Enter 留空</p><p>Enter same passphrase again: &lt;== 再输入一遍密钥锁码</p><p>Your identification has been saved in /root/.ssh/id_rsa. &lt;== 私钥</p><p>Your public key has been saved in /root/.ssh/id_rsa.pub. &lt;== 公钥</p><p>The key fingerprint is:</p><p>0f:d3:e7:1a:1c:bd:5c:03:f1:19:f1:22:df:9b:cc:08 root@host</p><p>密钥锁码在使用私钥时必须输入，这样就可以保护私钥不被盗用。当然，也可以留空，实现无密码登录。</p><p>现在，在 root 用户的家目录中生成了一个 .ssh 的隐藏目录，内含两个密钥文件。id_rsa 为私钥，id_rsa.pub 为公钥。</p><h3 id="3-2-2-在服务器上安装公钥"><strong>3.2.2 在服务器上安装公钥</strong></h3><p>键入以下命令，在服务器上安装公钥：</p><p>[root@host ~]$ cd .ssh</p><p>[root@host .ssh]$ cat id_rsa.pub &gt;&gt; authorized_keys</p><p>如此便完成了公钥的安装。为了确保连接成功，请保证以下文件权限正确：</p><p>[root@host .ssh]$ chmod 600 authorized_keys</p><p>[root@host .ssh]$ chmod 700 ~/.ssh</p><h3 id="3-2-3-设置-SSH，打开密钥登录功能"><strong>3.2.3 设置 SSH，打开密钥登录功能</strong></h3><p>编辑 /etc/ssh/sshd_config 文件，进行如下设置：</p><p>RSAAuthentication yes</p><p>PubkeyAuthentication yes</p><p>另外，请留意 root 用户能否通过 SSH 登录：</p><p>PermitRootLogin yes</p><p>当你完成全部设置，并以密钥方式登录成功后，再禁用密码登录：</p><p>PasswordAuthentication no</p><p>最后，重启 SSH 服务：</p><p>[root@host .ssh]$ service sshd restart</p><h3 id="3-2-4-将私钥下载到客户端，然后转换为PuTTY能使用的格式"><strong>3.2.4 将私钥下载到客户端，然后转换为PuTTY能使用的格式</strong></h3><p>使用 WinSCP、SFTP 等工具将私钥文件 id_rsa 下载到客户端机器上。然后打开 PuTTYGen，单击 Actions 中的 Load 按钮，载入你刚才下载到的私钥文件。如果你刚才设置了密钥锁码，这时则需要输入。</p><p>载入成功后，PuTTYGen 会显示密钥相关的信息。在 Key comment 中键入对密钥的说明信息，然后单击 Save private key 按钮即可将私钥文件存放为 PuTTY 能使用的格式。</p><p>今后，当你使用 PuTTY 登录时，可以在左侧的 Connection -&gt; SSH -&gt; Auth 中的 Private key file for authentication: 处选择你的私钥文件，然后即可登录了，过程中只需输入密钥锁码即可。</p><h2 id="3-3-配置防火墙"><strong>3.3 配置防火墙</strong></h2><h3 id="centos7-Firewall防火墙开启80端口"><strong>centos7 Firewall防火墙开启80端口</strong></h3><p>centos7 默认是FirewallD 提供支持网络/防火墙区域(zone)定义网络链接以及接口安全等级的动态防火墙管理工具，利用FirewallD开启80端口操作如下：</p><p>开启80端口</p><p>$ sudo firewall-cmd --zone=public --add-port=80/tcp --permanent</p><p>出现success表明添加成功</p><p>命令含义：</p><p>–zone #作用域</p><p>–add-port=80/tcp #添加端口，格式为：端口/通讯协议</p><p>–permanent #永久生效，没有此参数重启后失效</p><p>重启防火墙</p><p>systemctl restart firewalld.service</p><p>1、运行、停止、禁用firewalld</p><p>启动：# systemctl start firewalld</p><p>查看状态：# systemctl status firewalld 或者 firewall-cmd –state</p><p>停止：# systemctl disable firewalld</p><p>禁用：# systemctl stop firewalld</p><p>2、配置firewalld</p><p>查看版本：$ firewall-cmd –version</p><p>查看帮助：$ firewall-cmd –help</p><p>查看设置：</p><p>显示状态：$ firewall-cmd –state</p><p>查看区域信息: $ firewall-cmd –get-active-zones</p><p>查看指定接口所属区域：$ firewall-cmd –get-zone-of-interface=eth0</p><p>拒绝所有包：# firewall-cmd –panic-on</p><p>取消拒绝状态：# firewall-cmd –panic-off</p><p>查看是否拒绝：$ firewall-cmd –query-panic</p><p>更新防火墙规则：# firewall-cmd –reload</p><p>firewall-cmd –complete-reload</p><p>两者的区别就是第一个无需断开连接，就是firewalld特性之一动态添加规则，第二个需要断开连接，类似重启服务</p><p>将接口添加到区域，默认接口都在public</p><p>firewall-cmd –zone=public –add-interface=eth0</p><p>永久生效再加上 –permanent 然后reload防火墙</p><p>设置默认接口区域</p><p>firewall-cmd –set-default-zone=public</p><p>立即生效无需重启</p><p>打开端口（貌似这个才最常用）</p><p>查看所有打开的端口：</p><p>firewall-cmd –zone=dmz –list-ports</p><p>加入一个端口到区域：</p><p>firewall-cmd –zone=dmz –add-port=8080/tcp</p><p>若要永久生效方法同上</p><p>打开一个服务，类似于将端口可视化，服务需要在配置文件中添加，/etc/firewalld 目录下有services文件夹，这个不详细说了，详情参考文档</p><p>firewall-cmd –zone=work –add-service=smtp</p><p>移除服务</p><p>firewall-cmd –zone=work –remove-service=smtp</p><p>原文链接：<a class="link"   href="http://www.zhaokeli.com/article/6321.html" >http://www.zhaokeli.com/article/6321.html<i class="fas fa-external-link-alt"></i></a></p><p>附：systemctl命令如下 <br>systemctl is-enabled iptables.service <br>systemctl is-enabled servicename.service #查询服务是否开机启动 <br>systemctl enable *.service #开机运行服务 <br>systemctl disable *.service #取消开机运行 <br>systemctl start *.service #启动服务 <br>systemctl stop *.service #停止服务 <br>systemctl restart *.service #重启服务 <br>systemctl reload *.service #重新加载服务配置文件 <br>systemctl status *.service #查询服务运行状态 <br>systemctl –failed #显示启动失败的服务</p><p>注：*代表某个服务的名字，如http的服务名为httpd</p><h3 id="CentOS6防火墙开启80，3306端口"><strong>CentOS6防火墙开启80，3306端口</strong></h3><p>$ sudo vi /etc/sysconfig/iptables</p><p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT（允许80端口通过防火墙）</p><p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT（允许3306端口通过防火墙）</p><p>特别提示：很多网友把这两条规则添加到防火墙配置的最后一行，导致防火墙启动失败，正确的应该是添加到默认的22端口这条规则的下面</p><p>添加好之后防火墙规则如下所示：</p><p>代码如下：</p><h1>Firewall configuration written by system-config-firewall</h1><h1>Manual customization of this file is not recommended.</h1><p>*filter</p><p>:INPUT ACCEPT [0:0]</p><p>:FORWARD ACCEPT [0:0]</p><p>:OUTPUT ACCEPT [0:0]</p><p>-A INPUT -m state –state ESTABLISHED,RELATED -j ACCEPT</p><p>-A INPUT -p icmp -j ACCEPT</p><p>-A INPUT -i lo -j ACCEPT</p><p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 22 -j ACCEPT</p><p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 80 -j ACCEPT</p><p>-A INPUT -m state –state NEW -m tcp -p tcp –dport 3306 -j ACCEPT</p><p>-A INPUT -j REJECT –reject-with icmp-host-prohibited</p><p>-A FORWARD -j REJECT –reject-with icmp-host-prohibited</p><p>COMMIT</p><p>最后重启防火墙使配置生效</p><p>$ sudo /etc/init.d/iptables restart</p><h1><strong>附录：Linux常用命令</strong></h1><h2 id="1、用户和组"><strong>1、用户和组</strong></h2><p>一、LINUX(UBUNTU/CENTOS)用户添加删除修改</p><p>linux 创建用户</p><p>1、建用户：</p><p>adduser web                             //新建web用户</p><p>useradd web    -m#添加web 用户</p><p>passwd web                               //给web用户设置密码</p><p>useradd web -g admin -n -m //新建web用户并指定用户组为 admin用户组,并自动建立登录目录</p><p>passwd web //给web 用户设置密码</p><p>useradd(选项)(参数)</p><p>-c&lt;备注&gt;：加上备注文字。备注文字会保存在passwd的备注栏位中；</p><p>-d&lt;登入目录&gt;：指定用户登入时的启始目录；</p><p>-D：变更预设值；</p><p>-e&lt;有效期限&gt;：指定帐号的有效期限；</p><p>-f&lt;缓冲天数&gt;：指定在密码过期后多少天即关闭该帐号；</p><p>-g&lt;群组&gt;：指定用户所属的群组；</p><p>-G&lt;群组&gt;：指定用户所属的附加群组；</p><p>-m：自动建立用户的登入目录；</p><p>-M：不要自动建立用户的登入目录；</p><p>-n：取消建立以用户名称为名的群组；</p><p>-r：建立系统帐号；</p><p>-s：指定用户登入后所使用的shell；</p><p>-u：指定用户id。</p><p>2、给已有的用户增加工作组</p><p>usermod -G admin web#给web用户设置admin附属用户组</p><p>#给用户设置添加多个用户组</p><p>usermod -g web -G admin,www web#给web用户设置主用户组web组，admin,www附属用户组</p><p>gpasswd -a web admin#给web用户设置admin用户组</p><p>3、新建用户同时增加工作组</p><p>useradd -g admin web                      //新建web用户并增加到admin工作组</p><p>注：：-g 所属组 -d 家目录 -s 所用的SHELL</p><p>4、临时关闭</p><p>方法一</p><p>/etc/shadow文件中属于该用户的行的第二个字段（密码）前面加上*就可以了。想恢复该用户，去掉*即可。</p><p>方法二</p><p>使用命令关闭用户账号：</p><p>passwd web –l</p><p>重新释放：</p><p>passwd web –u</p><p>5、永久性删除用户账号</p><p>userdel web</p><p>groupdel web</p><p>usermod –G web web   （强制删除该用户的主目录和主目录下的所有文件和子目录）</p><p>7、从组中删除用户</p><p>编辑/etc/group 找到用户组admin那一行，删除用户名web</p><p>或者用命令</p><p>gpasswd -d A web</p><p>8、显示用户信息</p><p>id user</p><p>cat /etc/passwd</p><p>二、用户组 LINUX(UBUNTU/CENTOS) 添加删除修改</p><p>1、建工作组</p><p>groupadd admin                          //新建admin工作组</p><p>2、修改用户组</p><p>groupmod -n newadmin admin#修改admin用户组名称改为newadmin</p><p>3、删除用户组</p><p>groupdel admin#删除admin用户组</p><p>4.查看用户的用户组信息</p><p>groups web</p><h2 id="2、目录和文件cd，ls，ll，rmdir，mkdir，pwd"><strong>2、目录和文件cd，ls，ll，rmdir，mkdir，pwd</strong></h2><p>\1)        pwd命令</p><p>用途：查看工作目录（PrintWorking Directory）</p><p>例：</p><p>[root@web03 home]# pwd</p><p>/home</p><p>pwd命令一般单独使用，无需特别注意命令格式；</p><p>\2)        cd命令</p><p>用途：切换工作目录（Change Directory）</p><p>格式：cd  [目录位置]</p><p>例：</p><p><code>         </code>[root@localhost~]# cd /etc/httpd</p><p>[root@localhost httpd]# cd conf</p><p>[root@localhost conf]# cd ~benet</p><p><code>      </code>目录位置（包括文件位置）可以使用绝对路径，也可以使用相对路径</p><p>绝对路径：以“/”开始的路径，表示从Linux目录结构的最顶点算起</p><p>相对路径：不“/”开始的路径，可以相对于当前目录、父目录、其他用户的目录等作为起始点，使用形式如下：</p><p>直接使用文件名/目录名；</p><p>以“.”或 “…” 开始的路径；</p><p>以“~用户名”的形式开始的路径</p><p><code>  </code>例：</p><p><code>       </code>cd:切换目录，Change Directory</p><p>cd ：不带任何参数表示切换回当前用户的家目录</p><p>cd /path/to/dir ：切换到指定目录</p><p>cd - ：表示在上一个目录和这个目录来回切换，类似于电视遥控器上的返回之前</p><p>cd ~ ：切换回当前的家目录。</p><p>cd ~student ：表示切换到别人的家目录</p><p>cd … ：可以切换到当前目录的父目录</p><p>cd …/… ：可以切换到当前目录父目录的父目录</p><p>cd命令指定短横线“-”作为参数时，表示切换到前一次（执行cd命令前）所在的工作目录</p><p>\3)        ls命令</p><p>用途：用于显示某一个文件的属性，或者某一个目录旗下子目录的属性。</p><p>格式：ls  [选项]…  [目录或文件名]</p><p>常用命令选项</p><p>-l ：以长格式显示</p><p>-a：显示所有子目录和文件的信息，包括隐藏文件</p><p>-d：显示目录本身的属性</p><p>-A：类似于“-a”，但不显示“.”和“…”目录的信息</p><p>-h：以更易读的字节单位（K、M等）显示信息</p><p>Human readable</p><p>-R：递归显示内容</p><p>–color：以颜色区分不同类型文件</p><p>例：</p><p>ls /etc/inittab 直接显示这个文件</p><p>ls /：直接显示根下的文件和子目录</p><p>ls /etc 显示文件夹含有的目录</p><p>-l :显示目录/文件内详细信息。比如 ls-l /etc 则显示etc目录的详细信息</p><p>ls -l后：这里面显示的是元数据信息，他们本身不属于文件内容的部分，但是却跟文件本身息息相关，称之为属性信息，我们都将他称之为元数据信息。</p><p>-h : 将文件信息中的大小变成人类易读的</p><p>-a : 显示所有文件，包括隐藏文件</p><p>-d : 显示的是目录自身的属性，而不是目录中文件或者子目录的属性</p><p>-r : 显示目录，将以逆序的方式进行排序。从Z-A</p><p>-R : 递归现实，显示目录下的每一个文件和子目录，如果目录还有子目录，则继续显示子目录下的文件和子目录，直到显示完全。</p><p>Linux的文件类型：</p><p>a)        普通文件：开头用“-”表示的</p><p>b)        目录文件：开头用“d”表示的</p><p>c)        符号链接文件（软连接文件）：开头用“l”表示</p><p>d)        设备文件：</p><p><code>             </code>i.             块设备，用 b 表示。按照随机存取。通常一次存取一个块。(硬盘)</p><p><code>             </code>ii.             字符设备，用 c 表示，通常按照线性（有顺序）的方式进行存储，一次存取的一个单位是字节。比如键盘，鼠标显示器等。字符存储是串行的。</p><p>e)        套接字文件：开头用“s”  表示 sock</p><p>f)         命令管道文件：开头用“p”表示</p><p>\4)        mkdir命令</p><p>用途：创建新的目录（Make Directory）</p><p>格式：mkdir   [-p]  [/路径/]目录名</p><p>例：</p><p><code>         </code>[root@localhost~]# mkdir -p mydir/level1/level2</p><p>mkdir命令用于创建新的空目录，可以同时创建多个目录</p><p>较常用到的选项为“-p”，该命令用于创建嵌套的多层目录结构</p><p>若不使用“-p”选项，则只能在已经存在的目录中创建其他子目录</p><p>\5)        du命令</p><p>用途：统计目录及文件的空间占用情况（estimate file space usage）</p><p>格式：du  [选项]…  [目录或文件名]</p><p>常用命令选项</p><p>-a：统计时包括所有的文件，而不仅仅只统计目录</p><p>-h：以更易读的字节单位（K、M等）显示信息</p><p>-s：</p><p>例：</p><p><code>      </code>[root@localhost~]# du -sh /etc/httpd/</p><p>du命令的“-s”、“-h”选项通常结合在一起使用，以统计指定文件夹总占用空间的大小</p><h2 id="2、文本编辑vi"><strong>2、文本编辑vi</strong></h2><p>所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。但是目前我们使用比较多的是 vim 编辑器。vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。</p><p><strong>1、什么是 vim？</strong></p><p>Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。连 vim 的官方网站 (<a class="link"   href="http://www.vim.org/" >http://www.vim.org<i class="fas fa-external-link-alt"></i></a>) 自己也说 vim 是一个程序开发工具而不是文字处理软件。vim 键盘图：</p><p><strong>2、vi/vim 的使用</strong></p><p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）<strong>和</strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p><p><strong>命令模式：</strong></p><p>用户刚刚启动 vi/vim，便进入了命令模式。</p><p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><p>以下是常用的几个命令：</p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p><p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><p><strong>输入模式：</strong></p><p>在命令模式下按下i就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li><li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><p><strong>底线命令模式：</strong></p><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件</li></ul><p>按ESC键可随时退出底线命令模式。</p><p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p><p><strong>3、vi/vim 使用实例</strong></p><p><strong>使用 vi/vim 进入一般模式</strong></p><p>如果你想要使用 vi 来建立一个名为 test.txt 的文件时，你可以这样做：</p><p>$ vi runoob.txt</p><p>直接输入 <strong>vi 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！</p><p><strong>按下 i 进入输入模式(也称为编辑模式)，开始编辑文字</strong></p><p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！</p><p>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。</p><p>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p><p><strong>按下 ESC 按钮回到一般模式</strong></p><p>好了，假设我已经按照上面的样式给他编辑完毕了，那么应该要如何退出呢？是的！没错！就是给他按下 <strong>Esc</strong> 这个按钮即可！马上你就会发现画面左下角的 – INSERT – 不见了！</p><p><strong>在一般模式中按下 :wq</strong> <strong>储存后离开 vi</strong></p><p>OK，我们要存档了，存盘并离开的指令很简单，输入 <strong>:wq</strong> 即可保存离开！</p><p>OK! 这样我们就成功创建了一个 runoob.txt 的文件。</p><p><strong>4、vi/vim 按键说明</strong></p><p>除了上面简易范例的 i, Esc, :wq 之外，其实 vim 还有非常多的按键可以使用。</p><p><strong>第一部份：一般模式可用的光标移动、复制粘贴、搜索替换等</strong></p><table><thead><tr><th><strong>移动光标的方法</strong></th><th style="text-align:left"></th></tr></thead><tbody><tr><td>h 或 向左箭头键(←)</td><td style="text-align:left">光标向左移动一个字符</td></tr><tr><td>j 或 向下箭头键(↓)</td><td style="text-align:left">光标向下移动一个字符</td></tr><tr><td>k 或 向上箭头键(↑)</td><td style="text-align:left">光标向上移动一个字符</td></tr><tr><td>l 或 向右箭头键(→)</td><td style="text-align:left">光标向右移动一个字符</td></tr><tr><td>如果你将右手放在键盘上的话，你会发现 hjkl 是排列在一起的，因此可以使用这四个按钮来移动光标。 如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！</td><td style="text-align:left"></td></tr><tr><td>[Ctrl] + [f]</td><td style="text-align:left">屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</td></tr><tr><td>[Ctrl] + [b]</td><td style="text-align:left">屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</td></tr><tr><td>[Ctrl] + [d]</td><td style="text-align:left">屏幕『向下』移动半页</td></tr><tr><td>[Ctrl] + [u]</td><td style="text-align:left">屏幕『向上』移动半页</td></tr><tr><td>+</td><td style="text-align:left">光标移动到非空格符的下一行</td></tr><tr><td>-</td><td style="text-align:left">光标移动到非空格符的上一行</td></tr><tr><td>n<space></td><td style="text-align:left">那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。</td></tr><tr><td>0 或功能键[Home]</td><td style="text-align:left">这是数字『 0 』：移动到这一行的最前面字符处 (常用)</td></tr><tr><td>$ 或功能键[End]</td><td style="text-align:left">移动到这一行的最后面字符处(常用)</td></tr><tr><td>H</td><td style="text-align:left">光标移动到这个屏幕的最上方那一行的第一个字符</td></tr><tr><td>M</td><td style="text-align:left">光标移动到这个屏幕的中央那一行的第一个字符</td></tr><tr><td>L</td><td style="text-align:left">光标移动到这个屏幕的最下方那一行的第一个字符</td></tr><tr><td>G</td><td style="text-align:left">移动到这个档案的最后一行(常用)</td></tr><tr><td>nG</td><td style="text-align:left">n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)</td></tr><tr><td>gg</td><td style="text-align:left">移动到这个档案的第一行，相当于 1G 啊！ (常用)</td></tr><tr><td>n<Enter></td><td style="text-align:left">n 为数字。光标向下移动 n 行(常用)</td></tr><tr><td><strong>搜索替换</strong></td><td style="text-align:left"></td></tr><tr><td>/word</td><td style="text-align:left">向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)</td></tr><tr><td>?word</td><td style="text-align:left">向光标之上寻找一个字符串名称为 word 的字符串。</td></tr><tr><td>n</td><td style="text-align:left">这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td>N</td><td style="text-align:left">这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td>使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td><td style="text-align:left"></td></tr><tr><td>:n1,n2s/word1/word2/g</td><td style="text-align:left">n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则：<br>『:100,200s/vbird/VBIRD/g』。(常用)</td></tr><tr><td>:1,$s/word1/word2/g</td><td style="text-align:left">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td>:1,$s/word1/word2/gc</td><td style="text-align:left">从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</td></tr><tr><td><strong>删除、复制与贴上</strong></td><td style="text-align:left"></td></tr><tr><td>x, X</td><td style="text-align:left">在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)</td></tr><tr><td>nx</td><td style="text-align:left">n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td>dd</td><td style="text-align:left">删除游标所在的那一整行(常用)</td></tr><tr><td>ndd</td><td style="text-align:left">n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)</td></tr><tr><td>d1G</td><td style="text-align:left">删除光标所在到第一行的所有数据</td></tr><tr><td>dG</td><td style="text-align:left">删除光标所在到最后一行的所有数据</td></tr><tr><td>d$</td><td style="text-align:left">删除游标所在处，到该行的最后一个字符</td></tr><tr><td>d0</td><td style="text-align:left">那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td>yy</td><td style="text-align:left">复制游标所在的那一行(常用)</td></tr><tr><td>nyy</td><td style="text-align:left">n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td>y1G</td><td style="text-align:left">复制游标所在行到第一行的所有数据</td></tr><tr><td>yG</td><td style="text-align:left">复制游标所在行到最后一行的所有数据</td></tr><tr><td>y0</td><td style="text-align:left">复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td>y$</td><td style="text-align:left">复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td>p, P</td><td style="text-align:left">p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td>J</td><td style="text-align:left">将光标所在行与下一行的数据结合成同一行</td></tr><tr><td>c</td><td style="text-align:left">重复删除多个数据，例如向下删除 10 行，[ 10cj ]</td></tr><tr><td>u</td><td style="text-align:left">复原前一个动作。(常用)</td></tr><tr><td>[Ctrl]+r</td><td style="text-align:left">重做上一个动作。(常用)</td></tr><tr><td>这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</td><td style="text-align:left"></td></tr><tr><td>.</td><td style="text-align:left">不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</td></tr></tbody></table><p><strong>第二部份：一般模式切换到编辑模式的可用的按钮说明</strong></p><table><thead><tr><th><strong>进入输入或取代的编辑模式</strong></th><th style="text-align:left"></th></tr></thead><tbody><tr><td>i, I</td><td style="text-align:left">进入输入模式(Insert mode)：<br>i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。 (常用)</td></tr><tr><td>a, A</td><td style="text-align:left">进入输入模式(Insert mode)：<br>a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。(常用)</td></tr><tr><td>o, O</td><td style="text-align:left">进入输入模式(Insert mode)：<br>这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』； O 为在目前光标所在处的上一行输入新的一行！(常用)</td></tr><tr><td>r, R</td><td style="text-align:left">进入取代模式(Replace mode)：<br>r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)</td></tr><tr><td>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT 或 REPLACE 才能输入喔！</td><td style="text-align:left"></td></tr><tr><td>[Esc]</td><td style="text-align:left">退出编辑模式，回到一般模式中(常用)</td></tr></tbody></table><p><strong>第三部份：一般模式切换到指令行模式的可用的按钮说明</strong></p><table><thead><tr><th><strong>指令行的储存、离开等指令</strong></th><th style="text-align:left"></th></tr></thead><tbody><tr><td>:w</td><td style="text-align:left">将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td>:w!</td><td style="text-align:left">若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！</td></tr><tr><td>:q</td><td style="text-align:left">离开 vi (常用)</td></tr><tr><td>:q!</td><td style="text-align:left">若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。</td></tr><tr><td>注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</td><td style="text-align:left"></td></tr><tr><td>:wq</td><td style="text-align:left">储存后离开，若为 :wq! 则为强制储存后离开 (常用)</td></tr><tr><td>ZZ</td><td style="text-align:left">这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td></tr><tr><td>:w [filename]</td><td style="text-align:left">将编辑的数据储存成另一个档案（类似另存新档）</td></tr><tr><td>:r [filename]</td><td style="text-align:left">在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面</td></tr><tr><td>:n1,n2 w [filename]</td><td style="text-align:left">将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td>:! command</td><td style="text-align:left">暂时离开 vi 到指令行模式下执行 command 的显示结果！例如<br>『:! ls /home』即可在 vi 当中察看 /home 底下以 ls 输出的档案信息！</td></tr><tr><td><strong>vim 环境的变更</strong></td><td style="text-align:left"></td></tr><tr><td>:set nu</td><td style="text-align:left">显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td>:set nonu</td><td style="text-align:left">与 set nu 相反，为取消行号！</td></tr></tbody></table><p>特别注意，在 vi/vim 中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。</p><p>举例来说，要删除 50 行，则是用 『50dd』 对吧！ 数字加在动作之前，如我要向下移动 20 行呢？那就是『20j』或者是『20↓』即可。</p><h2 id="3、软件包安装yum和rpm"><strong>3、软件包安装yum和rpm</strong></h2><p>一、源代码形式</p><p>1.      绝大多数开源软件都是直接以原码形式发布的</p><p>2.      源代码一般会被打成.tar.gz的归档压缩文件</p><p>3.      源代码需要编译成为二进制形式之后才能够运行使用</p><p>4.      源代码基本编译流程：</p><p>1）.configure 检查编译环境；</p><p>2）make对源代码进行编译；</p><p>3）make insall 将生成的可执行文件安装到当前计算机中</p><p>二、RPM</p><p>1.源代码形式的特点：操作复杂、编译时间长、极易出现问题、依赖关系复杂</p><p>2.为了方便，RPM（redhat package manager）</p><p>3.RPM通过将代码基于特定平台系统编译为可执行文件，并保存依赖关系，来简化开源软件的安装管理。针对不同的系统设定不同的包</p><p>4.常用命令规范：linuxcast-1.2.0-30.el6.1686.rpm 包名-版本号-适用平台-32/64-rpm</p><p>5.使用rpm –i software.rpm(安装)；</p><p>rpm -e software.rpm(卸载)；</p><p>rpm –U software.rpm(升级形式安装)；</p><p>rpm –ivh <a class="link"   href="http://www.linuxcast.net/software.rpm(%E6%94%AF%E6%8C%81%E9%80%9A%E8%BF%87http%5Cftp%E5%8D%8F%E8%AE%AE%E5%BD%A2%E5%BC%8F%E5%AE%89%E8%A3%85)" >http://www.linuxcast.net/software.rpm(支持通过http\ftp协议形式安装)<i class="fas fa-external-link-alt"></i></a></p><p>-v 显示详细信息；-h显示进度条</p><p>查询功能：rpm –qa 列出全部已经安装的.rpm软件  rpm –qa |grep ***</p><p>三：YUM</p><p>1.      rpm软件包形式的管理虽然方便，但是需要手工解决软件包的依赖关系。很多时候安装一个软件安装一个软件需要安装1个或者多个其他软件，手动解决时，很复杂，yum解决这些问题。Yum是rpm的前端程序，主要目的是设计用来自动解决rpm的依赖关系，其特点：</p><p>1）  自动解决依赖关系；2）可以对rpm进行分组，基于组进行安装操作；3）引入仓库概念，支持多个仓库；4）配置简单</p><p>2.      yum仓库用来存放所有的现有的.rpm包，当使用yum安装一个rpm包时，需要依赖关系，会自动在仓库中查找依赖软件并安装。仓库可以是本地的，也可以是HTTP、FTP、nfs形式使用的集中地、统一的网络仓库。</p><p>3.      仓库的配置文件/etc/yum.repos.d目录下</p><p>4.      使用：1）yum install 安装；</p><p>2)yum remove卸载；</p><p>3)yum update 升级制定软件</p><p>5.      安装的时候，会下载软件包.Rpm在安装，所以用国内仓库</p><p>改变镜像源1）访问地址<a class="link"   href="http://mirrors.163.com/%EF%BC%9B2%EF%BC%89%E7%82%B9centos%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%EF%BC%9B3%EF%BC%89%E6%8C%89%E6%AD%A5%E9%AA%A4%E6%9D%A5" >http://mirrors.163.com/；2）点centos使用帮助；3）按步骤来<i class="fas fa-external-link-alt"></i></a></p><p>6.      查询软件：可以使用yumsearch</p><p>Yum: 即Yellowdog Update Modifier,是一种基于rpm的包管理工具</p><p>yum命令使用示例</p><p>显示yum仓库</p><p>显示所有仓库</p><p>yum repolist all</p><p>显示可用的仓库</p><p>repolist enabled</p><p>显示可用的仓库</p><p>repolist disabled</p><p>显示应用程序包</p><p>显示所有的程序包</p><p>yum list</p><p>或</p><p>yum list all</p><p>[vathe@localhost ~]$yum list tre?</p><p>Installed Packages</p><p>tree.x86_64                                         1.6.0-10.el7                                          @base</p><p>还支持通配符格式的查询</p><p>显示可安装的程序包</p><p>yum list available</p><p>[vathe@localhost ~]$yum list available php</p><p>Available Packages</p><p>php.x86_64                                          5.4.16-42.el7                                          base</p><p>显示可更新或已安装的程序包</p><p>yum list updates</p><p>yum list installed</p><p>显示仓库中最近增加的程序包</p><p>yum list recent</p><p>安装程序包</p><p>#安装 tree 程序</p><p>yum install tree</p><p>升级程序包</p><p>yum update tree</p><p>卸载程序包</p><p>yum remove tree</p><p>或</p><p>yum erase tree</p><p>查看程序包信息</p><p>yum info tree</p><p>查看文件的来源</p><p>查看某一文件来自于那个程序包</p><p>[vathe@localhost ~]$yum provides /bin/mv</p><p>coreutils-8.22-18.el7.x86_64 : A set of basic GNU tools commonly used in shell scripts</p><p>Repo        : base</p><p>Matched from:</p><p>Filename    : /bin/mv</p><p>#表示/bin/mv文件来自于coreutils-8.22-18.el7.x86_64程序包</p><p>清理本地缓存</p><p>yum clean all</p><p>#清楚插件缓存</p><p>yum clean plugins</p><p>构建缓存</p><p>yum makecache</p><p>搜索</p><p>[vathe@localhost ~]$yum search php</p><p>============================================== N/S matched: php ===============================================</p><p>graphviz-php.x86_64 : PHP extension for graphviz</p><p>php.x86_64 : PHP scripting language for creating dynamic web sites</p><p>php-bcmath.x86_64 : A module for PHP applications for using the bcmath library</p><p>…</p><p>查看指定包所依赖的capabilities</p><p>[vathe@localhost ~]$yum deplist php</p><p>package: php.x86_64 5.4.16-42.el7</p><p><code>  </code>dependency: httpd</p><p><code> </code>provider: httpd.x86_64 2.4.6-45.el7.centos</p><p>…</p><p>查看yum事务历史</p><p>[root@localhost ~]# yum history</p><p>Repository ‘base’ is missing name in configuration, using id</p><p>ID     | Login user               | Date and time    | Action(s)      | Altered</p><p>-------------------------------------------------------------------------------</p><p><code>   </code>2 | Vathe Su <vathe>         | 2017-04-17 17:07 | Install        |    1</p><p><code>   </code>1 | System <unset>           | 2017-03-23 22:19 | Install        | 1405</p><p>history list</p><p>包组相关的命令</p><p>yum groupinstall    # 安装包组</p><p>yum groupupdate     #更新包组</p><p>yum grouplist       #显示包组</p><p>yum groupremove     #移除包组</p><p>yum groupinfo       #查看包组信息</p><p>yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><p>yum的命令形式一般是如下：yum [options] [command] [package …]</p><p>其中的[options]是可选的，选项包括-h（帮助），-y（当安装过程提示选择全部为&quot;yes&quot;），-q（不显示安装的过程）等等。[command]为所要进行的操作，[package …]是操作的对象。</p><p>概括了部分常用的命令包括：</p><p>自动搜索最快镜像插件：   yum install yum-fastestmirror</p><p>安装yum图形窗口插件：    yum install yumex</p><p>查看可能批量安装的列表： yum grouplist</p><p>1 安装</p><p>yum install 全部安装</p><p>yum install package1 安装指定的安装包package1</p><p>yum groupinsall group1 安装程序组group1</p><p>2 更新和升级</p><p>yum update 全部更新</p><p>yum update package1 更新指定程序包package1</p><p>yum check-update 检查可更新的程序</p><p>yum upgrade package1 升级指定程序包package1</p><p>yum groupupdate group1 升级程序组group1</p><p>3 查找和显示</p><p>yum info package1 显示安装包信息package1</p><p>yum list 显示所有已经安装和可以安装的程序包</p><p>yum list package1 显示指定程序包安装情况package1</p><p>yum groupinfo group1 显示程序组group1信息yum search string 根据关键字string查找安装包</p><p>4 删除程序</p><p>yum remove | erase package1 删除程序包package1</p><p>yum groupremove group1 删除程序组group1</p><p>yum deplist package1 查看程序package1依赖情况</p><p>5 清除缓存</p><p>yum clean packages 清除缓存目录下的软件包</p><p>yum clean headers 清除缓存目录下的 headers</p><p>yum clean oldheaders 清除缓存目录下旧的 headers</p><p>yum clean, yum clean all (= yum clean packages; yum clean oldheaders) 清除缓存目录下的软件包及旧的headers</p><p>比如，要安装游戏程序组，首先进行查找：</p><p>＃：yum grouplist</p><p>可以发现，可安装的游戏程序包名字是”Games and Entertainment“，这样就可以进行安装：</p><p>＃：yum groupinstall “Games and Entertainment”</p><p>所 有的游戏程序包就自动安装了。在这里Games and Entertainment的名字必须用双引号选定，因为linux下面遇到空格会认为文件名结束了，因此必须告诉系统安装的程序包的名字是“Games and Entertainment”而不是“Games&quot;。</p><p>yum，是Yellow dog Updater Modified的简称，起初是由yellow dog这一发行版的开发者Terra Soft研发，用python写成，那时还叫做yup(yellow dog updater)，后经杜克大学的Linux@Duke开发团队进行改进，遂有此名。yum的宗旨是自动化地升级，安装/移除rpm包，收集rpm包的相关信息，检查依赖性并自动提示用户解决。yum的关键之处是要有可靠的repository，顾名思义，这是软件的仓库，它可以是http或ftp站点， 也可以是本地软件池，但必须包含rpm的header， header包括了rpm包的各种信息，包括描述，功能，提供的文件，依赖性等.正是收集了这些 header并加以分析，才能自动化地完成余下的任务。</p><p>1.yum的一切配置信息都储存在一个叫yum.conf的配置文件中，通常位于/etc目 录下，这是整个yum系统的重中之重，我在的F9中查看了这一文件，大家一起来看下：</p><p>[hanlong@localhost F9常用文档]$ sudo more /etc/yum.conf</p><p>[main]</p><p>cachedir=/var/cache/yum</p><p>keepcache=0</p><p>debuglevel=2</p><p>logfile=/var/log/yum.log</p><p>exactarch=1</p><p>obsoletes=1</p><p>gpgcheck=1</p><p>plugins=1</p><p>metadata_expire=1800</p><h1>PUT YOUR REPOS HERE OR IN separate files named file.repo</h1><h1>in /etc/yum.repos.d</h1><p>下面简单的对这一文件作简要的说明：</p><p>cachedir：yum缓存的目录，yum在此存储下载的rpm包和数据库，一般是/var/cache/yum。</p><p>debuglevel：除错级别，0──10,默认是2</p><p>logfile：yum的日志文件，默认是/var/log/yum.log。</p><p>exactarch，有两个选项1和0,代表是否只升级和你安装软件包cpu体系一致的包，如果设为1，则如你安装了一个i386的rpm，则yum不会用686的包来升级。</p><p>gpgchkeck= 有1和0两个选择，分别代表是否是否进行gpg校验，如果没有这一项，默认好像也是检查的。</p><p>2.好了，接下来就是yum的使用了，首先用yum来升级软件，yum的操作大都须有超级用户的权限，当然可以用sudo。</p><p>yum update，这一步是必须的，yum会从服务器的header目录下载rpm的header，放在本地的缓存中，这可能会花费一定的时间，但比起yum 给我们带来方便，这些时间的花费又算的了什么呢？header下载完毕，yum会判断是否有可更新的软件包，如果有，它会询问你的意见，是否更新，还是说 y吧，把系统始终up to date总是不错的，这时yum开始下载软件包并使用调用rpm安装，这可能要一定时间，取决于要更新软件的数目和网络状况，万一网络断了，也没关系，再 进行一次就可以了。升级完毕，以后每天只要使用yum check-update检查一下有无跟新，如果有，就用yum update进行跟新，时刻保持系统为最新，堵住一切发现的漏洞。用yum update packagename 对某个单独包进行升级。</p><p>现在简单的把yum软件升级的一些命令罗列一下：</p><p>(更新：我在安装wine的时候是用rpm一个一个安装的，先安装以来关系，然后在安装wine的主包，但是刚刚在论坛上发现来一个好的帖子，就yum的本地安装。参数是-localinstall</p><p>$yum localinstall wine-*</p><p>这样的话，yum会自动安装所有的依赖关系，而不用rpm一个一个的安装了，省了好多工作。</p><p>还有一个与他类似的参数：</p><p>$yum localupdate wine-*</p><p>如果有wine的新版本，而且你也下载到来本地，就可以这样本地更新wine了。)</p><p>1.列出所有可更新的软件清单</p><p>命令：yum check-update</p><p>2.安装所有更新软件</p><p>命令：yum update</p><p>3.仅安装指定的软件</p><p>命令：yum install</p><p>4.仅更新指定的软件</p><p>命令：yum update</p><p>5.列出所有可安裝的软件清单</p><p>命令：yum list</p><p>3.使用yum安装和卸载软件，有个前提是yum安装的软件包都是rpm格式的。</p><p>安装的命令是，yum install xxx，yum会查询数据库，有无这一软件包，如果有，则检查其依赖冲突关系，如果没有依赖冲突，那么最好，下载安装;如果有，则会给出提示，询问是否要同时安装依赖，或删除冲突的包，你可以自己作出判断</p><p>删除的命令是，yum remove xxx，同安装一样，yum也会查询数据库，给出解决依赖关系的提示。</p><p>1.用YUM安装软件包</p><p>命令：yum install</p><p>2.用YUM删除软件包</p><p>命令：yum remove</p><p>4.用yum查询想安装的软件</p><p>我们常会碰到这样的情况，想要安装一个软件，只知道它和某方面有关，但又不能确切知道它的名字。这时yum的查询功能就起作用了。你可以用 yum search keyword这样的命令来进行搜索，比如我们要则安装一个Instant Messenger，但又不知到底有哪些，这时不妨用 yum search messenger这样的指令进行搜索，yum会搜索所有可用rpm的描述，列出所有描述中和messeger有关的rpm包，于是我们可能得到 gaim，kopete等等，并从中选择。</p><p>有时我们还会碰到安装了一个包，但又不知道其用途，我们可以用yum info packagename这个指令来获取信息。</p><p>1.使用YUM查找软件包</p><p>命令：yum search</p><p>2.列出所有可安装的软件包</p><p>命令：yum list</p><p>3.列出所有可更新的软件包</p><p>命令：yum list updates</p><p>4.列出所有已安装的软件包</p><p>命令：yum list installed</p><p>5.列出所有已安装但不在 Yum Repository 內的软件包</p><p>命令：yum list extras</p><p>6.列出所指定的软件包</p><p>命令：yum list 7.使用YUM获取软件包信息</p><p>命令：yum info 8.列出所有软件包的信息</p><p>命令：yum info</p><p>9.列出所有可更新的软件包信息</p><p>命令：yum info updates</p><p>10.列出所有已安裝的软件包信息</p><p>命令：yum info installed</p><p>11.列出所有已安裝但不在 Yum Repository 內的软件包信息</p><p>命令：yum info extras</p><p>12.列出软件包提供哪些文件</p><p>命令：yum provides</p><p>5.清除YUM缓存</p><p>yum 会把下载的软件包和header存储在cache中，而不会自动删除。如果我们觉得它们占用了磁盘空间，可以使用yum clean指令进行清除，更精确的用法是yum clean headers清除header，yum clean packages清除下载的rpm包，yum clean all 清除所有</p><p>1.清除缓存目录(/var/cache/yum)下的软件包</p><p>命令：yum clean packages</p><p>2.清除缓存目录(/var/cache/yum)下的 headers</p><p>命令：yum clean headers</p><p>3.清除缓存目录(/var/cache/yum)下旧的 headers</p><p>命令：yum clean oldheaders</p><p>4.清除缓存目录(/var/cache/yum)下的软件包及旧的headers</p><p>命令：yum clean, yum clean all (= yum clean packages; yum clean oldheaders)</p><p>以上所有命令参数的使用都可以用man来查看：</p><p>1、安装图形版yumex：yum install yumex。</p><p>2、安装额外的软件仓库：</p><p><a class="link"   href="http://rpm.livna.org" >rpm.livna.org<i class="fas fa-external-link-alt"></i></a> 的软件包仓库:</p><p>rpm -ivh <a class="link"   href="http://livna-dl.reloumirrors.net" >http://livna-dl.reloumirrors.net<i class="fas fa-external-link-alt"></i></a> … ease-7-2.noarch.rpm</p><p><a class="link"   href="http://freshrpms.net" >freshrpms.net<i class="fas fa-external-link-alt"></i></a> 的软件包仓库:</p><p>rpm –ivh <a class="link"   href="http://ftp.freshrpms.net/pub/fre" >http://ftp.freshrpms.net/pub/fre<i class="fas fa-external-link-alt"></i></a> … 1.1-1.fc.noarch.rpm</p><p>3、安装最快源 yum install yum-fastestmirror</p><p>资源真的是非常丰富，从Centos到Ubuntu，ISO镜像、升级包，应有尽有，上交的兄弟们真是幸福，羡慕啊。不过还好，我们好歹也算是在教育网内，凑合着也可以沾点光，下载一些。</p><p>网址为：<a class="link"   href="ftp://ftp.sjtu.edu.cn/" >ftp://ftp.sjtu.edu.cn/<i class="fas fa-external-link-alt"></i></a></p><p>相应的yum的repo为</p><p>[updates]</p><p>name=Fedora updates</p><p>baseurl=<a class="link"   href="ftp://ftp.sjtu.edu.cn/fedora/linux/updates/$releasever/$basearch/" >ftp://ftp.sjtu.edu.cn/fedora/linux/updates/$releasever/$basearch/<i class="fas fa-external-link-alt"></i></a></p><p>enabled=1</p><p>gpgcheck=0</p><p>[fedora]</p><p>name=Fedora $releasever - $basearch</p><p>baseurl=<a class="link"   href="ftp://ftp.sjtu.edu.cn/fedora/linux/releases/$releasever/Everything/$basearch/os/" >ftp://ftp.sjtu.edu.cn/fedora/linux/releases/$releasever/Everything/$basearch/os/<i class="fas fa-external-link-alt"></i></a></p><p>enabled=1</p><p>gpgcheck=1</p><p>gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-fedora file:///etc/pki/rpm-gpg/RPM-GPG-KEY</p><p>如果在机器上安装了apt管理器，则相应的源为</p><p>repomd <a class="link"   href="ftp://ftp.sjtu.edu.cn/" >ftp://ftp.sjtu.edu.cn/<i class="fas fa-external-link-alt"></i></a> fedora/linux/updates/$(VERSION)/$(ARCH)/</p><p>repomd <a class="link"   href="ftp://ftp.sjtu.edu.cn/" >ftp://ftp.sjtu.edu.cn/<i class="fas fa-external-link-alt"></i></a> fedora/linux/releases/$(VERSION)/Everything/$(ARCH)/os/</p><h2 id="4、压缩解压缩tar，zip"><strong>4、压缩解压缩tar，zip</strong></h2><p>本文介绍了linux下的压缩程式tar、gzip、gunzip、bzip2、bunzip2、compress 、uncompress、 zip、 unzip、rar、unrar等程式，以及如何使用它们对.tar、.gz 、.tar.gz、.tgz、.bz2、.tar.bz2、.Z、. tar.Z、.zip、.rar这10种压缩文件进行操作</p><p>Linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲tar命令的基本用法：</p><p>tar命令的选项有很多(用man tar可以查看到)，但常用的就那么几个选项，下面来举例说明一下：</p><p>?</p><p>1</p><h1>tar -cf all.tar *.jpg</h1><p>这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包 ，-f指定包的文件名。</p><p>?</p><p>1</p><h1>tar -rf all.tar *.gif</h1><p>这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。</p><p>?</p><p>1</p><h1>tar -uf all.tar logo.gif</h1><p>这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。</p><p>?</p><p>1</p><h1>tar -tf all.tar</h1><p>这条命令是列出all.tar包中所有文件，-t是列出文件的意思</p><p>?</p><p>1</p><h1>tar -xf all.tar</h1><p>这条命令是解出all.tar包中所有文件，-x是解开的意思</p><p>以上就是tar的最基本的用法。为了方便用户在打包解包的同时可以压缩或解压文件，tar提供了一种特殊的功能。这就是tar可以在打包或解包的同时调用其它的压缩程序，比如调用gzip、bzip2等。</p><p>\1) tar调用</p><p>gzip是GNU组织开发的一个压缩程序，.gz结尾的文件就是gzip压缩的结果。与gzip 相对的解压程序是gunzip。tar中使用-z这个参数来调用gzip。下面来举例说明一下：</p><p>?</p><p>1</p><h1>tar -czf all.tar.gz *.jpg</h1><p>这条命令是将所有.jpg的文件打成一个tar包，并且将其用gzip压缩，生成一个gzip压缩过的包，包名为all.tar.gz</p><p>?</p><p>1</p><h1>tar -xzf all.tar.gz</h1><p>这条命令是将上面产生的包解开。</p><p>\2) tar调用bzip2</p><p>bzip2是一个压缩能力更强的压缩程序，.bz2结尾的文件就是bzip2压缩的结果。</p><p>与bzip2相对的解压程序是bunzip2。tar中使用-j这个参数来调用gzip。下面来举例说明一下：</p><p>?</p><p>1</p><h1>tar -cjf all.tar.bz2 *.jpg</h1><p>这条命令是将所有.jpg的文件打成一个tar包，并且将其用bzip2压缩，生成一个bzip2压缩过的包，包名为all.tar.bz2</p><p>?</p><p>1</p><h1>tar -xjf all.tar.bz2</h1><p>这条命令是将上面产生的包解开。</p><p>3)tar调用compress</p><p>compress也是一个压缩程序，但是好象使用compress的人不如gzip和bzip2的人多。.Z结尾的文件就是bzip2压缩的结果。与 compress相对的解压程序是uncompress。tar中使用-Z这个参数来调用compress。下面来举例说明一下：</p><p>?</p><p>1</p><h1>tar -cZf all.tar.Z *.jpg</h1><p>这条命令是将所有.jpg的文件打成一个tar包，并且将其用compress压缩，生成一个uncompress压缩过的包，包名为all.tar.Z</p><p>?</p><p>1</p><h1>tar -xZf all.tar.Z</h1><p>这条命令是将上面产生的包解开</p><p>有了上面的知识，你应该可以解开多种压缩文件了，下面对于tar系列的压缩文件作一个小结：</p><p>1)对于.tar结尾的文件</p><p>tar -xf all.tar</p><p>2)对于.gz结尾的文件</p><p>gzip -d all.gz</p><p>gunzip all.gz</p><p>3)对于.tgz或.tar.gz结尾的文件</p><p>tar -xzf all.tar.gz</p><p>tar -xzf all.tgz</p><p>4)对于.bz2结尾的文件</p><p>bzip2 -d all.bz2</p><p>bunzip2 all.bz2</p><p>5)对于tar.bz2结尾的文件</p><p>tar -xjf all.tar.bz2</p><p>6)对于.Z结尾的文件</p><p>uncompress all.Z</p><p>7)对于.tar.Z结尾的文件</p><p>tar -xZf all.tar.z</p><p>另外对于Window下的常见压缩文件.zip和.rar，Linux也有相应的方法来解压它们：</p><p>1)对于.zip</p><p>linux下提供了zip和unzip程序，zip是压缩程序，unzip是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：</p><p>?</p><p>1</p><h1>zip all.zip *.jpg</h1><p>这条命令是将所有.jpg的文件压缩成一个zip包</p><p>?</p><p>1</p><h1>unzip all.zip</h1><p>这条命令是将all.zip中的所有文件解压出来</p><p>2)对于.rar</p><p>要在linux下处理.rar文件，需要安装RAR for Linux，可以从网上下载，但要记住，RAR for Linux 不是免费的；可从<a class="link"   href="http://www.rarsoft.com/download.htm%E4%B8%8B%E8%BD%BDRARfor" >http://www.rarsoft.com/download.htm下载RARfor<i class="fas fa-external-link-alt"></i></a> Linux 3.2.</p><p>0，然后安装：</p><p>?</p><p>1</p><p>2</p><p>3</p><h1>tar -xzpvf rarlinux-3.2.0.tar.gz</h1><h1>cd rar</h1><h1>make</h1><p>这样就安装好了，安装后就有了rar和unrar这两个程序，rar是压缩程序，unrar 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：</p><p>?</p><p>1</p><h1>rar a all *.jpg</h1><p>这条命令是将所有.jpg的文件压缩成一个rar包，名为all.rar，该程序会将.rar 扩展名将自动附加到包名后。</p><p>?</p><p>1</p><h1>unrar e all.rar</h1><p>这条命令是将all.rar中的所有文件解压出来</p><p>到此为至，我们已经介绍过linux下的tar、gzip、gunzip、bzip2、bunzip2、compress 、 uncompress、 zip、unzip、rar、unrar等程式，你应该已经能够使用它们对.tar 、.gz、.tar.gz、.tgz、.bz2、.tar.bz2、. Z、.tar.Z、.zip、.rar这10种压缩文</p><p>件进行解压了，以后应该不需要为下载了一个软件而不知道如何在Linux下解开而烦恼了。而且以上方法对于Unix也基本有效。</p><h2 id="5、用户和权限chmod，chown"><strong>5、用户和权限chmod，chown</strong></h2><p>Linux下数字表示文件的操作权限(777,755,…)</p><p>Linux下。查看某路径下用（ls -l）查看全部文件的具体属性列表时。会看到文件的操作权限。类似“drwxr-xr-x”的字符串。</p><p>这串字符能够分成4段理解。结构为“d + 文件全部者操作权限 + 文件全部者所在组操作权限 + 其余人的操作权限”：</p><p>1，第一段：样例中字母“d”，表示文件所在文件夹</p><p>2，第二段：样例中字符串“rwx”，表示文件全部者对此文件的操作权限</p><p>3，第三段。样例中字符串“r-x”。表示文件全部者所在组对些文件的操作权限</p><p>4。第四段。样例中字符串“r-x”，表示除2、3两种外的不论什么人对此文件的操作权限</p><p>通经常使用三个数字来表示文件的读取、写入、运行权限：</p><p>运行：1</p><p>写入：2</p><p>读取：4</p><p>随便写个数字：755，这个3位数分别相应前面所说的分段：7相应第二段，5相应第三段，5相应第四段。</p><p>含义：</p><p>7：表示文件全部者的权限，4+2+1=7，即文件全部者对该文件有生杀大权，读、写、运行随便。</p><p>5：表示文件全部者所在组的权限：4+1=5。即文件全部者所在组对文件有读、运行权限。没有写权限。</p><p>5：同上，其余人对该文件仅仅有读、运行权限，没有写权限。</p><p>指令名称 : chmod</p><p>使用权限 : 全部使用者</p><p>使用方式 : chmod [-cfvR] [–help] [–version] mode file…</p><p>说明 : Linux/Unix 的档案调用权限分为三级 : 档案拥有者、群组、其它。利用 chmod 能够藉以控制档案怎样被他人所调用。</p><p>參数 :</p><p>mode : 权限设定字串，格式例如以下 : [ugoa…][[±=][rwxX]…][,…]，当中</p><p>u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其它以外的人，a 表示这三者皆是。</p><p>+ 表示添加权限、- 表示取消权限、= 表示唯一设定权限。</p><p>r 表示可读取。w 表示可写入，x 表示可运行。X 表示仅仅有当该档案是个子文件夹或者该档案已经被设定过为可运行。</p><p>-c : 若该档案权限确实已经更改，才显示其更修改作</p><p>-f : 若该档案权限无法被更改也不要显示错误讯息</p><p>-v : 显示权限变更的具体资料</p><p>-R : 对眼下文件夹下的全部档案与子文件夹进行同样的权限变更(即以递回的方式逐个变更)</p><p>–help : 显示辅助说明</p><p>–version : 显示版本号</p><p>范例 :将档案 file1.txt 设为全部人皆可读取 :</p><p>chmod ugo+r file1.txt</p><p>将档案 file1.txt 设为全部人皆可读取 :</p><p>chmod a+r file1.txt</p><p>将档案 file1.txt 与 file2.txt 设为该档案拥有者，与其所属同一个群体者可写入，但其它以外的人则不可写入 :</p><p>chmod ug+w,o-w file1.txt file2.txt</p><p>将 <a class="link"   href="http://ex1.py" >ex1.py<i class="fas fa-external-link-alt"></i></a> 设定为仅仅有该档案拥有者能够运行 :</p><p>chmod u+x <a class="link"   href="http://ex1.py" >ex1.py<i class="fas fa-external-link-alt"></i></a></p><p>将眼下文件夹下的全部档案与子文件夹皆设为不论什么人可读取 :</p><p>chmod -R a+r *</p><p>此外chmod也能够用数字来表示权限如 chmod 777 file</p><p>语法为：chmod abc file</p><p>当中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p><p>r=4，w=2，x=1</p><p>若要rwx属性则4+2+1=7；</p><p>若要rw-属性则4+2=6；</p><p>若要r-x属性则4+1=5。</p><p>范例：</p><p>chmod a=rwx file</p><p>和</p><p>chmod 777 file</p><p>效果同样</p><p>chmod ug=rwx,o=x file</p><p>和</p><p>chmod 771 file</p><p>效果同样</p><p>若用chmod 4755 filename可使此程序具有root的权限.</p><p>指令名称 : chown</p><p>使用权限 : root</p><p>使用方式 : chown [-cfhvR] [–help] [–version] user[] file…</p><p>说明 : Linux/Unix 是多人多工作业系统，全部的档案皆有拥有者。利用 chown 能够将档案的拥有者加以改变。</p><p>一般来说，这个指令仅仅有是由系统管理者(root)所使用。一般使用者没有权限能够改变别人的档案拥有者，也没有权限能够自己的档案拥有者改设为别人。</p><p>仅仅有系统管理者(root)才有这种权限。</p><p>參数 :</p><p>user : 新的档案拥有者的使用者</p><p>IDgroup : 新的档案拥有者的使用者群体(group)</p><p>-c : 若该档案拥有者确实已经更改，才显示其更修改作</p><p>-f : 若该档案拥有者无法被更改也不要显示错误讯息</p><p>-h : 仅仅对于连结(link)进行变更。而非该 link 真正指向的档案</p><p>-v : 显示拥有者变更的具体资料</p><p>-R : 对眼下文件夹下的全部档案与子文件夹进行同样的拥有者变更(即以递回的方式逐个变更)</p><p>–help : 显示辅助说明</p><p>–version : 显示版本号</p><p>范例 :</p><p>将档案 file1.txt 的拥有者设为 users 群体的使用者 jessie :</p><p>chown jessie:users file1.txt</p><p>将眼下文件夹下的全部档案与子文件夹的拥有者皆设为 users 群体的使用者 lamport :</p><p>chmod -R lamport:users *</p><p>-rw------- (600) – 仅仅有属主有读写权限。</p><p>-rw-r–r-- (644) – 仅仅有属主有读写权限；而属组用户和其它用户仅仅有读权限。</p><p>-rwx------ (700) – 仅仅有属主有读、写、运行权限。</p><p>-rwxr-xr-x (755) – 属主有读、写、运行权限。而属组用户和其它用户仅仅有读、运行权限。</p><p>-rwx–x–x (711) – 属主有读、写、运行权限；而属组用户和其它用户仅仅有运行权限。</p><p>-rw-rw-rw- (666) – 全部用户都有文件读、写权限。</p><p>这样的做法不可取。</p><p>-rwxrwxrwx (777) – 全部用户都有读、写、运行权限。更不可取的做法。</p><p>下面是对文件夹的两个普通设定:</p><p>drwx------ (700) - 仅仅有属主可在文件夹中读、写。</p><p>drwxr-xr-x (755) - 全部用户可读该文件夹，但仅仅有属主才干改变文件夹中的内容。</p><p>--------------------------------------------------------------------------</p><p>执行 .sh 文件类型的文件：</p><p>用file命令測试一下看是什么类型的</p><p>file <a class="link"   href="http://xxxx.sh" >xxxx.sh<i class="fas fa-external-link-alt"></i></a></p><p>假设是Bourne-Again shell script 能够sh <a class="link"   href="http://xxxx.sh" >xxxx.sh<i class="fas fa-external-link-alt"></i></a> 或者chmod +x <a class="link"   href="http://xxxx.sh" >xxxx.sh<i class="fas fa-external-link-alt"></i></a> 再./xxx.sh</p><p>一般 .sh 的直接加入x(可运行属性) chmod +x <a class="link"   href="http://xxx.sh" >xxx.sh<i class="fas fa-external-link-alt"></i></a> 然后./xxx.sh就能够了</p><p>chmod是一个改变用户拥有指定文件的权限的命令.r:仅仅读,w:写,x运行.也能够用数字</p><h2 id="6、系统管理systemd"><strong>6、系统管理systemd</strong></h2><p>Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。历史上，Linux 的启动一直采用init进程。下面的命令用来启动服务。</p><p>$ sudo /etc/init.d/apache2 start</p><h1>或者</h1><p>$ service apache2 start</p><p>这种方法有两个缺点。一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。</p><p><strong>1、Systemd 概述</strong></p><p>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl --version</span><br></pre></td></tr></table></figure><p>上面的命令查看 Systemd 的版本。</p><p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反&quot;keep simple, keep stupid&quot;的Unix 哲学。</p><p><strong>图1  Systemd 架构图</strong></p><p><strong>2、系统管理</strong></p><p>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p><p><strong>2.1 systemctl</strong></p><p>systemctl是 Systemd 的主命令，用于管理系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 重启系统</span><br><span class="line"></span><br><span class="line">$ sudo systemctl reboot</span><br><span class="line"></span><br><span class="line"># 关闭系统，切断电源</span><br><span class="line"></span><br><span class="line">$ sudo systemctl poweroff</span><br><span class="line"></span><br><span class="line"># CPU停止工作</span><br><span class="line"></span><br><span class="line">$ sudo systemctl halt</span><br><span class="line"></span><br><span class="line"># 暂停系统</span><br><span class="line"></span><br><span class="line">$ sudo systemctl suspend</span><br><span class="line"></span><br><span class="line"># 让系统进入冬眠状态</span><br><span class="line"></span><br><span class="line">$ sudo systemctl hibernate</span><br><span class="line"></span><br><span class="line"># 让系统进入交互式休眠状态</span><br><span class="line"></span><br><span class="line">$ sudo systemctl hybrid-sleep</span><br><span class="line"></span><br><span class="line"># 启动进入救援状态（单用户状态）</span><br><span class="line"></span><br><span class="line">$ sudo systemctl rescue</span><br></pre></td></tr></table></figure><p><strong>2.2 systemd-analyze</strong></p><p>systemd-analyze命令用于查看启动耗时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 查看启动耗时</span><br><span class="line"></span><br><span class="line">$ systemd-analyze</span><br><span class="line"></span><br><span class="line"># 查看每个服务的启动耗时</span><br><span class="line"></span><br><span class="line">$ systemd-analyze blame</span><br><span class="line"></span><br><span class="line"># 显示瀑布状的启动过程流</span><br><span class="line"></span><br><span class="line">$ systemd-analyze critical-chain</span><br><span class="line"></span><br><span class="line"># 显示指定服务的启动流</span><br><span class="line"></span><br><span class="line">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure><p><strong>2.3 hostnamectl</strong></p><p>hostnamectl命令用于查看当前主机的信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前主机的信息</span><br><span class="line"></span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line"># 设置主机名。</span><br><span class="line"></span><br><span class="line">$ sudo hostnamectl set-hostname rhel7</span><br></pre></td></tr></table></figure><p><strong>2.4 localectl</strong></p><p>localectl命令用于查看本地化设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看本地化设置</span><br><span class="line"></span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line"># 设置本地化参数。</span><br><span class="line"></span><br><span class="line">$ sudo localectl set-locale LANG=en\_GB.utf8</span><br><span class="line"></span><br><span class="line">$ sudo localectl set-keymap en\_GB</span><br></pre></td></tr></table></figure><p><strong>2.5 timedatectl</strong></p><p>timedatectl命令用于查看当前时区设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前时区设置</span><br><span class="line"></span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line"># 显示所有可用的时区</span><br><span class="line"></span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line"># 设置当前时区</span><br><span class="line"></span><br><span class="line">$ sudo timedatectl set-timezone America/New\_York</span><br><span class="line"></span><br><span class="line">$ sudo timedatectl set-time YYYY-MM-DD</span><br><span class="line"></span><br><span class="line">$ sudo timedatectl set-time HH:MM:SS</span><br></pre></td></tr></table></figure><p><strong>2.6 loginctl</strong></p><p>loginctl命令用于查看当前登录的用户。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 列出当前session</span><br><span class="line"></span><br><span class="line">$ loginctl list-sessions</span><br><span class="line"></span><br><span class="line"># 列出当前登录用户</span><br><span class="line"></span><br><span class="line">$ loginctl list-users</span><br><span class="line"></span><br><span class="line"># 列出显示指定用户的信息</span><br><span class="line"></span><br><span class="line">$ loginctl show-user ruanyf</span><br></pre></td></tr></table></figure><p><strong>3、Unit</strong></p><p><strong>3.1 含义</strong></p><p>Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。</p><p>Unit 一共分成12种。</p><ul><li>Service unit：系统服务</li><li>Target unit：多个 Unit 构成的一个组</li><li>Device Unit：硬件设备</li><li>Mount Unit：文件系统的挂载点</li><li>Automount Unit：自动挂载点</li><li>Path Unit：文件或路径</li><li>Scope Unit：不是由 Systemd 启动的外部进程</li><li>Slice Unit：进程组</li><li>Snapshot Unit：Systemd 快照，可以切回某个快照</li><li>Socket Unit：进程间通信的 socket</li><li>Swap Unit：swap 文件</li><li>Timer Unit：定时器</li></ul><p>systemctl list-units命令可以查看当前系统的所有 Unit 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 列出正在运行的 Unit</span><br><span class="line"></span><br><span class="line">$ systemctl list-units</span><br><span class="line"></span><br><span class="line"># 列出所有Unit，包括没有找到配置文件的或者启动失败的</span><br><span class="line"></span><br><span class="line">$ systemctl list-units --all</span><br><span class="line"></span><br><span class="line"># 列出所有没有运行的 Unit</span><br><span class="line"></span><br><span class="line">$ systemctl list-units --all --state=inactive</span><br><span class="line"></span><br><span class="line"># 列出所有加载失败的 Unit</span><br><span class="line"></span><br><span class="line">$ systemctl list-units --failed</span><br><span class="line"></span><br><span class="line"># 列出所有正在运行的、类型为 service 的 Unit</span><br><span class="line"></span><br><span class="line">$ systemctl list-units --type=service</span><br></pre></td></tr></table></figure><p><strong>3.2 Unit 的状态</strong></p><p>systemctl status命令用于查看系统状态和单个 Unit 的状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 显示系统状态</span><br><span class="line"></span><br><span class="line">$ systemctl status</span><br><span class="line"></span><br><span class="line"># 显示单个 Unit 的状态</span><br><span class="line"></span><br><span class="line">$ sysystemctl status bluetooth.service</span><br><span class="line"></span><br><span class="line"># 显示远程主机的某个 Unit 的状态</span><br><span class="line"></span><br><span class="line">$ systemctl -H root@rhel7.example.com status httpd.service</span><br><span class="line"></span><br><span class="line">除了status命令，systemctl还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</span><br><span class="line"></span><br><span class="line"># 显示某个 Unit 是否正在运行</span><br><span class="line"></span><br><span class="line">$ systemctl is-active application.service</span><br><span class="line"></span><br><span class="line"># 显示某个 Unit 是否处于启动失败状态</span><br><span class="line"></span><br><span class="line">$ systemctl is-failed application.service</span><br><span class="line"></span><br><span class="line"># 显示某个 Unit 服务是否建立了启动链接</span><br><span class="line"></span><br><span class="line">$ systemctl is-enabled application.service</span><br></pre></td></tr></table></figure><p><strong>3.3 Unit 管理</strong></p><p>对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 立即启动一个服务</span><br><span class="line"></span><br><span class="line">$ sudo systemctl start apache.service</span><br><span class="line"></span><br><span class="line"># 立即停止一个服务</span><br><span class="line"></span><br><span class="line">$ sudo systemctl stop apache.service</span><br><span class="line"></span><br><span class="line"># 重启一个服务</span><br><span class="line"></span><br><span class="line">$ sudo systemctl restart apache.service</span><br><span class="line"></span><br><span class="line"># 杀死一个服务的所有子进程</span><br><span class="line"></span><br><span class="line">$ sudo systemctl kill apache.service</span><br><span class="line"></span><br><span class="line"># 重新加载一个服务的配置文件</span><br><span class="line"></span><br><span class="line">$ sudo systemctl reload apache.service</span><br><span class="line"></span><br><span class="line"># 重载所有修改过的配置文件</span><br><span class="line"></span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 显示某个 Unit 的所有底层参数</span><br><span class="line"></span><br><span class="line">$ systemctl show httpd.service</span><br><span class="line"></span><br><span class="line"># 显示某个 Unit 的指定属性的值</span><br><span class="line"></span><br><span class="line">$ systemctl show -p CPUShares httpd.service</span><br><span class="line"></span><br><span class="line"># 设置某个 Unit 的指定属性</span><br><span class="line"></span><br><span class="line">$ sudo systemctl set-property httpd.service CPUShares=500</span><br></pre></td></tr></table></figure><p><strong>3.4 依赖关系</strong></p><p>Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</p><p>systemctl list-dependencies命令列出一个 Unit 的所有依赖。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl list-dependencies nginx.service</span><br></pre></td></tr></table></figure><p>上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用–all参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl list-dependencies --all nginx.service</span><br></pre></td></tr></table></figure><p><strong>4、Unit 的配置文件</strong></p><p><strong>4.1 概述</strong></p><p>每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</p><p>Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p><p>systemctl enable命令用于在上面两个目录之间，建立符号链接关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable clamd@scan.service</span><br></pre></td></tr></table></figure><h1>等同于</h1><p>$ sudo ln -s ‘/usr/lib/systemd/system/clamd@scan.service’ ‘/etc/systemd/system/multi-user.target.wants/clamd@scan.service’</p><p>如果配置文件里面设置了开机启动，systemctl enable命令相当于激活开机启动。</p><p>与之对应的，systemctl disable命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl disable clamd@scan.service</span><br></pre></td></tr></table></figure><p>配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。</p><p><strong>4.2 配置文件的状态</strong></p><p>systemctl list-unit-files命令用于列出所有配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有配置文件</span><br><span class="line"></span><br><span class="line">$ systemctl list-unit-files</span><br><span class="line"></span><br><span class="line"># 列出指定类型的配置文件</span><br><span class="line"></span><br><span class="line">$ systemctl list-unit-files --type=service</span><br></pre></td></tr></table></figure><p>这个命令会输出一个列表。</p><p>$ systemctl list-unit-files</p><p>UNIT FILE              STATE</p><p>chronyd.service        enabled</p><p>clamd@.service         static</p><p>clamd@scan.service     disabled</p><p>这个列表显示每个配置文件的状态，一共有四种。</p><ul><li>enabled：已建立启动链接</li><li>disabled：没建立启动链接</li><li>static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖</li><li>masked：该配置文件被禁止建立启动链接</li></ul><p>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status bluetooth.service</span><br><span class="line"></span><br><span class="line">一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。</span><br><span class="line"></span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">$ sudo systemctl restart httpd.service</span><br></pre></td></tr></table></figure><p><strong>4.3 配置文件的格式</strong></p><p>配置文件就是普通的文本文件，可以用文本编辑器打开。</p><p>systemctl cat命令可以查看配置文件的内容。</p><p>$ systemctl cat atd.service</p><p>[Unit]</p><p>Description=ATD daemon</p><p>[Service]</p><p>Type=forking</p><p>ExecStart=/usr/bin/atd</p><p>[Install]</p><p>WantedBy=multi-user.target</p><p>从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。</p><p>每个区块内部是一些等号连接的键值对。</p><p>[Section]</p><p>Directive1=value</p><p>Directive2=value</p><p>注意，键值对的等号两侧不能有空格。</p><p><strong>4.4 配置文件的区块</strong></p><p>[Unit]区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</p><ul><li>Description：简短描述</li><li>Documentation：文档地址</li><li>Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败</li><li>Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败</li><li>BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行</li><li>Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</li><li>After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动</li><li>Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行</li><li>Condition…：当前 Unit 运行必须满足的条件，否则不会运行</li><li>Assert…：当前 Unit 运行必须满足的条件，否则会报启动失败</li></ul><p>[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p><ul><li>WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中</li><li>RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中</li><li>Alias：当前 Unit 可用于启动的别名</li><li>Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit</li></ul><p>[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p><ul><li>Type：定义启动时的进程行为。它有以下几种值。</li><li>Type=simple：默认值，执行ExecStart指定的命令，启动主进程</li><li>Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出</li><li>Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行</li><li>Type=dbus：当前服务通过D-Bus启动</li><li>Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行</li><li>Type=idle：若有其他任务执行完毕，当前服务才会运行</li><li>ExecStart：启动当前服务的命令</li><li>ExecStartPre：启动当前服务之前执行的命令</li><li>ExecStartPost：启动当前服务之后执行的命令</li><li>ExecReload：重启当前服务时执行的命令</li><li>ExecStop：停止当前服务时执行的命令</li><li>ExecStopPost：停止当其服务之后执行的命令</li><li>RestartSec：自动重启当前服务间隔的秒数</li><li>Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog</li><li>TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数</li><li>Environment：指定环境变量</li></ul><p>Unit 配置文件的完整字段清单，请参考官方文档。</p><p><strong>5、Target</strong></p><p>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</p><p>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于&quot;状态点&quot;，启动某个 Target 就好比启动到某种状态。</p><p>传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前系统的所有 Target</span><br><span class="line"></span><br><span class="line">$ systemctl list-unit-files --type=target</span><br><span class="line"></span><br><span class="line"># 查看一个 Target 包含的所有 Unit</span><br><span class="line"></span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"># 查看启动时的默认 Target</span><br><span class="line"></span><br><span class="line">$ systemctl get-default</span><br><span class="line"></span><br><span class="line"># 设置启动时的默认 Target</span><br><span class="line"></span><br><span class="line">$ sudo systemctl set-default multi-user.target</span><br><span class="line"></span><br><span class="line"># 切换 Target 时，默认不关闭前一个 Target 启动的进程，</span><br><span class="line"></span><br><span class="line"># systemctl isolate 命令改变这种行为，</span><br><span class="line"></span><br><span class="line"># 关闭前一个 Target 里面所有不属于后一个 Target 的进程</span><br><span class="line"></span><br><span class="line">$ sudo systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure><p>Target 与 传统 RunLevel 的对应关系如下。</p><p>Traditional runlevel      New target name     Symbolically linked to…</p><p>Runlevel 0           |    runlevel0.target -&gt; poweroff.target</p><p>Runlevel 1           |    runlevel1.target -&gt; rescue.target</p><p>Runlevel 2           |    runlevel2.target -&gt; multi-user.target</p><p>Runlevel 3           |    runlevel3.target -&gt; multi-user.target</p><p>Runlevel 4           |    runlevel4.target -&gt; multi-user.target</p><p>Runlevel 5           |    runlevel5.target -&gt; graphical.target</p><p>Runlevel 6           |    runlevel6.target -&gt; reboot.target</p><p>它与init进程的主要差别如下。</p><p><strong>（1）默认的 RunLevel</strong>（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</p><p><strong>（2）启动脚本的位置</strong>，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。</p><p><strong>（3）配置文件的位置</strong>，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。</p><p><strong>6、日志管理</strong></p><p>Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf。</p><p>journalctl功能强大，用法非常多。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span><br><span class="line"></span><br><span class="line">$ sudo journalctl</span><br><span class="line"></span><br><span class="line"># 查看内核日志（不显示应用日志）</span><br><span class="line"></span><br><span class="line">$ sudo journalctl -k</span><br><span class="line"></span><br><span class="line"># 查看系统本次启动的日志</span><br><span class="line"></span><br><span class="line">$ sudo journalctl -b</span><br><span class="line"></span><br><span class="line">$ sudo journalctl -b -0</span><br><span class="line"></span><br><span class="line"># 查看上一次启动的日志（需更改设置）</span><br><span class="line"></span><br><span class="line">$ sudo journalctl -b -1</span><br><span class="line"></span><br><span class="line"># 查看指定时间的日志</span><br><span class="line"></span><br><span class="line">$ sudo journalctl --since=&quot;2012-10-30 18:17:16&quot;</span><br><span class="line"></span><br><span class="line">$ sudo journalctl --since &quot;20 min ago&quot;</span><br><span class="line"></span><br><span class="line">$ sudo journalctl --since yesterday</span><br><span class="line"></span><br><span class="line">$ sudo journalctl --since &quot;2015-01-10&quot; --until &quot;2015-01-11 03:00&quot;</span><br><span class="line"></span><br><span class="line">$ sudo journalctl --since 09:00 --until &quot;1 hour ago&quot;</span><br><span class="line"></span><br><span class="line"># 显示尾部的最新10行日志</span><br><span class="line"></span><br><span class="line">$ sudo journalctl -n</span><br><span class="line"></span><br><span class="line"># 显示尾部指定行数的日志</span><br><span class="line"></span><br><span class="line">$ sudo journalctl -n 20</span><br><span class="line"></span><br><span class="line"># 实时滚动显示最新日志</span><br><span class="line"></span><br><span class="line">$ sudo journalctl -f</span><br><span class="line"></span><br><span class="line"># 查看指定服务的日志</span><br><span class="line"></span><br><span class="line">$ sudo journalctl /usr/lib/systemd/systemd</span><br><span class="line"></span><br><span class="line"># 查看指定进程的日志</span><br><span class="line"></span><br><span class="line">$ sudo journalctl \_PID=1</span><br><span class="line"></span><br><span class="line"># 查看某个路径的脚本的日志</span><br><span class="line"></span><br><span class="line">$ sudo journalctl /usr/bin/bash</span><br><span class="line"></span><br><span class="line"># 查看指定用户的日志</span><br><span class="line"></span><br><span class="line">$ sudo journalctl \_UID=33 --since today</span><br><span class="line"></span><br><span class="line"># 查看某个 Unit 的日志</span><br><span class="line"></span><br><span class="line">$ sudo journalctl -u nginx.service</span><br><span class="line"></span><br><span class="line">$ sudo journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line"># 实时滚动显示某个 Unit 的最新日志</span><br><span class="line"></span><br><span class="line">$ sudo journalctl -u nginx.service -f</span><br><span class="line"></span><br><span class="line"># 合并显示多个 Unit 的日志</span><br><span class="line"></span><br><span class="line">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class="line"></span><br><span class="line"># 查看指定优先级（及其以上级别）的日志，共有8级</span><br><span class="line"></span><br><span class="line"># 0: emerg</span><br><span class="line"></span><br><span class="line"># 1: alert</span><br><span class="line"></span><br><span class="line"># 2: crit</span><br><span class="line"></span><br><span class="line"># 3: err</span><br><span class="line"></span><br><span class="line"># 4: warning</span><br><span class="line"></span><br><span class="line"># 5: notice</span><br><span class="line"></span><br><span class="line"># 6: info</span><br><span class="line"></span><br><span class="line"># 7: debug</span><br><span class="line"></span><br><span class="line">$ sudo journalctl -p err -b</span><br><span class="line"></span><br><span class="line"># 日志默认分页输出，--no-pager 改为正常的标准输出</span><br><span class="line"></span><br><span class="line">$ sudo journalctl --no-pager</span><br><span class="line"></span><br><span class="line"># 以 JSON 格式（单行）输出</span><br><span class="line"></span><br><span class="line">$ sudo journalctl -b -u nginx.service -o json</span><br><span class="line"></span><br><span class="line"># 以 JSON 格式（多行）输出，可读性更好</span><br><span class="line"></span><br><span class="line">$ sudo journalctl -b -u nginx.serviceqq</span><br><span class="line"></span><br><span class="line">` `-o json-pretty</span><br><span class="line"></span><br><span class="line"># 显示日志占据的硬盘空间</span><br><span class="line"></span><br><span class="line">$ sudo journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"># 指定日志文件占据的最大空间</span><br><span class="line"></span><br><span class="line">$ sudo journalctl --vacuum-size=1G</span><br><span class="line"></span><br><span class="line"># 指定日志文件保存多久</span><br><span class="line"></span><br><span class="line">$ sudo journalctl --vacuum-time=1years</span><br></pre></td></tr></table></figure><p><strong>7、操作实例</strong></p><p><strong>7.1 开机启动</strong></p><p>对于那些支持 Systemd 的软件，安装的时候，会自动在/usr/lib/systemd/system目录添加一个配置文件。</p><p>如果你想让该软件开机启动，就执行下面的命令（以httpd.service为例）。</p><p>$ sudo systemctl enable httpd</p><p>上面的命令相当于在/etc/systemd/system目录添加一个符号链接，指向/usr/lib/systemd/system里面的httpd.service文件。</p><p>这是因为开机时，Systemd只执行/etc/systemd/system目录里面的配置文件。这也意味着，如果把修改后的配置文件放在该目录，就可以达到覆盖原始配置的效果。</p><p><strong>7.2 启动服务</strong></p><p>设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行systemctl start命令。</p><p>$ sudo systemctl start httpd</p><p>执行上面的命令以后，有可能启动失败，因此要用systemctl status命令查看一下该服务的状态。</p><p>$ sudo systemctl status httpd</p><p>httpd.service - The Apache HTTP Server</p><p><code> </code>Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled)</p><p><code> </code>Active: active (running) since 金 2014-12-05 12:18:22 JST; 7min ago</p><p><code> </code>Main PID: 4349 (httpd)</p><p><code> </code>Status: “Total requests: 1; Current requests/sec: 0; Current traffic:   0 B/sec”</p><p><code> </code>CGroup: /system.slice/httpd.service</p><p><code>         </code>├─4349 /usr/sbin/httpd -DFOREGROUND</p><p><code>         </code>├─4350 /usr/sbin/httpd -DFOREGROUND</p><p><code>         </code>├─4351 /usr/sbin/httpd -DFOREGROUND</p><p><code>         </code>├─4352 /usr/sbin/httpd -DFOREGROUND</p><p><code>         </code>├─4353 /usr/sbin/httpd -DFOREGROUND</p><p><code>         </code>└─4354 /usr/sbin/httpd -DFOREGROUND</p><p>12月 05 12:18:22 localhost.localdomain systemd[1]: Starting The Apache HTTP Server</p><p>12月 05 12:18:22 localhost.localdomain systemd[1]: Started The Apache HTTP Server.</p><p>12月 05 12:22:40 localhost.localdomain systemd[1]: Started The Apache HTTP Server.</p><p>上面的输出结果含义如下。</p><ul><li>Loaded行：配置文件的位置，是否设为开机启动</li><li>Active行：表示正在运行</li><li>Main PID行：主进程ID</li><li>Status行：由应用本身（这里是 httpd ）提供的软件当前状态</li><li>CGroup块：应用的所有子进程</li><li>日志块：应用的日志</li></ul><p><strong>7.3 停止服务</strong></p><p>终止正在运行的服务，需要执行systemctl stop命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop httpd.service</span><br></pre></td></tr></table></figure><p>有时候，该命令可能没有响应，服务停不下来。这时候就不得不&quot;杀进程&quot;了，向正在运行的进程发出kill信号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl kill httpd.service</span><br></pre></td></tr></table></figure><p>此外，重启服务要执行systemctl restart命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart httpd.service</span><br></pre></td></tr></table></figure><p><strong>7.4 读懂配置文件</strong></p><p>一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。</p><p>前面说过，配置文件主要放在/usr/lib/systemd/system目录，也可能在/etc/systemd/system目录。找到配置文件以后，使用文本编辑器打开即可。</p><p>systemctl cat命令可以用来查看配置文件，下面以sshd.service文件为例，它的作用是启动一个 SSH 服务器，供其他用户以 SSH 方式登录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl cat sshd.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line"></span><br><span class="line">Description=OpenSSH server daemon</span><br><span class="line"></span><br><span class="line">Documentation=man:sshd(8) man:sshd\_config(5)</span><br><span class="line"></span><br><span class="line">After=network.target sshd-keygen.service</span><br><span class="line"></span><br><span class="line">Wants=sshd-keygen.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"></span><br><span class="line">EnvironmentFile=/etc/sysconfig/sshd</span><br><span class="line"></span><br><span class="line">ExecStart=/usr/sbin/sshd -D $OPTIONS</span><br><span class="line"></span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line"></span><br><span class="line">Type=simple</span><br><span class="line"></span><br><span class="line">KillMode=process</span><br><span class="line"></span><br><span class="line">Restart=on-failure</span><br><span class="line"></span><br><span class="line">RestartSec=42s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"></span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>可以看到，配置文件分成几个区块，每个区块包含若干条键值对。</p><p>下面依次解释每个区块的内容。</p><p><strong>7.5 [Unit] 区块：启动顺序与依赖关系。</strong></p><p>Unit区块的Description字段给出当前服务的简单描述，Documentation字段给出文档位置。</p><p>接下来的设置是启动顺序和依赖关系，这个比较重要。</p><p>After字段：表示如果network.target或sshd-keygen.service需要启动，那么sshd.service应该在它们之后启动。</p><p>相应地，还有一个Before字段，定义sshd.service应该在哪些服务之前启动。</p><p>注意，After和Before字段只涉及启动顺序，不涉及依赖关系。</p><p>举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。</p><p>设置依赖关系，需要使用Wants字段和Requires字段。</p><p>Wants字段：表示sshd.service与sshd-keygen.service之间存在&quot;弱依赖&quot;关系，即如果&quot;sshd-keygen.service&quot;启动失败或停止运行，不影响sshd.service继续执行。</p><p>Requires字段则表示&quot;强依赖&quot;关系，即如果该服务启动失败或异常退出，那么sshd.service也必须退出。</p><p>注意，Wants字段与Requires字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。</p><p><strong>7.6 [Service] 区块：启动行为</strong></p><p>Service区块定义如何启动当前服务。</p><p><strong>7.6.1 启动命令</strong></p><p>许多软件都有自己的环境参数文件，该文件可以用EnvironmentFile字段读取。</p><p>EnvironmentFile字段：指定当前服务的环境参数文件。该文件内部的key=value键值对，可以用$key的形式，在当前配置文件中获取。</p><p>上面的例子中，sshd 的环境参数文件是/etc/sysconfig/sshd。</p><p>配置文件里面最重要的字段是ExecStart。</p><p>ExecStart字段：定义启动进程时执行的命令。</p><p>上面的例子中，启动sshd，执行的命令是/usr/sbin/sshd -D $OPTIONS，其中的变量$OPTIONS就来自EnvironmentFile字段指定的环境参数文件。</p><p>与之作用相似的，还有如下这些字段。</p><ul><li>ExecReload字段：重启服务时执行的命令</li><li>ExecStop字段：停止服务时执行的命令</li><li>ExecStartPre字段：启动服务之前执行的命令</li><li>ExecStartPost字段：启动服务之后执行的命令</li><li>ExecStopPost字段：停止服务之后执行的命令</li></ul><p>请看下面的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Service]</span><br><span class="line"></span><br><span class="line">ExecStart=/bin/echo execstart1</span><br><span class="line"></span><br><span class="line">ExecStart=</span><br><span class="line"></span><br><span class="line">ExecStart=/bin/echo execstart2</span><br><span class="line"></span><br><span class="line">ExecStartPost=/bin/echo post1</span><br><span class="line"></span><br><span class="line">ExecStartPost=/bin/echo post2</span><br></pre></td></tr></table></figure><p>上面这个配置文件，第二行ExecStart设为空值，等于取消了第一行的设置，运行结果如下。</p><p>execstart2</p><p>post1</p><p>post2</p><p>所有的启动设置之前，都可以加上一个连词号（-），表示&quot;抑制错误&quot;，即发生错误的时候，不影响其他命令的执行。比如，EnvironmentFile=-/etc/sysconfig/sshd（注意等号后面的那个连词号），就表示即使/etc/sysconfig/sshd文件不存在，也不会抛出错误。</p><p><strong>7.6.2 启动类型</strong></p><p>Type字段定义启动类型。它可以设置的值如下。</p><ul><li>simple（默认值）：ExecStart字段启动的进程为主进程</li><li>forking：ExecStart字段将以fork()方式启动，此时父进程将会退出，子进程将成为主进程</li><li>oneshot：类似于simple，但只执行一次，Systemd 会等它执行完，才启动其他服务</li><li>dbus：类似于simple，但会等待 D-Bus 信号后启动</li><li>notify：类似于simple，启动结束后会发出通知信号，然后 Systemd 再启动其他服务</li><li>idle：类似于simple，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合</li></ul><p>下面是一个oneshot的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"></span><br><span class="line">Description=Switch-off Touchpad</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"></span><br><span class="line">Type=oneshot</span><br><span class="line"></span><br><span class="line">ExecStart=/usr/bin/touchpad-off</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"></span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>上面的配置文件，启动类型设为oneshot，就表明这个服务只要运行一次就够了，不需要长期运行。</p><p>如果关闭以后，将来某个时候还想打开，配置文件修改如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"></span><br><span class="line">Description=Switch-off Touchpad</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"></span><br><span class="line">Type=oneshot</span><br><span class="line"></span><br><span class="line">ExecStart=/usr/bin/touchpad-off start</span><br><span class="line"></span><br><span class="line">ExecStop=/usr/bin/touchpad-off stop</span><br><span class="line"></span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line"></span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>上面配置文件中，RemainAfterExit字段设为yes，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用systemctl stop命令停止服务，ExecStop指定的命令就会执行，从而重新开启触摸板。</p><p><strong>7.6.3 重启行为</strong></p><p>Service区块有一些字段，定义了重启行为。</p><p>KillMode字段：定义 Systemd 如何停止 sshd 服务。</p><p>上面这个例子中，将KillMode设为process，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对 sshd 很重要，否则你停止服务的时候，会连自己打开的 SSH session 一起杀掉。</p><p>KillMode字段可以设置的值如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉</span><br><span class="line">- process：只杀主进程</span><br><span class="line">- mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</span><br><span class="line">- none：没有进程会被杀掉，只是执行服务的 stop 命令。</span><br></pre></td></tr></table></figure><p>接下来是Restart字段。</p><p>Restart字段：定义了 sshd 退出后，Systemd 的重启方式。</p><p>上面的例子中，Restart设为on-failure，表示任何意外的失败，就将重启sshd。如果 sshd 正常停止（比如执行systemctl stop命令），它就不会重启。</p><p>Restart字段可以设置的值如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- no（默认值）：退出后不会重启</span><br><span class="line">- on-success：只有正常退出时（退出状态码为0），才会重启</span><br><span class="line">- on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启</span><br><span class="line">- on-abnormal：只有被信号终止和超时，才会重启</span><br><span class="line">- on-abort：只有在收到没有捕捉到的信号终止时，才会重启</span><br><span class="line">- on-watchdog：超时退出，才会重启</span><br><span class="line">- always：不管是什么退出原因，总是重启</span><br></pre></td></tr></table></figure><p>对于守护进程，推荐设为on-failure。对于那些允许发生错误退出的服务，可以设为on-abnormal。</p><p>最后是RestartSec字段。</p><p>RestartSec字段：表示 Systemd 重启服务之前，需要等待的秒数。上面的例子设为等待42秒。</p><p><strong>7.7 [Install] 区块</strong></p><p>Install区块，定义如何安装这个配置文件，即怎样做到开机启动。</p><p>WantedBy字段：表示该服务所在的 Target。</p><p>Target的含义是服务组，表示一组服务。WantedBy=multi-user.target指的是，sshd 所在的 Target 是multi-user.target。</p><p>这个设置非常重要，因为执行systemctl enable sshd.service命令时，sshd.service的一个符号链接，就会放在/etc/systemd/system目录下面的multi-user.target.wants子目录之中。</p><p>Systemd 有默认的启动 Target。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl get-default</span><br><span class="line"></span><br><span class="line">multi-user.target</span><br></pre></td></tr></table></figure><p>上面的结果表示，默认的启动 Target 是multi-user.target。在这个组里的所有服务，都将开机启动。这就是为什么systemctl enable命令能设置开机启动的原因。</p><p>使用 Target 的时候，systemctl list-dependencies命令和systemctl isolate命令也很有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查看 multi-user.target 包含的所有服务</span><br><span class="line"></span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"># 切换到另一个 target</span><br><span class="line"></span><br><span class="line"># shutdown.target 就是关机状态</span><br><span class="line"></span><br><span class="line">$ sudo systemctl isolate shutdown.target</span><br></pre></td></tr></table></figure><p>一般来说，常用的 Target 有两个：一个是multi-user.target，表示多用户命令行状态；另一个是graphical.target，表示图形用户状态，它依赖于multi-user.target。官方文档有一张非常清晰的 Target 依赖关系图。</p><p><strong>7.8 Target 的配置文件</strong></p><p>Target 也有自己的配置文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl cat multi-user.target</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line"></span><br><span class="line">Description=Multi-User System</span><br><span class="line"></span><br><span class="line">Documentation=man:systemd.special(7)</span><br><span class="line"></span><br><span class="line">Requires=basic.target</span><br><span class="line"></span><br><span class="line">Conflicts=rescue.service rescue.target</span><br><span class="line"></span><br><span class="line">After=basic.target rescue.service rescue.target</span><br><span class="line"></span><br><span class="line">AllowIsolate=yes</span><br></pre></td></tr></table></figure><p>注意，Target 配置文件里面没有启动命令。</p><p>上面输出结果中，主要字段含义如下。</p><p>Requires字段：要求basic.target一起运行。</p><p>Conflicts字段：冲突字段。如果rescue.service或rescue.target正在运行，multi-user.target就不能运行，反之亦然。</p><p>After：表示multi-user.target在basic.target 、 rescue.service、 rescue.target之后启动，如果它们有启动的话。</p><p>AllowIsolate：允许使用systemctl isolate命令切换到multi-user.target。</p><p><strong>7.9 修改配置文件后重启</strong></p><p>修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 重新加载配置文件</span><br><span class="line"></span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 重启相关服务</span><br><span class="line"></span><br><span class="line">$ sudo systemctl restart foobar</span><br></pre></td></tr></table></figure><h2 id="7、查看设置时区"><strong>7、查看设置时区</strong></h2><p><strong>一、GMT、UTC、CST、DST 时间</strong></p><ul><li>UTC</li></ul><p><code> 　　</code>整个地球分为二十四时区，每个时区都有自己的本地时间。在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时(UTC, Universal Time Coordinated)。</p><ul><li>GMT</li></ul><p><code> 　　</code>格林威治标准时间 (Greenwich Mean Time)指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。(UTC与GMT时间基本相同，本文中不做区分)</p><ul><li>CST</li></ul><p><code> 　　</code>中国标准时间 (China Standard Time)</p><table><thead><tr><th>1</th><th>GMT + 8 = UTC + 8 = CST</th></tr></thead></table><ul><li>DST</li></ul><p><code> 　　</code>夏令时(Daylight Saving Time) 指在夏天太阳升起的比较早时，将时间拨快一小时，以提早日光的使用。（中国不使用）</p><p><strong>二、硬件时间和系统时间</strong></p><ul><li>硬件时间</li></ul><p>RTC(Real-Time Clock)或CMOS时间，一般在主板上靠电池供电，服务器断电后也会继续运行。仅保存日期时间数值，无法保存时区和夏令时设置。</p><ul><li>系统时间</li></ul><p>一般在服务器启动时复制RTC时间，之后独立运行，保存了时间、时区和夏令时设置。</p><p><strong>三、timedatectl 命令</strong></p><p>3.1使用指南</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# timedatectl -h</span><br><span class="line">timedatectl [OPTIONS...] COMMAND ...</span><br><span class="line"> </span><br><span class="line">Query or change system time and date settings.</span><br><span class="line"> </span><br><span class="line">  -h --help                Show this help message</span><br><span class="line">     --version             Show package version</span><br><span class="line">     --no-pager            Do not pipe output into a pager</span><br><span class="line">     --no-ask-password     Do not prompt for password</span><br><span class="line">  -H --host=[USER@]HOST    Operate on remote host</span><br><span class="line">  -M --machine=CONTAINER   Operate on local container</span><br></pre></td></tr></table></figure><p>3.2命令示例(查看当前系统时间)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#timedatectl</span><br><span class="line">#timedatectl status</span><br></pre></td></tr></table></figure><p>3.3设置当前时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-time &quot;YYYY-MM-DD HH:MM:SS&quot;</span><br><span class="line">timedatectl set-time &quot;YYYY-MM-DD&quot;</span><br><span class="line">timedatectl set-time &quot;HH:MM:SS&quot;</span><br></pre></td></tr></table></figure><p>3.4查看所有可用的时区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">timedatectl list-timezones</span><br><span class="line"># 亚洲</span><br><span class="line">timedatectl list-timezones |  grep  -E &quot;Asia/S.*&quot;</span><br></pre></td></tr></table></figure><p>3.5设置时区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure><p>3.6设置硬件时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 硬件时间默认为UTC</span><br><span class="line">timedatectl set-local-rtc 1</span><br><span class="line"># hwclock --systohc --localtime</span><br><span class="line"># 两条命令效果等同</span><br></pre></td></tr></table></figure><p>3.7启动自动同步时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timedatectl set-ntp yes</span><br><span class="line"># yes或no; 1或0也可以</span><br></pre></td></tr></table></figure><p><strong>四、Chrony 服务器</strong></p><p>Chrony：是网络时间协议的 (NTP) 的另一种实现，由两个程序组成，分别是chronyd和chronyc。</p><p>chronyd：是一个后台运行的守护进程，用于调整内核中运行的系统时钟和时钟服务器同步。它确定计算机增减时间的比率，并对此进行补偿。</p><p>chronyc：提供了一个用户界面，用于监控性能并进行多样化的配置。它可以在chronyd实例控制的计算机上工作，也可以在一台不同的远程计算机上工作。</p><p>优势：</p><ul><li>更快的同步只需要数分钟而非数小时时间，从而最大程度减少了时间和频率误差，这对于并非全天 24 小时运行的台式计算机或系统而言非常有用。</li><li>能够更好地响应时钟频率的快速变化，这对于具备不稳定时钟的虚拟机或导致时钟频率发生变化的节能技术而言非常有用。</li><li>在初始同步后，它不会停止时钟，以防对需要系统时间保持单调的应用程序造成影响。</li><li>在应对临时非对称延迟时（例如，在大规模下载造成链接饱和时）提供了更好的稳定性。</li><li>无需对服务器进行定期轮询，因此具备间歇性网络连接的系统仍然可以快速同步时钟。</li></ul><p>注意：在CentOS7下为标配的时间同步服务，当然也可以使用以前的NTP同步方式，不过要安装NTP服务。</p><p>服务端</p><p>4.1安装使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install chrony</span><br><span class="line">systemctl start chronyd</span><br><span class="line">systemctl enable chronyd</span><br></pre></td></tr></table></figure><p>4.2配置文件修改</p><p>当Chrony启动时，它会读取/etc/chrony.conf配置文件中的设置。也就是锁，如果需要更改时间同步的服务器，修改此配置文件即可。</p><p>4.3客户端配置</p><p>客户端的配置文件是同一个文件（/etc/chrony.conf），删掉那些没用的server xxxxxxxxxx iburst</p><p>4.4常用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- accheck 检查NTP访问是否对特定主机可用</span><br><span class="line">- activity 该命令会显示有多少NTP源在线/离线</span><br><span class="line">- add server 手动添加一台新的NTP服务器</span><br><span class="line">- clients 在客户端报告已访问到服务器</span><br><span class="line">- delete 手动移除NTP服务器或对等服务器</span><br><span class="line">- settime 手动设置守护进程时间</span><br><span class="line">- tracking 显示系统时间信息</span><br></pre></td></tr></table></figure><p>4.5案例介绍</p><p>查看当前时间服务器状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chronyc </span><br><span class="line">chronyc&gt; activity #查看当前服务器状态，如下服务器有两个NTP源在线</span><br></pre></td></tr></table></figure><p>查看时间同步的信息来源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# chronyc  sources</span><br><span class="line">210 Number of sources = 2</span><br><span class="line">MS Name/IP address         Stratum Poll Reach LastRx Last sample   </span><br><span class="line">^* time5.aliyun.com              2   6   377    31   +267us[ +573us] +/- 3769us</span><br><span class="line">^- 203.107.6.88                  2   6   377    31  -2586us[-2586us] +/-   38ms</span><br></pre></td></tr></table></figure><p><strong>五、日常使用案例</strong></p><p>centos7从外网同步时间和时区设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 安装</span><br><span class="line">yum install chrony</span><br><span class="line"># 启用</span><br><span class="line">systemctl start chronyd</span><br><span class="line">systemctl enable chronyd</span><br><span class="line"># 设置亚洲时区</span><br><span class="line">timedatectl set-timezone Asia/Shanghai</span><br><span class="line"># 启用NTP同步</span><br><span class="line">timedatectl set-ntp yes</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以用NTP同步时间（不推荐）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 安装ntp服务</span><br><span class="line">yum install ntp</span><br><span class="line"># 开机启动服务</span><br><span class="line">systemctl enable ntpd</span><br><span class="line"># 启动服务</span><br><span class="line">systemctl start ntpd</span><br><span class="line"># 设置亚洲时区</span><br><span class="line">timedatectl set-timezone Asia/Shanghai</span><br><span class="line"># 启用NTP同步</span><br><span class="line">timedatectl set-ntp yes</span><br><span class="line"># 重启ntp服务</span><br><span class="line">systemctl restart ntpd</span><br><span class="line"># 手动同步时间</span><br><span class="line">ntpq -p</span><br></pre></td></tr></table></figure><p>常见问题：</p><p>1、#date看到上的时间和#timedatectl看到的本地时间不同，需要我们注意一样。</p><p>2、(Real-Time Clock)或CMOS时间和本地时间不同，需要执行timedatectl set-local-rtc 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# date</span><br><span class="line">Thu Apr  5 17:22:34 CST 2018</span><br><span class="line">[root@localhost ~]# timedatectl</span><br><span class="line">      Local time: Thu 2018-04-05 17:22:38 CST</span><br><span class="line">  Universal time: Thu 2018-04-05 09:22:38 UTC</span><br><span class="line">        RTC time: Thu 2018-04-05 17:22:35</span><br><span class="line">       Time zone: Asia/Shanghai (CST, +0800)</span><br><span class="line">     NTP enabled: yes</span><br><span class="line">     NTP synchronized: yes</span><br><span class="line">     RTC in local TZ: yes</span><br><span class="line">     DST active: n/a</span><br><span class="line"> </span><br><span class="line">Warning: The system is configured to read the RTC time in the local time zone.</span><br><span class="line">         This mode can not be fully supported. It will create various problems</span><br><span class="line">         with time zone changes and daylight saving time adjustments. The RTC</span><br><span class="line">         time is never updated, it relies on external facilities to maintain it.</span><br><span class="line">         If at all possible, use RTC in UTC by calling</span><br><span class="line">         &#x27;timedatectl set-local-rtc 0&#x27;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>参考：<a class="link"   href="https://www.jianshu.com/p/fb32239ccf2b" >https://www.jianshu.com/p/fb32239ccf2b<i class="fas fa-external-link-alt"></i></a></p><h2 id="8、-常用Linux命令"><strong>8、 常用Linux命令</strong></h2><h3 id="2-1-1-命令帮助"><strong>2.1.1 命令帮助</strong></h3><p>CentOS安装完成，今后的操作都是基于命令行的，后续内容只列出操作命令，不解释该命令的使用方法，可查阅相关手册。可以用下列方法了解具体命令的使用方法和参数。</p><p>列出某个命令的使用手册，PgUp - PgDn翻页，q退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ man tar</span><br></pre></td></tr></table></figure><p>命令帮助，后面加上 | more或者 | less使内容分页，空格键翻页，q退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ tar --help | more</span><br><span class="line"></span><br><span class="line">$ tar --help | less</span><br></pre></td></tr></table></figure><p>一般在VMware虚机（或者阿里云这类的远程虚机）和主机之间，可以用鼠标右键进行命令行的文本粘贴。</p><h3 id="2-1-2-文本编辑器vi"><strong>2.1.2 文本编辑器vi</strong></h3><p>对文本文件或脚本文件的编辑，一般用vi编辑器，简要介绍如下：</p><p>1、编辑某文件，如果此文件不存在，则新建一个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/abc.txt</span><br></pre></td></tr></table></figure><p>2、打开文件后，默认为命令模式，按键“i”进入编辑模式，左下角会出现 – INSERT – 字样。在输入模式中，可以使用以下按键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">•字符按键以及Shift组合，输入字符</span><br><span class="line"></span><br><span class="line">•ENTER，回车键，换行</span><br><span class="line"></span><br><span class="line">•BACK SPACE，退格键，删除光标前一个字符</span><br><span class="line"></span><br><span class="line">•DEL，删除键，删除光标后一个字符</span><br><span class="line"></span><br><span class="line">•方向键，在文本中移动光标</span><br><span class="line"></span><br><span class="line">•HOME/END，移动光标到行首/行尾</span><br><span class="line"></span><br><span class="line">•Page Up/Page Down，上/下翻页</span><br><span class="line"></span><br><span class="line">•Insert，切换光标为输入/替换模式，光标将变成竖线/下划线</span><br><span class="line"></span><br><span class="line">•ESC，退出输入模式，切换到命令模式</span><br></pre></td></tr></table></figure><p>3、编辑完成后ESC，退出输入模式，切换到命令模式。在命令模式下按下:（英文冒号）就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>常用的有 :w 保存，:wq 保存后退出，:q 直接退出。</p><p>一般在VMware虚机（或者阿里云这类的远程虚机）和主机之间，可以用鼠标右键进行文本粘贴。</p><h3 id="2-1-3-压缩解压缩"><strong>2.1.3 压缩解压缩</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">最常用的压缩解压缩的命令是tar</span><br><span class="line"></span><br><span class="line">#这条命令是解出all.tar包中所有文件，-x是解开的意思</span><br><span class="line"></span><br><span class="line">$ tar -xf all.tar</span><br><span class="line"></span><br><span class="line">#这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。</span><br><span class="line"></span><br><span class="line">$ tar -cf all.tar \*.jpg</span><br><span class="line"></span><br><span class="line">#这条命令是将所有.gif的文件增加到all.tar的包里面去</span><br><span class="line"></span><br><span class="line">$ tar -rf all.tar \*.gif</span><br><span class="line"></span><br><span class="line">#这条命令是更新原来tar包all.tar中logo.gif文件</span><br><span class="line"></span><br><span class="line">$ tar -uf all.tar logo.gif</span><br><span class="line"></span><br><span class="line">#这条命令是列出all.tar包中所有文件</span><br><span class="line"></span><br><span class="line">$ tar -tf all.tar</span><br></pre></td></tr></table></figure><p>常用压缩文件的处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1、\*.tar 用 tar -xvf 解压</span><br><span class="line"></span><br><span class="line">2、\*.gz 用 gzip -d或者gunzip 解压</span><br><span class="line"></span><br><span class="line">3、\*.tar.gz和\*.tgz 用 tar -xzf 解压</span><br><span class="line"></span><br><span class="line">4、\*.bz2 用 bzip2 -d或者用bunzip2 解压</span><br><span class="line"></span><br><span class="line">5、\*.tar.bz2用tar -xjf 解压</span><br><span class="line"></span><br><span class="line">6、\*.Z 用 uncompress 解压</span><br><span class="line"></span><br><span class="line">7、\*.tar.Z 用tar -xZf 解压</span><br><span class="line"></span><br><span class="line">8、\*.rar 用 unrar e解压</span><br><span class="line"></span><br><span class="line">9、\*.zip 用 unzip 解压</span><br></pre></td></tr></table></figure><h3 id="2-1-4-软件包安装"><strong>2.1.4 软件包安装</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">yum和rpm是紧密相关的安装命令。</span><br><span class="line"></span><br><span class="line">#查询perl包安装了没有</span><br><span class="line"></span><br><span class="line">$ rpm -q perl</span><br><span class="line"></span><br><span class="line">#查询含perl关键词的包安装了没有</span><br><span class="line"></span><br><span class="line">$ rpm -qa | grep perl</span><br><span class="line"></span><br><span class="line">#安装abc.rpm包</span><br><span class="line"></span><br><span class="line">$ rpm -ivh abc.rpm</span><br><span class="line"></span><br><span class="line">#升级abc.rpm包</span><br><span class="line"></span><br><span class="line">$ rpm -Uvh abc.rpm</span><br><span class="line"></span><br><span class="line">$ yum install perl gcc kernel-devel wget</span><br></pre></td></tr></table></figure><h2 id="9、系统命令"><strong>9、系统命令</strong></h2><p>命令信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">winver 检查windows版本</span><br><span class="line"></span><br><span class="line">arch 显示机器的处理器架构(1)</span><br><span class="line"></span><br><span class="line">uname -m 显示机器的处理器架构(2)</span><br><span class="line"></span><br><span class="line">uname -r 显示正在使用的内核版本</span><br><span class="line"></span><br><span class="line">dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)</span><br><span class="line"></span><br><span class="line">hdparm -i /dev/hda 罗列一个磁盘的架构特性</span><br><span class="line"></span><br><span class="line">hdparm -tT /dev/sda 在磁盘上执行测试性读取操作</span><br><span class="line"></span><br><span class="line">cat /proc/cpuinfo 显示CPU info的信息</span><br><span class="line"></span><br><span class="line">cat /proc/interrupts 显示中断</span><br><span class="line"></span><br><span class="line">cat /proc/meminfo 校验内存使用</span><br><span class="line"></span><br><span class="line">cat /proc/swaps 显示哪些swap被使用</span><br><span class="line"></span><br><span class="line">cat /proc/version 显示内核的版本</span><br><span class="line"></span><br><span class="line">cat /proc/net/dev 显示网络适配器及统计</span><br><span class="line"></span><br><span class="line">cat /proc/mounts 显示已加载的文件系统</span><br><span class="line"></span><br><span class="line">lspci -tv 罗列 PCI 设备</span><br><span class="line"></span><br><span class="line">lsusb -tv 显示 USB 设备</span><br><span class="line"></span><br><span class="line">date 显示系统日期</span><br><span class="line"></span><br><span class="line">cal 2007 显示2007年的日历表</span><br><span class="line"></span><br><span class="line">date 041217002007.00 设置日期和时间 - 月日时分年.秒</span><br><span class="line"></span><br><span class="line">clock -w 将时间修改保存到 BIOS</span><br></pre></td></tr></table></figure><p>关机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now 关闭系统(1)</span><br><span class="line"></span><br><span class="line">init 0 关闭系统(2)</span><br><span class="line"></span><br><span class="line">telinit 0 关闭系统(3)</span><br><span class="line"></span><br><span class="line">shutdown -h hours:minutes &amp; 按预定时间关闭系统</span><br><span class="line"></span><br><span class="line">shutdown -c 取消按预定时间关闭系统</span><br><span class="line"></span><br><span class="line">shutdown -r now 重启(1)</span><br><span class="line"></span><br><span class="line">reboot 重启(2)</span><br><span class="line"></span><br><span class="line">logout 注销</span><br></pre></td></tr></table></figure><p>文件目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">cd /home 进入 &#x27;/ home&#x27; 目录&#x27;</span><br><span class="line"></span><br><span class="line">cd .. 返回上一级目录</span><br><span class="line"></span><br><span class="line">cd ../.. 返回上两级目录</span><br><span class="line"></span><br><span class="line">cd 进入个人的主目录</span><br><span class="line"></span><br><span class="line">cd ~user1 进入个人的主目录</span><br><span class="line"></span><br><span class="line">cd - 返回上次所在的目录</span><br><span class="line"></span><br><span class="line">pwd 显示工作路径</span><br><span class="line"></span><br><span class="line">ls 查看目录中的文件</span><br><span class="line"></span><br><span class="line">ls -F 查看目录中的文件</span><br><span class="line"></span><br><span class="line">ls -l 显示文件和目录的详细资料</span><br><span class="line"></span><br><span class="line">ls -a 显示隐藏文件</span><br><span class="line"></span><br><span class="line">ls -R 显示目录结构和目录内文件</span><br><span class="line"></span><br><span class="line">ls \*[0-9]\* 显示包含数字的文件名和目录名</span><br><span class="line"></span><br><span class="line">tree 显示文件和目录由根目录开始的树形结构(1)</span><br><span class="line"></span><br><span class="line">lstree 显示文件和目录由根目录开始的树形结构(2)</span><br><span class="line"></span><br><span class="line">mkdir dir1 创建一个叫做 &#x27;dir1&#x27; 的目录&#x27;</span><br><span class="line"></span><br><span class="line">mkdir dir1 dir2 同时创建两个目录</span><br><span class="line"></span><br><span class="line">mkdir -p /tmp/dir1/dir2 创建一个目录树</span><br><span class="line"></span><br><span class="line">rm -f file1 删除一个叫做 &#x27;file1&#x27; 的文件&#x27;</span><br><span class="line"></span><br><span class="line">rmdir dir1 删除一个叫做 &#x27;dir1&#x27; 的目录&#x27;</span><br><span class="line"></span><br><span class="line">rm -rf dir1 删除一个叫做 &#x27;dir1&#x27; 的目录并同时删除其内容</span><br><span class="line"></span><br><span class="line">rm -rf dir1 dir2 同时删除两个目录及它们的内容</span><br><span class="line"></span><br><span class="line">mv dir1 new\_dir 重命名/移动 一个目录</span><br><span class="line"></span><br><span class="line">cp file1 file2 复制一个文件</span><br><span class="line"></span><br><span class="line">cp dir/\* . 复制一个目录下的所有文件到当前工作目录</span><br><span class="line"></span><br><span class="line">cp -a /tmp/dir1 . 复制一个目录到当前工作目录</span><br><span class="line"></span><br><span class="line">cp -a dir1 dir2 复制一个目录</span><br><span class="line"></span><br><span class="line">ln -s file1 lnk1 创建一个指向文件或目录的软链接</span><br><span class="line"></span><br><span class="line">ln file1 lnk1 创建一个指向文件或目录的物理链接</span><br><span class="line"></span><br><span class="line">touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)</span><br></pre></td></tr></table></figure><p>文件搜索</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">find / -name file1 从 &#x27;/&#x27; 开始进入根文件系统搜索文件和目录</span><br><span class="line"></span><br><span class="line">find / -user user1 搜索属于用户 &#x27;user1&#x27; 的文件和目录</span><br><span class="line"></span><br><span class="line">find /home/user1 -name \\*.bin 在目录 &#x27;/ home/user1&#x27; 中搜索带有&#x27;.bin&#x27; 结尾的文件</span><br><span class="line"></span><br><span class="line">find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件</span><br><span class="line"></span><br><span class="line">find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件</span><br><span class="line">find / -name \\*.rpm -exec chmod 755 &#x27;&#123;&#125;&#x27; \; 搜索以 &#x27;.rpm&#x27; 结尾的文件并定义其权限</span><br><span class="line"></span><br><span class="line">find / -xdev -name \\*.rpm 搜索以 &#x27;.rpm&#x27; 结尾的文件，忽略光驱、捷盘等可移动设备</span><br><span class="line">locate \\*.ps 寻找以 &#x27;.ps&#x27; 结尾的文件 - 先运行 &#x27;updatedb&#x27; 命令</span><br><span class="line">whereis halt 显示一个二进制文件、源码或man的位置</span><br><span class="line">which halt 显示一个二进制文件或可执行文件的完整路径</span><br></pre></td></tr></table></figure><p>文件系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 &#x27;/ mnt/hda2&#x27; 已经存在</span><br><span class="line">umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 &#x27;/ mnt/hda2&#x27; 退出</span><br><span class="line">fuser -km /mnt/hda2 当设备繁忙时强制卸载</span><br><span class="line">umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用</span><br><span class="line">mount /dev/fd0 /mnt/floppy 挂载一个软盘</span><br><span class="line">mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom</span><br><span class="line">mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom</span><br><span class="line">mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件</span><br><span class="line">mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统</span><br><span class="line">mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备</span><br><span class="line">mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个网络共享</span><br></pre></td></tr></table></figure><p>磁盘空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df -h 显示已经挂载的分区列表</span><br><span class="line"></span><br><span class="line">ls -lSr |more 以尺寸大小排列文件和目录</span><br><span class="line"></span><br><span class="line">du -sh dir1 估算目录 &#x27;dir1&#x27; 已经使用的磁盘空间&#x27;</span><br><span class="line"></span><br><span class="line">du -sk \* | sort -rn 以容量大小为依据依次显示文件和目录的大小</span><br><span class="line"></span><br><span class="line">rpm -q -a --qf &#x27;%10&#123;SIZE&#125;t%&#123;NAME&#125;n&#x27; | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)</span><br><span class="line">dpkg-query -W -f=&#x27;$&#123;Installed-Size;10&#125;t$&#123;Package&#125;n&#x27; | sort -k1,1n 以大小为依据显示已安装的deb包所使用的 空间 (ubuntu, debian类系统)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;strong&gt;一、安装CentOS&lt;/strong&gt;&lt;/h1&gt;
&lt;h1&gt;&lt;strong&gt;二、基本系统设置&lt;/strong&gt;&lt;/h1&gt;
&lt;p&gt;一二详细步骤参考我的另一篇文章：&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://dettry.gi</summary>
      
    
    
    
    <category term="Linux专题" scheme="http://example.com/categories/Linux%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
</feed>
